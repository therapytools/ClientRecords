<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mental Health Client Data Organizer</title>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <style>
        :root {
            --bg-main: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --bg-container: white;
            --text-color-primary: #2c3e50;
            --text-color-secondary: #7f8c8d;
            --text-color-inverted: white;
            --panel-bg: #fafafa;
            --panel-border: #ecf0f1;
            --panel-footer-bg: #fdfdfd;
            --panel-header-bg: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            --item-bg: white;
            --item-active-bg: #e3f2fd;
            --item-border-color: #3498db;
            --item-active-border-color: #2196f3;
            --textarea-bg: white;
            --textarea-border: #ddd;
            --textarea-focus-border: #3498db;
            --textarea-focus-shadow: rgba(52, 152, 219, 0.2);
            --modal-bg: white;
            --modal-text: #333;
            --modal-header-border: #ccc;
            --input-bg: white;
            --input-text: #333;
            --input-border: #ccc;
            --suggestion-bg: #fff5f5;
            --suggestion-border: #e53e3e;
            --suggestion-text: #c53030;
            --resizer-bg: #ecf0f1;
            --deleted-item-text: #000;
        }

        [data-theme="dark"] {
            --bg-main: linear-gradient(135deg, #2c3e50 0%, #1a2533 100%);
            --bg-container: #2d3748;
            --text-color-primary: #e2e8f0;
            --text-color-secondary: #a0aec0;
            --text-color-inverted: #e2e8f0; /* Changed for better contrast on dark headers */
            --panel-bg: #283141;
            --panel-border: #4a5568;
            --panel-footer-bg: #232b38;
            --panel-header-bg: linear-gradient(135deg, #1a2533 0%, #2c3e50 100%);
            --item-bg: #4a5568;
            --item-active-bg: #718096;
            --item-border-color: #63b3ed;
            --item-active-border-color: #90cdf4;
            --appointment-item-active-bg: #5a4a63; /* Dark mode specific */
            --appointment-item-active-border: #c084fc; /* Dark mode specific */
            --textarea-bg: #2d3748;
            --textarea-border: #4a5568;
            --textarea-focus-border: #63b3ed;
            --textarea-focus-shadow: rgba(99, 179, 237, 0.3);
            --modal-bg: #2d3748;
            --modal-text: #e2e8f0;
            --modal-header-border: #4a5568;
            --input-bg: #4a5568;
            --input-text: #e2e8f0;
            --input-border: #718096;
            --suggestion-bg: #4c3030;
            --suggestion-border: #e53e3e;
            --suggestion-text: #fed7d7;
            --resizer-bg: #4a5568;
            --deleted-item-text: #e2e8f0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-main);
            min-height: 100vh;
            padding: 10px;
            overflow: hidden;
            color: var(--text-color-primary);
        }

        .container {
            width: 100%;
            margin: 0 auto;
            background: var(--bg-container);
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
            height: calc(100vh - 20px);
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: var(--text-color-inverted);
            padding: 12px 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }
        
        .header h1 {
            font-size: 1.5rem;
            margin-right: auto;
        }

        .btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        .btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }

        .btn.settings-btn {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
        }

        .btn.save-btn {
             background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        }

        .btn.theme-btn {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            padding: 0;
        }

        .main-content {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }

        .panel {
            border-right: 2px solid var(--panel-border);
            background: var(--panel-bg);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex-grow: 1; /* Allow panels to grow/shrink */
            flex-shrink: 1;
        }

        .panel:last-child {
            border-right: none;
        }
        
        .clients-panel { flex-basis: 20%; min-width: 180px; }
        .appointments-panel { flex-basis: 20%; min-width: 180px;}
        .session-panel { flex-basis: 30%; display: flex; flex-direction: column; min-width: 250px; }
        .soap-panel { flex-basis: 30%; min-width: 250px;}


        .panel-header {
            background: var(--panel-header-bg);
            color: var(--text-color-inverted);
            padding: 12px 15px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            height: 50px;
            min-height: 50px;
        }

        .add-btn {
            background: #27ae60;
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .add-btn:hover {
            background: #229954;
            transform: scale(1.1);
        }
        
        .add-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }

        .panel-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        .panel-footer {
            padding: 10px;
            border-top: 1px solid var(--panel-border);
            background: var(--panel-footer-bg);
            flex-shrink: 0;
        }
        
        input[type="date"] {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--input-border);
            border-radius: 4px;
            font-size: 14px;
            font-family: inherit;
            background-color: var(--input-bg);
            color: var(--input-text);
        }

        /* Client Panel */
        .client-item {
            background: var(--item-bg);
            margin-bottom: 8px;
            padding: 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 4px solid var(--item-border-color);
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            -webkit-user-drag: element;
            user-select: none;
        }
        .client-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .client-item.active {
            background: var(--item-active-bg);
            border-left-color: var(--item-active-border-color);
            font-weight: bold;
        }
        
        .client-item.dragging {
            opacity: 0.5;
        }
        
        .action-buttons {
            position: absolute;
            top: 5px; right: 5px;
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }
        .client-item:hover .action-buttons, .appointment-item:hover .action-buttons, .note-item:hover .action-buttons, .intake-item:hover .action-buttons {
            opacity: 1;
        }
        .action-btn {
            border: none; color: white;
            width: 20px; height: 20px;
            border-radius: 50%;
            cursor: pointer; font-size: 12px;
            display: flex; align-items: center; justify-content: center;
        }
        .archive-btn { background: #f39c12; }
        .delete-btn { background: #e74c3c; }
        .edit-btn { background: #3498db; }
        .timeline-btn { background: #e67e22; }

        /* Appointments Panel */
        .appointment-item {
            background: var(--item-bg); margin-bottom: 8px; padding: 10px;
            border-radius: 6px; cursor: pointer; transition: all 0.2s ease;
            border-left: 4px solid #9b59b6; position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .appointment-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
        }
        .appointment-item.active {
            background: var(--appointment-item-active-bg, #f3e5f5);
            border-left-color: var(--appointment-item-active-border, #9c27b0);
        }
        .appointment-date { font-weight: 600; color: var(--text-color-primary); }

        .note-item {
            background: var(--item-bg); margin-bottom: 8px; padding: 10px;
            border-radius: 6px; cursor: pointer; transition: all 0.2s ease;
            border-left: 4px solid #16a085; position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .note-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
        }
        .note-item.active {
            background: #e8f8f5;
            border-left-color: #138d75;
        }
        [data-theme="dark"] .note-item.active {
            background: #2f4a45;
            border-left-color: #35c9a5;
        }
        .note-name { font-weight: 600; color: var(--text-color-primary); }
        .intake-item {
            background: var(--item-bg); margin-bottom: 8px; padding: 10px;
            border-radius: 6px; cursor: pointer; transition: all 0.2s ease;
            border-left: 4px solid #d35400; position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .intake-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
        }
        .intake-item.active {
            background: #fdf2e9;
            border-left-color: #ba4a00;
        }
        [data-theme="dark"] .intake-item.active {
            background: #4a3a2d;
            border-left-color: #f5b041;
        }
        .list-subheader {
            font-size: 0.8rem;
            font-weight: 700;
            letter-spacing: 0.02em;
            color: var(--text-color-secondary);
            margin: 8px 0 6px;
            text-transform: uppercase;
        }

        /* Session and SOAP Panels */
        textarea {
            width: 100%; border: 1px solid var(--textarea-border); border-radius: 6px;
            padding: 12px; font-family: inherit; font-size: 14px;
            resize: both; /* Allow vertical and horizontal resizing */
            transition: all 0.2s;
            min-height: 50px; /* Ensure a minimum height */
            overflow: auto; /* Show scrollbars when content overflows */
            background-color: var(--textarea-bg);
            color: var(--text-color-primary);
        }
        textarea:focus {
            outline: none; border-color: var(--textarea-focus-border);
            box-shadow: 0 0 0 2px var(--textarea-focus-shadow);
        }
        
        .session-section {
            display: flex; flex-direction: column;
            flex-grow: 1; min-height: 0;
        }
        .session-section .panel-header {
             background: linear-gradient(135deg, #16a085 0%, #138d75 100%);
        }
        .session-section .panel-content {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
        }
        .session-section textarea {
            flex-grow: 1;
        }
        .persistent-notes-section .panel-header {
             background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }
        
        .goals-section .panel-header {
             background: linear-gradient(135deg, #8e44ad 0%, #9b59b6 100%);
        }

        /* Collapsible Section Styles */
        .collapsible-header {
            cursor: pointer;
            user-select: none;
        }

        .collapsible-header:hover {
            opacity: 0.9;
        }

        .collapse-icon {
            transition: transform 0.3s ease;
            font-size: 0.8rem;
            margin-left: 8px;
        }

        .collapse-icon.collapsed {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .collapsible-content.collapsed {
            flex-basis: 50px !important;
            min-height: 50px !important;
            max-height: 50px !important;
            flex-grow: 0;
            flex-shrink: 0;
            overflow: hidden; /* Ensure no content spills over */
        }

        /* Pinning styles for collapsed sections */
        .collapsible-content.collapsed.pinned {
            order: 999; /* Pin to bottom */
        }

        /* Ensure wrapper containers also collapse properly */
        .session-section:has(.collapsible-content.collapsed) {
            flex-basis: 50px !important;
            min-height: 50px !important;
            max-height: 50px !important;
            flex-grow: 0;
            flex-shrink: 0;
        }

        .collapsible-content .panel-content {
            transition: opacity 0.2s ease;
        }

        .collapsible-content.collapsed .panel-content {
            opacity: 0;
            display: none;
        }

        /* Goals Section Scrolling */
        .goals-section .panel-content {
            overflow-y: auto;
            max-height: 100%;
        }

        /* Goals and Objectives Styling */
        .goal-item {
            background: var(--item-bg);
            margin-bottom: 12px;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid #8e44ad;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        .goal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .goal-title {
            font-weight: 600;
            color: var(--text-color-primary);
            flex-grow: 1;
            margin-right: 8px;
        }

        .goal-actions {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        .goal-item:hover .goal-actions {
            opacity: 1;
        }

        .goal-status {
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-right: 8px;
        }

        .goal-status.active {
            background: #d4edda;
            color: #155724;
        }

        .goal-status.completed {
            background: #cce5ff;
            color: #004085;
        }

        .goal-status.discontinued {
            background: #f8d7da;
            color: #721c24;
        }

        .objective-list {
            margin-top: 8px;
            padding-left: 16px;
        }

        .objective-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            font-size: 0.9rem;
        }

        .objective-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .objective-text {
            flex-grow: 1;
            color: var(--text-color-primary);
        }

        .objective-text.completed {
            text-decoration: line-through;
            color: var(--text-color-secondary);
        }

        .add-objective-btn {
            background: none;
            border: 1px dashed #8e44ad;
            color: #8e44ad;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            margin-top: 8px;
            width: 100%;
        }

        .add-objective-btn:hover {
            background: rgba(142, 68, 173, 0.1);
        }

        .generator-card {
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            background: var(--panel-bg);
        }
        .generator-title {
            font-weight: 700;
            margin-bottom: 6px;
        }
        .mini-input {
            width: 100%;
            border: 1px solid var(--input-border);
            border-radius: 6px;
            padding: 7px;
            background: var(--input-bg);
            color: var(--input-text);
            font-family: inherit;
            font-size: 13px;
        }
        .intervention-list {
            max-height: 45vh;
            overflow-y: auto;
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 8px;
            background: var(--panel-bg);
        }
        .intervention-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
            border-bottom: 1px dashed var(--panel-border);
            font-size: 0.92rem;
        }
        .intervention-row:last-child {
            border-bottom: none;
        }
        .goal-generator-modal {
            width: 99.5vw;
            max-width: 1760px;
            max-height: 92vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .goal-generator-card {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 10px;
            padding: 12px;
        }
        .goal-generator-title {
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--text-color-secondary);
            margin-bottom: 8px;
            letter-spacing: 0.2px;
        }
        .setting-input {
            width: 100%;
            box-sizing: border-box;
        }
        .goal-generator-controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }
        .goal-generator-secondary {
            display: grid;
            grid-template-columns: 140px 180px 220px;
            gap: 12px;
            align-items: end;
        }
        .goal-generator-secondary label {
            font-size: 0.9rem;
            font-weight: 600;
        }
        .goal-generator-secondary .setting-input {
            font-size: 0.9rem;
            padding: 7px 8px;
        }
        .goal-generator-modal label {
            font-size: 0.9rem;
        }
        .goal-generator-modal .setting-input {
            font-size: 0.9rem;
        }
        .goal-generator-modal .modality-row-btn {
            font-size: 0.9rem;
        }
        .goal-generator-actions {
            display: flex;
            gap: 10px;
            position: sticky;
            bottom: 0;
            background: var(--modal-bg);
            padding-top: 8px;
            z-index: 3;
        }
        #generatedGoalsReview {
            border-radius: 10px;
            padding: 10px;
            max-height: none !important;
            overflow: visible !important;
        }
        #generatedGoalsReview .generator-card {
            border-radius: 10px;
            padding: 12px;
        }
        .modality-grid {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
        }
        .modality-option {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            color: var(--text-color-primary);
        }
        .modality-row {
            display: grid;
            grid-template-columns: 1fr 34px 34px;
            gap: 8px;
            align-items: center;
        }
        .modality-row-btn {
            width: 34px;
            height: 34px;
            border-radius: 6px;
            border: 1px solid var(--panel-border);
            background: var(--panel-bg);
            color: var(--text-color-primary);
            cursor: pointer;
            font-size: 1rem;
            font-weight: 700;
            line-height: 1;
        }
        .modality-row-btn:hover {
            background: var(--suggestion-bg);
        }

        .soap-section { margin-bottom: 15px; }
        .soap-header {
            background: linear-gradient(135deg, #5D6D7E 0%, #34495E 100%);
            color: var(--text-color-inverted); padding: 8px 12px;
            border-radius: 6px 6px 0 0; font-weight: 600;
            display: flex; justify-content: space-between; align-items: center;
        }
        .copy-btn {
            background: rgba(255, 255, 255, 0.2); border: none; color: var(--text-color-inverted);
            padding: 4px 8px; border-radius: 4px; cursor: pointer;
            font-size: 12px; transition: all 0.2s;
        }
        .copy-btn:hover { background: rgba(255, 255, 255, 0.3); }
        .soap-textarea {
            border-radius: 0 0 6px 6px; border-top: none;
            flex-grow: 1;
            /* overflow-y: hidden; is removed to allow manual resize */
        }

        .suggestion-box {
            background-color: var(--suggestion-bg);
            border: 1px solid var(--suggestion-border);
            border-radius: 6px;
            padding: 10px;
            margin-top: 8px;
            font-size: 14px;
        }
        .suggestion-text {
            color: var(--suggestion-text);
            margin-bottom: 8px;
        }
        .suggestion-actions button {
            background: none;
            border: 1px solid;
            border-radius: 4px;
            padding: 2px 8px;
            font-size: 12px;
            cursor: pointer;
            margin-right: 5px;
        }
        .suggestion-accept { color: #27ae60; border-color: #27ae60; }
        .suggestion-accept-replace { color: #27ae60; border-color: #27ae60; }
        .suggestion-decline { color: #e74c3c; border-color: #e74c3c; }

        .audit-box {
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 10px;
            background: var(--panel-bg);
            margin-top: 8px;
        }
        .audit-summary {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }
        .audit-badge {
            font-weight: 700;
            padding: 3px 8px;
            border-radius: 999px;
            font-size: 0.78rem;
        }
        .audit-badge.pass {
            background: #d1fae5;
            color: #065f46;
        }
        .audit-badge.fail {
            background: #fee2e2;
            color: #991b1b;
        }
        [data-theme="dark"] .audit-badge.pass {
            background: #1f4438;
            color: #a7f3d0;
        }
        [data-theme="dark"] .audit-badge.fail {
            background: #4b2a2a;
            color: #fecaca;
        }
        .audit-items {
            list-style: none;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 5px;
            font-size: 0.86rem;
        }
        .audit-item-pass { color: #1f7a57; }
        .audit-item-fail { color: #c0392b; }
        .audit-remediation {
            margin-top: 10px;
            font-size: 0.84rem;
            color: var(--text-color-secondary);
        }
        .audit-remediation ul {
            margin: 6px 0 0 18px;
            padding: 0;
        }
        .audit-proofing-block {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--panel-border);
        }
        #regularSessionFields {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            min-height: 0;
            overflow-y: auto;
        }
        #sessionInfo {
            width: 100%;
            height: 20lh;
            min-height: 20lh;
            resize: vertical;
            flex: 0 0 auto;
        }
        .audit-proofing-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }
        .audit-proofing-field label {
            font-size: 0.8rem;
            color: var(--text-color-secondary);
            font-weight: 600;
            display: block;
            margin-bottom: 4px;
        }
        .audit-proofing-field textarea {
            min-height: 80px;
            resize: vertical;
        }

        .no-selection {
            color: var(--text-color-secondary); text-align: center;
            margin-top: 50px; font-style: italic;
        }
        .autosave-indicator { color: var(--text-color-inverted); font-size: 12px; margin-left: auto; }
        
        .deleted-list { max-height: 100px; overflow-y: auto; }
        .deleted-item { display: flex; justify-content: space-between; align-items: center; font-size: 0.8rem; padding: 2px 0; color: var(--deleted-item-text); }
        .restore-btn {
             background: #3498db; color: white; border: none;
             padding: 2px 6px; border-radius: 4px; cursor: pointer;
        }
        .clear-deleted-btn {
            background: #e74c3c; color: white; border: none;
            padding: 2px 6px; border-radius: 4px; cursor: pointer;
            width: 100%; margin-top: 5px;
        }

        .resizer {
            background: var(--resizer-bg);
            cursor: col-resize;
            width: 6px;
            flex-shrink: 0;
            z-index: 10;
        }
        .resizer-y {
            background: var(--resizer-bg);
            cursor: row-resize;
            height: 6px;
            flex-shrink: 0;
            z-index: 10;
        }
        
        .hidden {
            display: none !important;
        }
        
        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: var(--modal-bg);
            padding: 24px;
            border-radius: 12px;
            width: 100%;
            max-width: 512px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            position: relative; /* For the close button */
            color: var(--modal-text);
        }

        .modal-content.goal-generator-modal {
            width: min(99vw, 1940px);
            max-width: min(99vw, 1940px);
        }

        .guide-modal-content {
            max-width: min(980px, 92vw);
            max-height: 88vh;
            display: flex;
            flex-direction: column;
        }

        .guide-scroll {
            overflow-y: auto;
            line-height: 1.55;
            padding-right: 6px;
        }

        .guide-scroll h3 {
            margin: 1rem 0 0.5rem;
            font-size: 1.15rem;
        }

        .guide-scroll h4 {
            margin: 0.75rem 0 0.4rem;
            font-size: 1rem;
        }

        .guide-scroll ul {
            margin: 0.4rem 0 0.8rem 1.2rem;
        }

        .guide-scroll li {
            margin-bottom: 0.3rem;
        }

        .guide-callout {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-left: 4px solid var(--item-border-color);
            border-radius: 8px;
            padding: 10px 12px;
            margin: 0.75rem 0;
        }

        .guide-example {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 10px 12px;
            margin-bottom: 0.6rem;
        }

        .guide-checklist {
            list-style: none;
            margin-left: 0;
        }


    </style>
</head>
<body data-theme="light">
    <div class="container">
        <div class="header">
            <h1>Client Data Organizer <span style="font-size: 0.8rem; font-weight: normal; vertical-align: middle;">v1.0.0</span></h1>
            <div id="autoSaveIndicator" class="autosave-indicator" style="opacity: 0;">
                <span id="saveStatus"></span>
            </div>
            <button id="informedConsentBtn" class="btn">Informed Consent</button>
            <button id="cssrsBtn" class="btn">CSSRS</button>
            <button id="soapAuditGuideBtn" class="btn">SOAP Audit Guide</button>
            <button id="interventionBankBtn" class="btn">Intervention Bank</button>
            <button id="manualSaveBtn" class="btn save-btn">Save Now</button>
            <button id="settingsBtn" class="btn settings-btn">Settings</button>
            <button id="themeToggleBtn" class="btn theme-btn" title="Toggle Theme">üåô</button>
        </div>

        <div class="main-content" id="mainGrid">
            <!-- Clients Panel -->
            <div class="panel clients-panel" id="panelClients">
                <div class="panel-header">
                    <span>Clients</span>
                    <div style="display: flex; align-items: center;">
                        <button id="sortClientsBtn" title="Sort A-Z" class="btn" style="padding: 2px 6px; font-size: 12px; margin-right: 8px;">A-Z</button>
                        <button id="addClientBtn" class="add-btn">+</button>
                    </div>
                </div>
                <div class="panel-content" id="clientList">
                    <div class="no-selection">Click + to add a client</div>
                </div>
                <div class="panel-footer">
                     <h3 style="color: var(--text-color-secondary); font-weight: 600; margin-bottom: 0.5rem; font-size: 0.875rem;">Recently Deleted</h3>
                     <div id="deletedClientsList" class="deleted-list"></div>
                     <button id="clearDeletedClientsBtn" class="clear-deleted-btn hidden">Clear All</button>
                </div>
                 <div class="panel-footer">
                     <h3 style="color: var(--text-color-secondary); font-weight: 600; margin-bottom: 0.5rem; font-size: 0.875rem;">Archived</h3>
                     <div id="archivedClientsList" class="deleted-list"></div>
                </div>
            </div>

            <div class="resizer" id="resizer1"></div>

            <!-- Appointments Panel -->
            <div class="panel appointments-panel" id="panelAppointments">
                <div class="panel-header">
                    <span>Appointments & Goals</span>
                </div>
                
                <!-- Tab Navigation -->
                <div style="display: flex; border-bottom: 2px solid var(--panel-border); background: var(--panel-bg); flex-shrink: 0;">
                    <button id="appointmentsTabBtn" class="panel-tab-btn active" style="flex: 1; padding: 12px; border: none; background: none; cursor: pointer; font-weight: 600; color: var(--text-color-primary); border-bottom: 3px solid #3498db;">Appointments</button>
                    <button id="goalsTabBtn" class="panel-tab-btn" style="flex: 1; padding: 12px; border: none; background: none; cursor: pointer; font-weight: 600; color: var(--text-color-secondary); border-bottom: 3px solid transparent;">Treatment Goals</button>
                </div>
                
                <!-- Appointments Tab Content -->
                <div id="appointmentsTabContent" class="panel-content" style="display: flex; flex-direction: column;">
                    <div id="appointmentList" style="flex-grow: 1; overflow-y: auto;">
                        <div class="no-selection">Select a client first</div>
                    </div>
                    <div class="panel-footer">
                         <label for="appointmentDateInput" style="font-weight: 600; color: var(--text-color-secondary); font-size: 0.875rem; margin-bottom: 4px; display: block;">Appointment Date</label>
                         <input type="date" id="appointmentDateInput" style="width: 100%; margin-bottom: 8px;">
                         <div style="display: flex; align-items: center; gap: 8px;">
                             <button id="addAppointmentBtn" class="btn save-btn" style="flex: 1; padding: 8px;">+ Add Appointment</button>
                             <button id="updateAppointmentDateBtn" class="btn" style="flex: 1; padding: 8px;">Update Appointment Date</button>
                         </div>
                         <button id="addIntakeBtn" class="btn" style="width: 100%; margin-top: 8px; padding: 8px; background: linear-gradient(135deg, #d35400 0%, #ba4a00 100%);">+ Add Intake Session</button>
                         <div style="margin-top: 12px; border-top: 1px solid var(--panel-border); padding-top: 10px;">
                             <label for="noteNameInput" style="font-weight: 600; color: var(--text-color-secondary); font-size: 0.875rem; margin-bottom: 4px; display: block;">Notes</label>
                             <input type="text" id="noteNameInput" placeholder="Enter note name" style="width: 100%; margin-bottom: 8px; padding: 8px; border: 1px solid var(--input-border); border-radius: 4px; font-size: 14px; font-family: inherit; background-color: var(--input-bg); color: var(--input-text);">
                             <div style="display: flex; align-items: center; gap: 8px;">
                                 <button id="addNoteBtn" class="btn" style="flex: 1; padding: 8px; background: linear-gradient(135deg, #16a085 0%, #138d75 100%);">+ Add Note</button>
                                 <button id="renameNoteBtn" class="btn" style="flex: 1; padding: 8px; background: linear-gradient(135deg, #7f8c8d 0%, #95a5a6 100%);" disabled>Rename Selected</button>
                             </div>
                         </div>
                    </div>
                     <div class="panel-footer">
                         <h3 style="color: var(--text-color-secondary); font-weight: 600; margin-bottom: 0.5rem; font-size: 0.875rem;">Recently Deleted</h3>
                         <div id="deletedAppointmentsList" class="deleted-list"></div>
                         <button id="clearDeletedAppointmentsBtn" class="clear-deleted-btn hidden">Clear All</button>
                    </div>
                </div>
                
                <!-- Goals Tab Content -->
                <div id="goalsTabContent" class="panel-content" style="display: none; flex-direction: column; overflow-y: auto;">
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid var(--panel-border); flex-shrink: 0;">
                        <span style="font-weight: 600; color: var(--text-color-primary);">Client Goals</span>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <button id="generateGoalsBtn" class="btn" style="padding: 4px 8px; font-size: 0.8rem; background: linear-gradient(135deg, #16a085 0%, #138d75 100%);" disabled>Goal/Objective Generator</button>
                            <button id="addGoalBtnInTab" class="add-btn" disabled>+</button>
                        </div>
                    </div>
                    <div id="goalsListInTab" style="flex-grow: 1; overflow-y: auto; padding: 10px;">
                        <div class="no-selection">Select a client to manage goals</div>
                    </div>
                </div>
            </div>

            <div class="resizer" id="resizer2"></div>

            <!-- Session & Notes Panel -->
            <div class="panel session-panel" id="panelSession">
                 <div id="sessionInfoWrapper" class="session-section" style="flex-basis: 50%;">
                     <div class="panel-header">
                         <span>Session Information</span>
                         <button id="customInstructionsBtn" class="btn" style="padding: 4px 8px; font-size: 0.8rem; margin-right: 8px;" title="Add custom AI instructions for this note">‚öôÔ∏è Instructions</button>
                         <button id="generateNoteBtn" class="btn" style="padding: 4px 8px; font-size: 0.8rem;" disabled>Generate Note</button>
                     </div>
                     <div class="panel-content">
                         <div id="regularSessionFields">
                         <textarea id="sessionInfo" placeholder="Select an appointment to enter session details..." disabled autocorrect="off" autocapitalize="off" spellcheck="true"></textarea>
                         <div id="auditProofingBlock" class="audit-proofing-block">
                             <div style="font-size: 0.85rem; color: var(--text-color-secondary); font-weight: 700; margin-bottom: 6px;">Audit-Proofing</div>
                             <div class="audit-proofing-grid">
                                 <div class="audit-proofing-field">
                                     <label for="auditProofSymptoms">Symptom Pattern / Severity Context</label>
                                     <textarea id="auditProofSymptoms" placeholder="Add symptom trend, frequency, intensity, and client-reported changes." disabled autocorrect="off" autocapitalize="off" spellcheck="true"></textarea>
                                 </div>
                                 <div class="audit-proofing-field">
                                     <label for="auditProofFunctional">Functional Impact</label>
                                     <textarea id="auditProofFunctional" placeholder="Document work/school/relationship/sleep/parenting or daily functioning impact." disabled autocorrect="off" autocapitalize="off" spellcheck="true"></textarea>
                                 </div>
                                 <div class="audit-proofing-field">
                                     <label for="auditProofProgress">Progress / Response to Treatment</label>
                                     <textarea id="auditProofProgress" placeholder="Describe measurable progress, barriers, and response to interventions." disabled autocorrect="off" autocapitalize="off" spellcheck="true"></textarea>
                                 </div>
                                 <div class="audit-proofing-field">
                                     <label for="auditProofGoal">Treatment Goal Alignment</label>
                                     <textarea id="auditProofGoal" placeholder="Link this session to active treatment goals/objectives and progress toward them." disabled autocorrect="off" autocapitalize="off" spellcheck="true"></textarea>
                                 </div>
                                 <div class="audit-proofing-field">
                                     <label for="auditProofNecessity">Medical Necessity Rationale</label>
                                     <textarea id="auditProofNecessity" placeholder="State why continued skilled treatment is needed at this level of care." disabled autocorrect="off" autocapitalize="off" spellcheck="true"></textarea>
                                 </div>
                             </div>
                         </div>
                         </div>
                         <div id="intakeSessionBlock" class="audit-proofing-block hidden">
                             <div style="font-size: 0.85rem; color: var(--text-color-secondary); font-weight: 700; margin-bottom: 6px;">Intake Session Prompts</div>
                             <div id="intakeFieldsContainer" class="audit-proofing-grid"></div>
                         </div>
                     </div>
                     <div class="panel-footer" id="sessionTimerWrapper" style="display: none;">
                         <div style="display: flex; justify-content: space-between; align-items: center; gap: 10px;">
                             <button id="startTimerBtn" class="btn" style="flex-grow: 1;">Start</button>
                             <button id="stopTimerBtn" class="btn" style="flex-grow: 1;">Stop</button>
                             <div id="sessionDuration" style="font-weight: 600; white-space: nowrap;">00:00</div>
                         </div>
                     </div>
                 </div>
                 <div class="resizer-y" id="resizer-session-notes"></div>
                 <div id="notesWrapper" class="session-section persistent-notes-section" style="flex-basis: 50%;">
                     <div class="panel-header collapsible-header" data-target="notesContent">
                         <span>Persistent Notes <span class="collapse-icon">‚ñº</span></span>
                     </div>
                     <div id="notesContent" class="panel-content collapsible-content">
                         <textarea id="persistentNotes" placeholder="Select a client to enter persistent notes..." disabled autocorrect="off" autocapitalize="off" spellcheck="true"></textarea>
                     </div>
                 </div>
            </div>

            <div class="resizer" id="resizer3"></div>

            <!-- SOAP Notes Panel -->
            <div class="panel soap-panel" id="panelSoap">
                <div class="panel-header">
                    <span>SOAP Note</span>
                </div>
                <div class="panel-content" id="soapContent">
                    <div class="no-selection">Select an appointment to begin</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Custom Instructions Modal -->
    <div id="customInstructionsModal" class="modal-overlay hidden">
        <div class="modal-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid var(--modal-header-border);">
                <h2 style="font-size: 1.5rem; font-weight: bold;">Custom AI Instructions</h2>
                <button id="closeCustomInstructionsBtn" style="font-size: 2rem; background: none; border: none; cursor: pointer; color: inherit;">&times;</button>
            </div>

            <div style="margin-bottom: 1rem;">
                <label for="persistentInstructionsInput" style="margin-bottom: 0.5rem; font-weight: 600; display: block;">Persistent Instructions</label>
                <textarea id="persistentInstructionsInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 12px; width: 100%; background-color: var(--input-bg); color: var(--input-text); font-family: inherit; font-size: 14px; min-height: 100px; resize: vertical;" placeholder="Applies across all sessions for this client."></textarea>
            </div>

            <div style="margin-bottom: 1rem;">
                <label for="sessionInstructionsInput" style="margin-bottom: 0.5rem; font-weight: 600; display: block;">Session Instructions</label>
                <textarea id="sessionInstructionsInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 12px; width: 100%; background-color: var(--input-bg); color: var(--input-text); font-family: inherit; font-size: 14px; min-height: 110px; resize: vertical;" placeholder="Applies only to the selected appointment/session."></textarea>
                <div style="font-size: 0.8rem; color: var(--text-color-secondary); margin-top: 4px;">
                    If Session Instructions conflict with Persistent Instructions, Session Instructions override for this note.
                </div>
            </div>

            <div style="margin-bottom: 1rem;">
                <label style="margin-bottom: 0.25rem; font-weight: 600; display: block;">Client Modality Lens (SOAP Default)</label>
                <div style="font-size: 0.82rem; color: var(--text-color-secondary); margin-bottom: 8px;">
                    SOAP generation uses this as the default lens for this client. If session details explicitly indicate different interventions/modalities, those interventions are preserved as written.
                </div>
                <div id="customInstructionsModalitiesList" class="modality-grid"></div>
                <div id="customInstructionsModalityOtherWrap" class="hidden" style="margin-top:8px; max-width: 380px;">
                    <label for="customInstructionsModalityOther" style="font-size:0.9rem; font-weight:600; display:block; margin-bottom:4px;">Other (Specify)</label>
                    <input id="customInstructionsModalityOther" type="text" class="setting-input" placeholder="Optional custom modality..." disabled>
                </div>
            </div>

            <div style="display: flex; gap: 1rem;">
                <button id="saveCustomInstructionsBtn" class="btn save-btn" style="flex-grow: 1;">Save Instructions</button>
                <button id="clearCustomInstructionsBtn" class="btn" style="flex-grow: 1; background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);">Clear Instructions</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal-overlay hidden">
        <div class="modal-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid var(--modal-header-border);">
                <h2 style="font-size: 1.5rem; font-weight: bold;">Settings</h2>
                <button id="closeSettingsBtn" style="font-size: 2rem; background: none; border: none; cursor: pointer; color: inherit;">&times;</button>
            </div>

            <div style="margin-bottom: 1.5rem;">
                <h3 style="font-size: 1.25rem; font-weight: 600; margin-bottom: 0.75rem;">Connection</h3>
                <div style="display: flex; flex-direction: column; gap: 1rem;">
                    <div>
                        <label for="apiProviderSelect" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">API Provider</label>
                        <select id="apiProviderSelect" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);">
                            <option value="openwebui">Open WebUI</option>
                            <option value="gemini">Google Gemini</option>
                            <option value="vertex">Google Vertex AI</option>
                            <option value="openai">OpenAI</option>
                        </select>
                    </div>

                    <div id="openwebuiSettings">
                        <div>
                            <label for="serverAddressInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">Open WebUI Address</label>
                            <input type="text" id="serverAddressInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);" placeholder="e.g., http://localhost:3000">
                        </div>
                        <div>
                            <label for="apiKeyInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">API Key (optional)</label>
                            <input type="password" id="apiKeyInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);">
                        </div>
                    </div>

                    <div id="geminiSettings" class="hidden">
                        <div>
                            <label for="geminiApiKeyInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">Gemini API Key</label>
                            <input type="password" id="geminiApiKeyInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);">
                        </div>
                         <div>
                            <label for="geminiModelInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">Gemini Model</label>
                            <select id="geminiModelInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);" disabled>
                                <option>Enter API Key first</option>
                            </select>
                        </div>
                    </div>

                    <div id="vertexSettings" class="hidden">
                        <div>
                            <label for="vertexProjectIdInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">Vertex Project ID</label>
                            <input type="text" id="vertexProjectIdInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);" placeholder="e.g., my-gcp-project">
                        </div>
                        <div>
                            <label for="vertexLocationInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">Vertex Location</label>
                            <input type="text" id="vertexLocationInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);" value="us-central1" placeholder="e.g., us-central1">
                        </div>
                        <div>
                            <label for="vertexProxyUrlInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">Vertex Proxy URL (optional)</label>
                            <input type="text" id="vertexProxyUrlInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);" placeholder="e.g., http://localhost:8787">
                        </div>
                        <div>
                            <label for="vertexGoogleClientIdInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">Google OAuth Client ID (optional)</label>
                            <input type="text" id="vertexGoogleClientIdInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);" placeholder="Your Google OAuth Web Client ID">
                        </div>
                        <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;">
                            <button id="vertexGoogleLoginBtn" type="button" class="btn" style="width:auto;">Google Login for Vertex</button>
                            <span id="vertexGoogleLoginStatus" style="font-size:0.8rem;color:var(--text-color-secondary);"></span>
                        </div>
                        <div>
                            <label for="vertexAccessTokenInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">Vertex Credential</label>
                            <input type="password" id="vertexAccessTokenInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);" placeholder="API key (AIza...) or OAuth2 token">
                        </div>
                        <div>
                            <label for="vertexModelInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">Vertex Model</label>
                            <select id="vertexModelInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);" disabled>
                                <option>Connect first</option>
                            </select>
                        </div>
                    </div>
                    
                    <div id="openaiSettings" class="hidden">
                        <div>
                            <label for="openaiApiKeyInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">OpenAI API Key</label>
                            <input type="password" id="openaiApiKeyInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);">
                        </div>
                        <div>
                            <label for="openaiModelInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">OpenAI Model</label>
                            <select id="openaiModelInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);" disabled>
                                <option>Enter API Key first</option>
                            </select>
                        </div>
                    </div>

                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <button id="connectApiBtn" class="btn">Connect</button>
                        <button id="verifyApiBtn" class="btn hidden" title="Test the API connection">Verify</button>
                        <span id="apiStatus" style="font-size: 0.875rem; font-weight: 600;"></span>
                    </div>
                    <div id="modelSelectWrapper">
                         <label for="modelSelect" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">AI Model</label>
                         <select id="modelSelect" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);" disabled>
                            <option>Connect to server first</option>
                        </select>
                    </div>
                </div>
            </div>

            <div style="margin-bottom: 1.5rem;">
                <h3 style="font-size: 1.25rem; font-weight: 600; margin-bottom: 0.75rem;">Data Management</h3>
                <div style="display: flex; flex-wrap: wrap; gap: 1rem;">
                     <button id="exportBtn" class="btn">Export Data</button>
                     <button id="importBtn" class="btn" style="background: linear-gradient(135deg, #7f8c8d 0%, #95a5a6 100%);">Import Data</button>
                     <button id="eraseAllBtn" class="btn save-btn">Erase All Data</button>
                </div>
            </div>
        </div>
    </div>

    <div id="goalGeneratorModal" class="modal-overlay hidden">
        <div class="modal-content goal-generator-modal">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid var(--modal-header-border);">
                <h2 style="font-size: 1.5rem; font-weight: bold;">Auto-Generate Goals & Objectives</h2>
                <button id="closeGoalGeneratorBtn" style="font-size: 2rem; background: none; border: none; cursor: pointer; color: inherit;">&times;</button>
            </div>
            <div class="goal-generator-controls">
                <div class="goal-generator-card">
                    <div class="goal-generator-title">Clinical Focus</div>
                    <label style="margin-bottom: 0.25rem; font-weight: 600; display: block;" for="goalProblemInput">Problem / Diagnosis Focus</label>
                    <textarea id="goalProblemInput" class="setting-input" rows="4" placeholder="Describe the presenting problem/diagnosis to target."></textarea>
                </div>
                <div class="goal-generator-card">
                    <div class="goal-generator-title">Generation Settings</div>
                    <div class="goal-generator-secondary">
                    <div>
                        <label style="margin-bottom: 0.25rem; font-weight: 600; display: block;" for="goalCountInput"># Goals</label>
                        <input id="goalCountInput" class="setting-input" type="number" min="1" max="20" value="1">
                    </div>
                    <div>
                        <label style="margin-bottom: 0.25rem; font-weight: 600; display: block;" for="objectiveCountInput"># Objectives per Goal</label>
                        <input id="objectiveCountInput" class="setting-input" type="number" min="1" max="20" value="4">
                    </div>
                    <div>
                        <label style="margin-bottom: 0.25rem; font-weight: 600; display: block;" for="objectiveStyleSelect">Objective Format</label>
                        <select id="objectiveStyleSelect" class="setting-input">
                            <option value="action">Action-Focused</option>
                            <option value="smart">SMART</option>
                        </select>
                    </div>
                    </div>
                </div>
                <div class="goal-generator-card">
                    <div class="goal-generator-title">Modality Lens</div>
                    <div style="font-size: 0.9rem; color: var(--text-color-secondary); font-weight: 600; margin-bottom: 6px;">Choose one or more modalities using + / ‚àí</div>
                    <div id="guidingModalitiesList" class="modality-grid"></div>
                    <div id="guidingModalityOtherWrap" class="hidden" style="margin-top:8px; max-width: 380px;">
                        <label for="guidingModalityOther" style="font-size:0.9rem; font-weight:600; display:block; margin-bottom:4px;">Other (Specify)</label>
                        <input id="guidingModalityOther" type="text" class="setting-input" placeholder="Optional custom modality..." disabled>
                    </div>
                </div>
            </div>
            <div class="goal-generator-actions">
                <button id="runGoalGeneratorBtn" class="btn">Generate Draft</button>
                <button id="applyGeneratedGoalsBtn" class="btn save-btn" disabled>Apply Approved Goals</button>
            </div>
            <div id="generatedGoalsReview" class="intervention-list"></div>
        </div>
    </div>

    <div id="interventionBankModal" class="modal-overlay hidden">
        <div class="modal-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid var(--modal-header-border);">
                <h2 style="font-size: 1.5rem; font-weight: bold;">Intervention Bank</h2>
                <button id="closeInterventionBankBtn" style="font-size: 2rem; background: none; border: none; cursor: pointer; color: inherit;">&times;</button>
            </div>
            <div style="display:flex;gap:8px;margin-bottom:10px;">
                <input id="newInterventionInput" class="setting-input" type="text" placeholder="Add intervention...">
                <button id="addInterventionBtn" class="btn save-btn" style="width:auto;padding:0 14px;">Add</button>
            </div>
            <div id="interventionBankList" class="intervention-list"></div>
        </div>
    </div>

    <div id="interventionPickerModal" class="modal-overlay hidden">
        <div class="modal-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid var(--modal-header-border);">
                <h2 style="font-size: 1.5rem; font-weight: bold;">Select Interventions for Note</h2>
                <button id="closeInterventionPickerBtn" style="font-size: 2rem; background: none; border: none; cursor: pointer; color: inherit;">&times;</button>
            </div>
            <div id="interventionPickerList" class="intervention-list" style="margin-bottom:10px;"></div>
            <button id="saveInterventionSelectionBtn" class="btn">Save Selection</button>
        </div>
    </div>

    <div id="informedConsentModal" class="modal-overlay hidden">
        <div class="modal-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid var(--modal-header-border);">
                <h2 style="font-size: 1.5rem; font-weight: bold;">Informed Consent</h2>
                <button id="closeConsentBtn" style="font-size: 2rem; background: none; border: none; cursor: pointer; color: inherit;">&times;</button>
            </div>
            <div style="max-height: 60vh; overflow-y: auto; margin-bottom: 1.5rem; line-height: 1.6;">
                <p>What we discuss here is confidential, with legal limits. I may need to break confidentiality if there is a risk of serious harm to you or others, suspected abuse of a child, elderly, or vulnerable adult, or if records are legally required. Sessions are billed at the agreed fee, and insurance is billed when applicable. You are responsible for any copays, deductibles, or denied claims. Appointments cancelled with less than 24 hours' notice, or missed entirely, are charged the full session fee. I wait up to ten minutes for scheduled sessions before a session is considered missed. Email is used for scheduling and administrative communication only, not emergencies. If you are in crisis, please contact 988 or call 911. Do you have any questions before we continue?</p>
            </div>
            <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                <button id="closeConsentBtnBottom" class="btn" style="background: linear-gradient(135deg, #7f8c8d 0%, #95a5a6 100%);">Close</button>
            </div>
        </div>
    </div>

    <div id="soapAuditGuideModal" class="modal-overlay hidden">
        <div class="modal-content guide-modal-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 1px solid var(--modal-header-border);">
                <h2 style="font-size: 1.5rem; font-weight: bold;">Audit-Ready SOAP Documentation Guide</h2>
                <button id="closeSoapAuditGuideBtn" style="font-size: 2rem; background: none; border: none; cursor: pointer; color: inherit;">&times;</button>
            </div>

            <div class="guide-scroll">
                <p style="margin-bottom: 0.6rem;">Comprehensive, audit-ready guidance for writing mental health SOAP notes that reduce risk of clawbacks, recoupments, and audit findings. Structured for outpatient behavioral health, with principles that apply broadly.</p>

                <h3>Core Principles That Protect Against Clawbacks</h3>
                <p>Audits typically look for:</p>
                <ul>
                    <li>Medical necessity</li>
                    <li>Clear link between symptoms and treatment</li>
                    <li>Measurable progress or clinical rationale</li>
                    <li>Appropriate level of care</li>
                    <li>Time documentation that matches billing</li>
                    <li>Consistency between diagnosis, treatment plan, and note</li>
                    <li>Compliance with payer requirements</li>
                    <li>No cloning or copy-paste patterns</li>
                    <li>Legible, specific documentation</li>
                    <li>Support for continued treatment</li>
                </ul>

                <div class="guide-callout">
                    <strong>Central question every note must answer:</strong><br>
                    Why was this service medically necessary today?
                </div>

                <h3>Required Elements in Every SOAP Note</h3>

                <h4>S ‚Äì Subjective</h4>
                <p>This section documents:</p>
                <ul>
                    <li>Client‚Äôs report of symptoms</li>
                    <li>Functional impact</li>
                    <li>Relevant changes since last session</li>
                    <li>Medication changes</li>
                    <li>Safety concerns</li>
                    <li>Client‚Äôs perspective on progress</li>
                </ul>
                <p>Must include:</p>
                <ul>
                    <li>Symptom description</li>
                    <li>Duration or frequency when relevant</li>
                    <li>Severity when relevant</li>
                    <li>Functional impairment</li>
                    <li>Direct quotes when helpful</li>
                </ul>
                <div class="guide-example">
                    <strong>Example (Strong)</strong><br>
                    Client reports increased anxiety over the past week, describing daily panic symptoms lasting 20‚Äì30 minutes. Sleep has decreased to 4‚Äì5 hours per night. Client states, ‚ÄúI am avoiding meetings because I feel like I will lose control.‚Äù Reports decreased work performance and difficulty concentrating.
                </div>
                <div class="guide-example">
                    <strong>Example (Weak)</strong><br>
                    Client reports feeling anxious.<br>
                    <strong>Why weak:</strong> lacks severity, duration, and functional impact.
                </div>

                <h4>O ‚Äì Objective</h4>
                <p>This section documents observable data. Includes:</p>
                <ul>
                    <li>Appearance</li>
                    <li>Behavior</li>
                    <li>Mood and affect (clinician observed)</li>
                    <li>Orientation</li>
                    <li>Speech</li>
                    <li>Thought process</li>
                    <li>Risk assessment findings</li>
                    <li>Engagement level</li>
                </ul>
                <p>Must include:</p>
                <ul>
                    <li>Mental status indicators</li>
                    <li>Safety assessment when clinically indicated</li>
                    <li>Any measurable data used (scales, scores)</li>
                </ul>
                <div class="guide-example">
                    <strong>Example</strong><br>
                    Client appeared fatigued with constricted affect. Speech was coherent and goal-directed. No psychosis observed. Oriented x4. Denies suicidal ideation, plan, or intent. Engaged throughout session.
                </div>
                <div class="guide-example">
                    <strong>Standardized measure example</strong><br>
                    GAD-7 score increased from 11 to 16 since last assessment.
                </div>

                <h4>A ‚Äì Assessment</h4>
                <p>This is the most important section for audits. It must demonstrate:</p>
                <ul>
                    <li>Clinical interpretation</li>
                    <li>Progress toward goals</li>
                    <li>Ongoing medical necessity</li>
                    <li>Response to treatment</li>
                    <li>Risk level</li>
                    <li>Diagnostic justification if relevant</li>
                </ul>
                <p>Must include:</p>
                <ul>
                    <li>Progress or lack of progress</li>
                    <li>Why continued treatment is needed</li>
                    <li>Connection to diagnosis</li>
                    <li>Clinical reasoning</li>
                </ul>
                <div class="guide-example">
                    <strong>Strong Example</strong><br>
                    Symptoms remain consistent with Generalized Anxiety Disorder, currently moderate to severe. Increased avoidance behaviors are interfering with occupational functioning. Client has demonstrated partial progress in cognitive restructuring skills but continues to require structured intervention to reduce functional impairment. Continued weekly therapy is medically necessary to prevent further deterioration.
                </div>
                <div class="guide-example">
                    <strong>Weak Example</strong><br>
                    Client is doing okay. Continue treatment.<br>
                    <strong>Why weak:</strong> no medical necessity, no progress detail.
                </div>

                <h4>P ‚Äì Plan</h4>
                <p>Must include:</p>
                <ul>
                    <li>Interventions used in session</li>
                    <li>Response to interventions</li>
                    <li>Homework or between-session tasks</li>
                    <li>Next session plan</li>
                    <li>Referrals if applicable</li>
                    <li>Risk follow-up if needed</li>
                    <li>Coordination of care if done</li>
                </ul>
                <p><strong>Must Align With Treatment Plan:</strong> Each session should clearly relate to at least one active treatment goal.</p>
                <div class="guide-example">
                    <strong>Strong Example</strong><br>
                    Continued CBT targeting cognitive distortions related to workplace anxiety. Client practiced thought record exercise in session. Assigned daily tracking of avoidance behaviors. Will continue weekly sessions. Next session to focus on exposure hierarchy development.
                </div>

                <h3>Medical Necessity Requirements</h3>
                <p>To withstand audits, notes should demonstrate:</p>
                <ul>
                    <li>Active symptoms</li>
                    <li>Functional impairment</li>
                    <li>Treatment addressing diagnosis</li>
                    <li>Skilled intervention required</li>
                    <li>Not appropriate for self-help or lower level of care</li>
                </ul>

                <h4>Include Functional Impact</h4>
                <p>Auditors often deny claims when notes lack impairment. Examples of functional impairment:</p>
                <ul>
                    <li>Work interference</li>
                    <li>Relationship strain</li>
                    <li>Sleep disruption</li>
                    <li>Academic difficulty</li>
                    <li>Parenting impairment</li>
                    <li>Avoidance behavior</li>
                    <li>Emotional dysregulation</li>
                    <li>Safety concerns</li>
                </ul>

                <h3>Time Documentation</h3>
                <ul>
                    <li>If billing time-based codes, document start and end time OR total time.</li>
                    <li>Match documentation to billing code requirements.</li>
                    <li>Include psychotherapy time separate from other services when applicable.</li>
                    <li>Avoid rounding inconsistently.</li>
                </ul>
                <div class="guide-example">
                    <strong>Example</strong><br>
                    53-minute psychotherapy session conducted from 10:02 AM to 10:55 AM.
                </div>

                <h3>Risk Assessment Documentation</h3>
                <p>Document when clinically appropriate:</p>
                <ul>
                    <li>Suicidal ideation</li>
                    <li>Homicidal ideation</li>
                    <li>Self-harm risk</li>
                    <li>Protective factors</li>
                    <li>Level of risk</li>
                    <li>Safety plan if needed</li>
                </ul>
                <p>Even if negative, document it.</p>
                <div class="guide-example">
                    <strong>Example</strong><br>
                    Client denies suicidal or homicidal ideation. No self-harm behaviors reported. Protective factors include supportive spouse and children. Risk assessed as low.
                </div>

                <h3>Link to Treatment Plan</h3>
                <p>Every session should:</p>
                <ul>
                    <li>Reference at least one goal</li>
                    <li>Show progress toward measurable objectives</li>
                    <li>Document interventions tied to goals</li>
                </ul>
                <div class="guide-example">
                    <strong>Example</strong><br>
                    Treatment Plan Goal: Reduce panic attacks from 4 per week to 1 per week within 8 weeks.<br>
                    SOAP Note Assessment: Client reports decrease from 4 to 2 panic episodes weekly, indicating measurable progress toward treatment goal.
                </div>
                <p>Auditors look for this alignment.</p>

                <h3>Common Audit Red Flags</h3>
                <p>Avoid:</p>
                <ul>
                    <li>Copy and paste notes</li>
                    <li>Identical wording across sessions</li>
                    <li>Vague descriptions</li>
                    <li>Missing diagnosis in note</li>
                    <li>No evidence of progress</li>
                    <li>No functional impairment</li>
                    <li>No intervention described</li>
                    <li>Inconsistent time documentation</li>
                    <li>Overly brief notes for high-level billing</li>
                    <li>Using psychotherapy codes without documenting therapy techniques</li>
                    <li>Billing family sessions without documenting client involvement</li>
                </ul>

                <h3>Special Considerations</h3>
                <h4>Telehealth</h4>
                <p>Document:</p>
                <ul>
                    <li>Platform used</li>
                    <li>Client location</li>
                    <li>Consent</li>
                    <li>Privacy confirmation</li>
                </ul>
                <div class="guide-example">
                    <strong>Example</strong><br>
                    Session conducted via secure telehealth platform. Client confirmed private location in home.
                </div>

                <h4>Medication Coordination</h4>
                <p>If applicable:</p>
                <ul>
                    <li>Document collaboration</li>
                    <li>Note ROI if needed</li>
                    <li>Record communication summary</li>
                </ul>

                <h4>Crisis Sessions</h4>
                <p>Must document:</p>
                <ul>
                    <li>Risk assessment</li>
                    <li>Safety planning</li>
                    <li>Increased level of care reasoning</li>
                    <li>Time spent</li>
                    <li>Follow-up plan</li>
                </ul>
                <div class="guide-example">
                    <strong>Example</strong><br>
                    Include risk assessment findings, safety planning steps taken, rationale for level of care, duration of crisis work, and explicit follow-up actions.
                </div>

                <h3>Example of a Fully Auditable SOAP Note</h3>
                <div class="guide-example">
                    <strong>S:</strong><br>
                    Client reports ongoing workplace anxiety with increased avoidance of meetings. States panic symptoms occur 3 times per week lasting approximately 20 minutes. Reports sleep disruption and difficulty concentrating. Describes fear of negative evaluation.
                </div>
                <div class="guide-example">
                    <strong>O:</strong><br>
                    Client appeared tense with anxious affect. Speech clear and organized. Oriented x4. No psychotic symptoms observed. Denies suicidal or homicidal ideation. Engaged throughout session.
                </div>
                <div class="guide-example">
                    <strong>A:</strong><br>
                    Symptoms consistent with Generalized Anxiety Disorder. Functional impairment present in occupational setting. Partial progress noted in cognitive restructuring skills. Continued weekly psychotherapy is medically necessary to reduce symptom severity and restore work functioning.
                </div>
                <div class="guide-example">
                    <strong>P:</strong><br>
                    Provided CBT focused on cognitive distortions. Practiced thought record in session. Assigned daily tracking of avoidance behaviors. Continue weekly sessions. Reassess symptom scale in two weeks.
                </div>

                <h3>Documentation Checklist for Every Note</h3>
                <p>Before signing, confirm:</p>
                <ul class="guide-checklist">
                    <li>‚òê Diagnosis supported</li>
                    <li>‚òê Symptoms described with detail</li>
                    <li>‚òê Functional impairment documented</li>
                    <li>‚òê Intervention clearly stated</li>
                    <li>‚òê Client response recorded</li>
                    <li>‚òê Medical necessity explained</li>
                    <li>‚òê Progress toward goals documented</li>
                    <li>‚òê Risk assessed when appropriate</li>
                    <li>‚òê Time documented accurately</li>
                    <li>‚òê Note is individualized</li>
                    <li>‚òê No copy-paste language</li>
                    <li>‚òê Plan aligns with treatment plan</li>
                </ul>

                <h3>Best Practices to Reduce Audit Risk</h3>
                <ul>
                    <li>Write notes immediately after session.</li>
                    <li>Tie every session to a treatment goal.</li>
                    <li>Use measurable language.</li>
                    <li>Document change over time.</li>
                    <li>Avoid excessive brevity.</li>
                    <li>Avoid unnecessary narrative.</li>
                    <li>Keep diagnosis consistent with treatment focus.</li>
                    <li>Update treatment plan regularly.</li>
                    <li>Use standardized measures periodically.</li>
                    <li>Ensure billing code matches documentation depth.</li>
                </ul>
            </div>

            <div style="display: flex; justify-content: flex-end; margin-top: 0.9rem;">
                <button id="closeSoapAuditGuideBtnBottom" class="btn" style="background: linear-gradient(135deg, #7f8c8d 0%, #95a5a6 100%);">Close</button>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" class="hidden" accept="application/json">

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const clientListEl = document.getElementById('clientList');
            const addClientBtn = document.getElementById('addClientBtn');
            const sortClientsBtn = document.getElementById('sortClientsBtn');
            const appointmentListEl = document.getElementById('appointmentList');
            const addAppointmentBtn = document.getElementById('addAppointmentBtn');
            const addIntakeBtn = document.getElementById('addIntakeBtn');
            const appointmentDateInput = document.getElementById('appointmentDateInput');
            const updateAppointmentDateBtn = document.getElementById('updateAppointmentDateBtn');
            const noteNameInput = document.getElementById('noteNameInput');
            const addNoteBtn = document.getElementById('addNoteBtn');
            const renameNoteBtn = document.getElementById('renameNoteBtn');
            const deletedClientsListEl = document.getElementById('deletedClientsList');
            const clearDeletedClientsBtn = document.getElementById('clearDeletedClientsBtn');
            const archivedClientsListEl = document.getElementById('archivedClientsList');
            const deletedAppointmentsListEl = document.getElementById('deletedAppointmentsList');
            const clearDeletedAppointmentsBtn = document.getElementById('clearDeletedAppointmentsBtn');
            const persistentNotesEl = document.getElementById('persistentNotes');
            const sessionInfoEl = document.getElementById('sessionInfo');
            const auditProofSymptomsEl = document.getElementById('auditProofSymptoms');
            const auditProofFunctionalEl = document.getElementById('auditProofFunctional');
            const auditProofProgressEl = document.getElementById('auditProofProgress');
            const auditProofGoalEl = document.getElementById('auditProofGoal');
            const auditProofNecessityEl = document.getElementById('auditProofNecessity');
            const regularSessionFieldsEl = document.getElementById('regularSessionFields');
            const auditProofingBlockEl = document.getElementById('auditProofingBlock');
            const intakeSessionBlockEl = document.getElementById('intakeSessionBlock');
            const intakeFieldsContainerEl = document.getElementById('intakeFieldsContainer');
            const guidingModalitiesListEl = document.getElementById('guidingModalitiesList');
            const guidingModalityOtherWrapEl = document.getElementById('guidingModalityOtherWrap');
            const guidingModalityOtherEl = document.getElementById('guidingModalityOther');
            const soapContentEl = document.getElementById('soapContent');
            const autoSaveIndicator = document.getElementById('autoSaveIndicator');
            const saveStatus = document.getElementById('saveStatus');
            // Session Timer Elements
            const sessionTimerWrapper = document.getElementById('sessionTimerWrapper');
            const startTimerBtn = document.getElementById('startTimerBtn');
            const stopTimerBtn = document.getElementById('stopTimerBtn');
            const sessionDurationEl = document.getElementById('sessionDuration');
            // Settings and Modal Elements
            const settingsBtn = document.getElementById('settingsBtn');
            const settingsModal = document.getElementById('settingsModal');
            const closeSettingsBtn = document.getElementById('closeSettingsBtn');
            const informedConsentBtn = document.getElementById('informedConsentBtn');
            const cssrsBtn = document.getElementById('cssrsBtn');
            const soapAuditGuideBtn = document.getElementById('soapAuditGuideBtn');
            const interventionBankBtn = document.getElementById('interventionBankBtn');
            const informedConsentModal = document.getElementById('informedConsentModal');
            const closeConsentBtn = document.getElementById('closeConsentBtn');
            const closeConsentBtnBottom = document.getElementById('closeConsentBtnBottom');
            const soapAuditGuideModal = document.getElementById('soapAuditGuideModal');
            const closeSoapAuditGuideBtn = document.getElementById('closeSoapAuditGuideBtn');
            const closeSoapAuditGuideBtnBottom = document.getElementById('closeSoapAuditGuideBtnBottom');
            const goalGeneratorModal = document.getElementById('goalGeneratorModal');
            const closeGoalGeneratorBtn = document.getElementById('closeGoalGeneratorBtn');
            const generateGoalsBtn = document.getElementById('generateGoalsBtn');
            const goalProblemInput = document.getElementById('goalProblemInput');
            const goalCountInput = document.getElementById('goalCountInput');
            const objectiveCountInput = document.getElementById('objectiveCountInput');
            const objectiveStyleSelect = document.getElementById('objectiveStyleSelect');
            const runGoalGeneratorBtn = document.getElementById('runGoalGeneratorBtn');
            const applyGeneratedGoalsBtn = document.getElementById('applyGeneratedGoalsBtn');
            const generatedGoalsReview = document.getElementById('generatedGoalsReview');
            const interventionBankModal = document.getElementById('interventionBankModal');
            const closeInterventionBankBtn = document.getElementById('closeInterventionBankBtn');
            const newInterventionInput = document.getElementById('newInterventionInput');
            const addInterventionBtn = document.getElementById('addInterventionBtn');
            const interventionBankList = document.getElementById('interventionBankList');
            const interventionPickerModal = document.getElementById('interventionPickerModal');
            const closeInterventionPickerBtn = document.getElementById('closeInterventionPickerBtn');
            const interventionPickerList = document.getElementById('interventionPickerList');
            const saveInterventionSelectionBtn = document.getElementById('saveInterventionSelectionBtn');
            const manualSaveBtn = document.getElementById('manualSaveBtn');
            const exportBtn = document.getElementById('exportBtn');
            const importBtn = document.getElementById('importBtn');
            const eraseAllBtn = document.getElementById('eraseAllBtn');
            // Custom Instructions Modal Elements
            const customInstructionsBtn = document.getElementById('customInstructionsBtn');
            const customInstructionsModal = document.getElementById('customInstructionsModal');
            const closeCustomInstructionsBtn = document.getElementById('closeCustomInstructionsBtn');
            const persistentInstructionsInput = document.getElementById('persistentInstructionsInput');
            const sessionInstructionsInput = document.getElementById('sessionInstructionsInput');
            const saveCustomInstructionsBtn = document.getElementById('saveCustomInstructionsBtn');
            const clearCustomInstructionsBtn = document.getElementById('clearCustomInstructionsBtn');
            const customInstructionsModalitiesListEl = document.getElementById('customInstructionsModalitiesList');
            const customInstructionsModalityOtherWrapEl = document.getElementById('customInstructionsModalityOtherWrap');
            const customInstructionsModalityOtherEl = document.getElementById('customInstructionsModalityOther');
            // AI Integration Elements
            const apiProviderSelect = document.getElementById('apiProviderSelect');
            const openwebuiSettings = document.getElementById('openwebuiSettings');
            const serverAddressInput = document.getElementById('serverAddressInput');
            const apiKeyInput = document.getElementById('apiKeyInput');
            const geminiSettings = document.getElementById('geminiSettings');
            const geminiApiKeyInput = document.getElementById('geminiApiKeyInput');
            const geminiModelInput = document.getElementById('geminiModelInput');
            const vertexSettings = document.getElementById('vertexSettings');
            const vertexProjectIdInput = document.getElementById('vertexProjectIdInput');
            const vertexLocationInput = document.getElementById('vertexLocationInput');
            const vertexProxyUrlInput = document.getElementById('vertexProxyUrlInput');
            const vertexGoogleClientIdInput = document.getElementById('vertexGoogleClientIdInput');
            const vertexGoogleLoginBtn = document.getElementById('vertexGoogleLoginBtn');
            const vertexGoogleLoginStatus = document.getElementById('vertexGoogleLoginStatus');
            const vertexAccessTokenInput = document.getElementById('vertexAccessTokenInput');
            const vertexModelInput = document.getElementById('vertexModelInput');
            const openaiSettings = document.getElementById('openaiSettings');
            const openaiApiKeyInput = document.getElementById('openaiApiKeyInput');
            const openaiModelInput = document.getElementById('openaiModelInput');
            const connectApiBtn = document.getElementById('connectApiBtn');
            const verifyApiBtn = document.getElementById('verifyApiBtn');
            const apiStatus = document.getElementById('apiStatus');
            const modelSelect = document.getElementById('modelSelect');
            const modelSelectWrapper = document.getElementById('modelSelectWrapper');
            const generateNoteBtn = document.getElementById('generateNoteBtn');
            const fileInput = document.getElementById('fileInput');
            const themeToggleBtn = document.getElementById('themeToggleBtn');
            // Goals Elements
            const goalsListInTabEl = document.getElementById('goalsListInTab');
            const addGoalBtnInTab = document.getElementById('addGoalBtnInTab');
            const appointmentsTabBtn = document.getElementById('appointmentsTabBtn');
            const goalsTabBtn = document.getElementById('goalsTabBtn');
            const appointmentsTabContent = document.getElementById('appointmentsTabContent');
            const goalsTabContent = document.getElementById('goalsTabContent');

            // App State
            let data = { clients: [], archivedClients: [] };
            let deletedItems = { clients: [], appointments: [], notes: [] };
            let selectedClientId = null;
            let selectedAppointmentId = null;
            let selectedNoteId = null;
            let selectedIntakeId = null;
            let isDirty = false;
            let apiProvider = 'openwebui';
            let serverAddress = null;
            let apiKey = null;
            let geminiApiKey = null;
            let vertexProjectId = null;
            let vertexLocation = 'us-central1';
            let vertexAccessToken = null;
            let openaiApiKey = null;
            let selectedModel = null;
            let sessionTimerInterval = null;
            let persistentInstructions = '';
            let sessionInstructions = '';
            let generatedGoalsDraft = [];
            let goalGeneratorModalities = [];
            let goalGeneratorModalityOther = '';
            const isLikelyGoogleApiKey = (value) => /^AIza[0-9A-Za-z\-_]{20,}$/.test((value || '').trim());
            const getVertexAuthConfig = (credential) => {
                const normalized = (credential || '').trim();
                if (!normalized) return { headers: {}, query: '' };
                if (isLikelyGoogleApiKey(normalized)) {
                    return {
                        headers: {},
                        query: `?key=${encodeURIComponent(normalized)}`
                    };
                }
                return {
                    headers: { 'Authorization': `Bearer ${normalized}` },
                    query: ''
                };
            };
            const getVertexProxyUrl = () => (vertexProxyUrlInput?.value || '').trim().replace(/\/+$/, '');
            const hasVertexProxy = () => !!getVertexProxyUrl();
            let vertexGoogleTokenClient = null;
            const callVertexProxyGenerate = async (model, payload) => {
                const proxyUrl = getVertexProxyUrl();
                if (!proxyUrl) throw new Error('Vertex proxy URL is not configured.');
                const response = await fetch(`${proxyUrl}/vertex/generate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        projectId: vertexProjectIdInput.value.trim(),
                        location: (vertexLocationInput.value.trim() || 'us-central1'),
                        model,
                        payload
                    })
                });
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Proxy error: ${response.status} - ${errorText}`);
                }
                return await response.json();
            };
            const requestVertexGoogleAccessToken = () => {
                const clientId = (vertexGoogleClientIdInput?.value || '').trim();
                if (!clientId) {
                    alert('Please enter a Google OAuth Client ID first.');
                    vertexGoogleClientIdInput?.focus();
                    return;
                }
                if (!window.google || !window.google.accounts || !window.google.accounts.oauth2) {
                    alert('Google Identity Services is not available yet. Please wait a moment and try again.');
                    return;
                }

                if (!vertexGoogleTokenClient) {
                    vertexGoogleTokenClient = google.accounts.oauth2.initTokenClient({
                        client_id: clientId,
                        scope: 'https://www.googleapis.com/auth/cloud-platform',
                        callback: (response) => {
                            if (response && response.access_token) {
                                vertexAccessTokenInput.value = response.access_token;
                                localStorage.setItem('vertexAccessToken', response.access_token);
                                localStorage.setItem('vertexGoogleClientId', clientId);
                                vertexGoogleLoginStatus.textContent = 'Google login successful';
                                vertexGoogleLoginStatus.style.color = 'green';
                            } else {
                                const err = response?.error || 'unknown_error';
                                vertexGoogleLoginStatus.textContent = `Google login failed: ${err}`;
                                vertexGoogleLoginStatus.style.color = 'red';
                            }
                        }
                    });
                }

                vertexGoogleLoginStatus.textContent = 'Opening Google login...';
                vertexGoogleLoginStatus.style.color = 'orange';
                try {
                    vertexGoogleTokenClient.requestAccessToken({ prompt: 'consent' });
                } catch (error) {
                    vertexGoogleLoginStatus.textContent = `Google login failed: ${error.message}`;
                    vertexGoogleLoginStatus.style.color = 'red';
                }
            };
            const DEFAULT_INTERVENTION_BANK = [
                'Acceptance', 'Career Counseling', 'CBT: Behavioral Activation', 'CBT: Cognitive Challenging', 'CBT: Cognitive Reframing',
                'CBT: Cognitive Restructuring', 'CBT: Identifying/Challenging Cognitive Distortions', 'CBT: Mindfulness Training',
                'Collaborative Problem-Solving', 'Collaborative Treatment Planning', 'Communication Skills Training',
                'Conflict Resolution Skill Development', 'Decisional Balance', 'Diagnostic Assessment', 'DPerspective Taking',
                'EFCT ‚Äì Choreographing Enactments', 'EFCT ‚Äì De-Escalation', 'EFCT ‚Äì Empathetic Conjecture', 'EFCT ‚Äì Evocative Responding',
                'EFCT ‚Äì Facilitation of Emotional Engagement', 'EFCT ‚Äì Heightening', 'EFCT ‚Äì Reflection', 'EFCT ‚Äì Restructuring Interactions',
                'Emotional Processing', 'Exploration of Coping Patterns', 'Exploration of Core Beliefs', 'Exploration of Family Dynamics',
                'Exploration of Relationship Patterns', 'Family Consultation', 'Grief Counseling', 'Inner Child Work',
                'MI: Decisional Balance (pros/cons)', 'MI: Developing Discrepancy', 'MI: Developing Motivation', 'MI: Eliciting Change Talk',
                'MI: Evoking Commitment Language', 'NT: Deconstruction', 'NT: Externalization', 'NT: Identifying Meaning-Making Patterns',
                'NT: Re-Authoring', 'NT: Re-Framing', 'NT: Re-membering', 'NT: Scaffolding Questions', 'NT: Use of Metaphor/Imagery',
                'NT: Values Exploration', 'PD: Confrontation', 'PD: Exploration of Attachment Patterns', 'PD: Exploration of Themes and Patterns',
                'PD: Exploration of Transference', 'PD: Explore Defense Mechanisms', 'PD: Insight & Emotional Integration', 'PD: Interpretation', 'PD: Reflection'
            ];
            const getInitialData = () => ({ clients: [], archivedClients: [], interventionBank: [...DEFAULT_INTERVENTION_BANK] });
            const intakePromptFields = [
                { key: 'presentingProblem', label: 'Presenting Problem' },
                { key: 'riskAssessment', label: 'Risk Assessment' },
                { key: 'objectiveContent', label: 'Objective Content' },
                { key: 'identification', label: 'Identification' },
                { key: 'historyPresentingProblem', label: 'History of Presenting Problem' },
                { key: 'psychiatricHistory', label: 'Psychiatric History' },
                { key: 'traumaHistory', label: 'Trauma History' },
                { key: 'familyPsychHistory', label: 'Family Psychiatric History' },
                { key: 'medicalConditionsHistory', label: 'Medical Conditions and History' },
                { key: 'currentMedications', label: 'Current Medications' },
                { key: 'substanceUse', label: 'Substance Use' },
                { key: 'familyHistory', label: 'Family History' },
                { key: 'socialHistory', label: 'Social History' },
                { key: 'spiritualCulturalFactors', label: 'Spiritual/Cultural Factors' },
                { key: 'developmentalHistory', label: 'Developmental History' },
                { key: 'educationalVocationalHistory', label: 'Educational/Vocational History' },
                { key: 'legalHistory', label: 'Legal History' },
                { key: 'snap', label: 'SNAP' },
                { key: 'otherImportantInformation', label: 'Other Important Information' },
                { key: 'plan', label: 'Plan' },
                { key: 'diagnosis', label: 'Diagnosis' }
            ];
            const DEFAULT_GUIDING_MODALITIES = ['Psychodynamic Psychotherapy', 'Narrative Therapy'];
            const GUIDING_MODALITY_OPTIONS = [
                'CBT (Cognitive Behavioral Therapy)',
                'DBT (Dialectical Behavior Therapy)',
                'ACT (Acceptance and Commitment Therapy)',
                'REBT (Rational Emotive Behavior Therapy)',
                'CPT (Cognitive Processing Therapy)',
                'ERP (Exposure and Response Prevention)',
                'Behavioral Activation (BA)',
                'TF-CBT (Trauma-Focused CBT)',
                'Psychodynamic Psychotherapy',
                'Psychoanalysis',
                'IFS (Internal Family Systems)',
                'Object Relations Therapy',
                'Attachment-Based Therapy',
                'EFT (Emotionally Focused Therapy)',
                'Person-Centered Therapy',
                'Gestalt Therapy',
                'Existential Therapy',
                'Narrative Therapy',
                'Solution-Focused Brief Therapy (SFBT)',
                'Logotherapy',
                'Other (Specify)'
            ];
            goalGeneratorModalities = [...DEFAULT_GUIDING_MODALITIES];

            // --- Data Management ---
            const findClient = id => data.clients.find(c => c.id === id) || data.archivedClients.find(c => c.id === id);
            const findAppointment = (client, id) => client?.appointments.find(a => a.id === id);
            const findNote = (client, id) => client?.notes?.find(n => n.id === id);
            const findIntakeSession = (client, id) => client?.intakeSessions?.find(i => i.id === id);

            const normalizeClientData = () => {
                const allClients = [...(data.clients || []), ...(data.archivedClients || [])];
                allClients.forEach(client => {
                    if (!Array.isArray(client.appointments)) client.appointments = [];
                    if (!Array.isArray(client.notes)) client.notes = [];
                    if (!Array.isArray(client.intakeSessions)) client.intakeSessions = [];
                    if (!Array.isArray(client.goals)) client.goals = [];
                    if (typeof client.persistentInstructions !== 'string') client.persistentInstructions = '';
                    client.goals.forEach(goal => {
                        if (!goal.timelineMonths) goal.timelineMonths = 12;
                        if (!Array.isArray(goal.objectives)) goal.objectives = [];
                        goal.objectives.forEach(obj => {
                            if (!obj.timelineMonths) obj.timelineMonths = 3;
                            if (!obj.format) obj.format = 'action';
                        });
                    });
                    client.appointments.forEach(appt => {
                        if (!Array.isArray(appt.selectedInterventions)) appt.selectedInterventions = [];
                        if (typeof appt.sessionInstructions !== 'string') {
                            appt.sessionInstructions = typeof appt.customInstructions === 'string' ? appt.customInstructions : '';
                        }
                        if (appt.customInstructions !== undefined) {
                            delete appt.customInstructions;
                        }
                    });

                    if (!client.goalGenerationLens || typeof client.goalGenerationLens !== 'object') {
                        client.goalGenerationLens = {
                            modalities: [...DEFAULT_GUIDING_MODALITIES],
                            other: ''
                        };
                    }
                    if (!Array.isArray(client.goalGenerationLens.modalities) || client.goalGenerationLens.modalities.length === 0) {
                        client.goalGenerationLens.modalities = [...DEFAULT_GUIDING_MODALITIES];
                    }
                    if (typeof client.goalGenerationLens.other !== 'string') {
                        client.goalGenerationLens.other = '';
                    }
                });

                if (!Array.isArray(data.interventionBank) || data.interventionBank.length === 0) {
                    data.interventionBank = [...DEFAULT_INTERVENTION_BANK];
                }

                if (!deletedItems || typeof deletedItems !== 'object') {
                    deletedItems = { clients: [], appointments: [], notes: [] };
                }
                if (!Array.isArray(deletedItems.clients)) deletedItems.clients = [];
                if (!Array.isArray(deletedItems.appointments)) deletedItems.appointments = [];
                if (!Array.isArray(deletedItems.notes)) deletedItems.notes = [];
            };

            const containsAny = (text, patterns) => patterns.some(pattern => pattern.test(text));

            const getAuditProofingData = (appointment) => {
                if (!appointment) {
                    return {
                        symptoms: '',
                        functionalImpact: '',
                        progressResponse: '',
                        goalAlignment: '',
                        medicalNecessity: ''
                    };
                }

                const raw = appointment.auditProofing;
                if (!raw) {
                    return {
                        symptoms: '',
                        functionalImpact: '',
                        progressResponse: '',
                        goalAlignment: '',
                        medicalNecessity: ''
                    };
                }

                if (typeof raw === 'string') {
                    return {
                        symptoms: '',
                        functionalImpact: '',
                        progressResponse: raw,
                        goalAlignment: '',
                        medicalNecessity: ''
                    };
                }

                return {
                    symptoms: raw.symptoms || '',
                    functionalImpact: raw.functionalImpact || '',
                    progressResponse: raw.progressResponse || '',
                    goalAlignment: raw.goalAlignment || '',
                    medicalNecessity: raw.medicalNecessity || ''
                };
            };

            const saveAuditProofingField = (fieldKey, value) => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (!appointment) return;

                const current = getAuditProofingData(appointment);
                current[fieldKey] = value;
                appointment.auditProofing = current;
                delete appointment.auditCheck;
                markDirty();
                generateNoteBtn.disabled = !hasAppointmentGenerationInput(appointment);
            };

            const renderIntakeFields = (intakeSession) => {
                if (!intakeFieldsContainerEl) return;

                intakeFieldsContainerEl.innerHTML = '';
                if (!intakeSession) return;

                if (!intakeSession.fields || typeof intakeSession.fields !== 'object') {
                    intakeSession.fields = {};
                }

                intakePromptFields.forEach(field => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'audit-proofing-field';

                    const label = document.createElement('label');
                    label.setAttribute('for', `intake-${field.key}`);
                    label.textContent = field.label;

                    const textarea = document.createElement('textarea');
                    textarea.id = `intake-${field.key}`;
                    textarea.className = 'intake-field-input';
                    textarea.dataset.intakeKey = field.key;
                    textarea.value = intakeSession.fields[field.key] || '';
                    textarea.placeholder = `Enter ${field.label.toLowerCase()}...`;

                    wrapper.appendChild(label);
                    wrapper.appendChild(textarea);
                    intakeFieldsContainerEl.appendChild(wrapper);
                });
            };

            const hasAppointmentGenerationInput = (appointment) => {
                if (!appointment) return false;
                const hasSessionInfo = !!(appointment.sessionInfo || '').trim();
                const auditProofing = getAuditProofingData(appointment);
                const hasAuditProofing = Object.values(auditProofing).some(value => !!(value || '').trim());
                return hasSessionInfo || hasAuditProofing;
            };

            const runSoapAuditCheck = (client, appointment) => {
                const soap = appointment?.soap || {};
                const sectionText = {
                    s: (soap.s || '').trim(),
                    o: (soap.o || '').trim(),
                    a: (soap.a || '').trim(),
                    p: (soap.p || '').trim(),
                    i: (soap.interventions || '').trim()
                };

                const auditProofing = getAuditProofingData(appointment);
                const auditProofingText = `${auditProofing.symptoms}\n${auditProofing.functionalImpact}\n${auditProofing.progressResponse}\n${auditProofing.goalAlignment}\n${auditProofing.medicalNecessity}`.toLowerCase();

                const fullText = `${sectionText.s}\n${sectionText.o}\n${sectionText.a}\n${sectionText.p}\n${sectionText.i}`.toLowerCase();
                const sessionText = (appointment?.sessionInfo || '').toLowerCase();
                const combined = `${fullText}\n${sessionText}\n${auditProofingText}`;

                const checks = [
                    {
                        label: 'Subjective includes symptom detail',
                        pass: sectionText.s.length >= 20 && containsAny(sectionText.s.toLowerCase(), [/anx|depress|panic|sleep|mood|stress|irritab|fear|sad|worry|symptom/]),
                        remedy: 'Add symptom frequency/intensity language (for example, how often and how severe symptoms were this session).'
                    },
                    {
                        label: 'Subjective includes functional impact',
                        pass: containsAny(`${sectionText.s.toLowerCase()}\n${auditProofingText}`, [/work|school|relationship|parent|sleep|concentrat|avoid|function|impair/]),
                        remedy: 'Describe where symptoms impacted functioning (work, school, relationships, sleep, parenting, or daily tasks).'
                    },
                    {
                        label: 'Objective includes observable/MSE data',
                        pass: sectionText.o.length >= 20 && containsAny(sectionText.o.toLowerCase(), [/affect|mood|speech|oriented|orientation|appearance|behavior|thought|engaged|observed|denies/]),
                        remedy: 'Include at least 1‚Äì2 observed findings (appearance, affect, speech, orientation, thought process, engagement).'
                    },
                    {
                        label: 'Assessment states medical necessity/progress',
                        pass: sectionText.a.length >= 20 && containsAny(`${sectionText.a.toLowerCase()}\n${auditProofingText}`, [/medically necessary|continued|progress|partial|interfer|impair|deteriorat|required|diagnos|consistent with/]),
                        remedy: 'Add one sentence explaining why continued skilled treatment is needed now and what progress/remaining barriers were observed.'
                    },
                    {
                        label: 'Plan includes intervention + next step',
                        pass: sectionText.p.length >= 20 && containsAny(sectionText.p.toLowerCase(), [/continue|next session|follow-up|homework|assign|reassess|weekly|referral|coordinate|safety plan/]),
                        remedy: 'Add a concrete next-step plan (homework/follow-up/reassessment target) and tie it to ongoing symptoms.'
                    },
                    {
                        label: 'Interventions documented',
                        pass: sectionText.i.length >= 12 && sectionText.i.toLowerCase() !== 'no interventions identified.',
                        remedy: 'List techniques used today (for example CBT, reframing, exposure, grounding, psychoeducation) and client response.'
                    },
                    {
                        label: 'Treatment-goal alignment documented',
                        pass: (client?.goals || []).length === 0 || containsAny(combined, [/goal|objective|toward|progress toward|treatment plan|cbt|exposure|coping/]),
                        remedy: 'Reference at least one active goal/objective and state progress (or barriers) toward that target.'
                    },
                    {
                        label: 'All SOAP sections completed',
                        pass: sectionText.s.length > 3 && sectionText.o.length > 3 && sectionText.a.length > 3 && sectionText.p.length > 3,
                        remedy: 'Complete S, O, A, and P with individualized content before finalizing.'
                    }
                ];

                const criticalLabels = new Set([
                    'All SOAP sections completed',
                    'Assessment states medical necessity/progress',
                    'Subjective includes functional impact'
                ]);

                const passedCount = checks.filter(check => check.pass).length;
                const score = Math.round((passedCount / checks.length) * 100);
                const failedCritical = checks.filter(check => !check.pass && criticalLabels.has(check.label));
                const likelyPass = score >= 80 && failedCritical.length === 0;

                return {
                    score,
                    likelyPass,
                    checks,
                    opportunities: checks.filter(check => !check.pass).map(check => check.remedy),
                    timestamp: new Date().toISOString(),
                    summary: likelyPass
                        ? 'Likely audit-ready based on configured SOAP criteria.'
                        : 'This note can be strengthened for stronger audit support. Suggested refinements are listed below.'
                };
            };

            const renderAuditResults = (auditResult) => {
                if (!auditResult) {
                    return `
                        <div class="audit-box">
                            <div style="font-size: 0.85rem; color: var(--text-color-secondary);">Run the audit check to evaluate this SOAP note against the audit guide criteria.</div>
                        </div>
                    `;
                }

                return `
                    <div class="audit-box">
                        <div class="audit-summary">
                            <span><strong>Audit Score:</strong> ${auditResult.score}%</span>
                            <span class="audit-badge ${auditResult.likelyPass ? 'pass' : 'fail'}">${auditResult.likelyPass ? 'Likely Pass' : 'Needs Revision'}</span>
                        </div>
                        <div style="font-size: 0.84rem; margin-bottom: 6px; color: var(--text-color-secondary);">${auditResult.summary}</div>
                        <ul class="audit-items">
                            ${auditResult.checks.map(check => `<li class="${check.pass ? 'audit-item-pass' : 'audit-item-fail'}">${check.pass ? '‚úì' : '‚úó'} ${check.label}</li>`).join('')}
                        </ul>
                        ${auditResult.opportunities && auditResult.opportunities.length > 0 ? `
                            <div class="audit-remediation">
                                <strong>Ways to strengthen this note:</strong>
                                <ul>
                                    ${auditResult.opportunities.map(item => `<li>${item}</li>`).join('')}
                                </ul>
                            </div>
                        ` : ''}
                    </div>
                `;
            };

            const getTreatmentGoalsContext = (client) => {
                if (!client?.goals?.length) return '';
                const activeGoals = client.goals.filter(g => g.status === 'active');
                if (activeGoals.length === 0) return '';
                return `\n- **Current Treatment Goals:**\n${activeGoals.map(goal => {
                    const objectives = goal.objectives && goal.objectives.length > 0
                        ? goal.objectives.map(obj => `  - ${obj.text} (${obj.completed ? 'Completed' : 'In Progress'}, ${obj.timelineMonths || 3} months)`).join('\n')
                        : '  - No specific objectives defined';
                    return `  ‚Ä¢ ${goal.title} (${goal.timelineMonths || 12} months)\n${objectives}`;
                }).join('\n')}\n`;
            };

            const getSelectedObjectivesContext = (client) => {
                if (!client?.goals?.length) return '';
                const objectives = client.goals
                    .filter(goal => goal.status === 'active')
                    .flatMap(goal => (goal.objectives || []).filter(obj => !obj.completed).map(obj => `${obj.text} (${obj.timelineMonths || 3} months)`));
                if (!objectives.length) return '';
                return `\n- **Priority Objectives:**\n${objectives.map(obj => `  - ${obj}`).join('\n')}`;
            };

            const getInterventionContext = (appointment) => {
                if (!appointment?.selectedInterventions?.length) return '';
                return `\n- **Interventions Selected from Intervention Bank:**\n${appointment.selectedInterventions.map(item => `  - ${item}`).join('\n')}`;
            };

            const getInstructionsContext = (client, appointment) => {
                const persistent = (client?.persistentInstructions || '').trim();
                const session = (appointment?.sessionInstructions || '').trim();

                let context = '';
                if (persistent) {
                    context += `\n- **Persistent Instructions (Client-Level):**\n${persistent}`;
                }
                if (session) {
                    context += `\n- **Session Instructions (Appointment-Level):**\n${session}`;
                }
                if (persistent && session) {
                    context += `\n- **Instruction Precedence Rule:** If Session Instructions conflict with Persistent Instructions, follow Session Instructions for this note.`;
                }
                return context;
            };

            const getModalitiesContext = (modalitiesInput, otherInput) => {
                const modalities = Array.isArray(modalitiesInput) ? [...new Set(modalitiesInput.filter(Boolean))] : [];
                const other = (otherInput || '').trim();
                const normalized = modalities.filter(m => m && m !== 'Other (Specify)');
                if (modalities.includes('Other (Specify)') && other) {
                    normalized.push(`Other: ${other}`);
                }
                if (!normalized.length) return '';
                return normalized;
            };

            const getGoalGenerationModalitiesContext = () => getModalitiesContext(goalGeneratorModalities, goalGeneratorModalityOther);

            const getClientGoalGenerationLens = (client) => {
                if (!client) {
                    return {
                        modalities: [...DEFAULT_GUIDING_MODALITIES],
                        other: ''
                    };
                }

                if (!client.goalGenerationLens || typeof client.goalGenerationLens !== 'object') {
                    client.goalGenerationLens = {
                        modalities: [...DEFAULT_GUIDING_MODALITIES],
                        other: ''
                    };
                }

                if (!Array.isArray(client.goalGenerationLens.modalities) || client.goalGenerationLens.modalities.length === 0) {
                    client.goalGenerationLens.modalities = [...DEFAULT_GUIDING_MODALITIES];
                }
                if (typeof client.goalGenerationLens.other !== 'string') {
                    client.goalGenerationLens.other = '';
                }

                return {
                    modalities: [...client.goalGenerationLens.modalities],
                    other: client.goalGenerationLens.other
                };
            };

            const saveClientGoalGenerationLens = () => {
                const client = findClient(selectedClientId);
                if (!client) return;

                client.goalGenerationLens = {
                    modalities: [...new Set((goalGeneratorModalities || []).filter(Boolean))],
                    other: goalGeneratorModalityOther || ''
                };
                markDirty();
            };

            const getClientSoapModalityContext = (client, appointment) => {
                const lens = getClientGoalGenerationLens(client);
                const modalities = getModalitiesContext(lens.modalities, lens.other);
                if (!modalities || modalities.length === 0) return '';

                const explicitInterventionSignals = [
                    (appointment?.sessionInfo || '').trim(),
                    ...((appointment?.selectedInterventions || []).map(item => item && item.trim()).filter(Boolean))
                ].filter(Boolean);

                return `
- **Client Modality Lens (Default):**
${modalities.map(item => `  - ${item}`).join('\n')}
- **Lens Rule:** Use the listed modalities as a default framing only when consistent with the session content.
- **Override Rule (Required):** If Session Information or selected interventions explicitly indicate a different modality/technique, preserve those interventions as written and do NOT force-fit them into the default lens.
${explicitInterventionSignals.length > 0 ? `- **Explicit Intervention Signals from Session Data:**\n${explicitInterventionSignals.map(item => `  - ${item}`).join('\n')}` : ''}`;
            };

            const renderInterventionBank = () => {
                if (!interventionBankList) return;
                interventionBankList.innerHTML = (data.interventionBank || []).map((item, index) => `
                    <div class="intervention-row">
                        <span>${item}</span>
                        <button class="action-btn delete-btn" data-bank-index="${index}" title="Remove intervention" style="width:20px;height:20px;">√ó</button>
                    </div>
                `).join('');
            };

            const renderInterventionPicker = () => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (!appointment || !interventionPickerList) return;
                const selected = new Set(appointment.selectedInterventions || []);
                interventionPickerList.innerHTML = (data.interventionBank || []).map(item => `
                    <label class="intervention-row" style="cursor:pointer;">
                        <span>${item}</span>
                        <input type="checkbox" class="picker-intervention" value="${item.replace(/"/g, '&quot;')}" ${selected.has(item) ? 'checked' : ''}>
                    </label>
                `).join('');
            };

            const renderGuidingModalities = () => {
                if (!guidingModalitiesListEl || !guidingModalityOtherEl || !guidingModalityOtherWrapEl) return;

                if (!Array.isArray(goalGeneratorModalities) || goalGeneratorModalities.length === 0) {
                    goalGeneratorModalities = [...DEFAULT_GUIDING_MODALITIES];
                }

                guidingModalitiesListEl.innerHTML = goalGeneratorModalities.map((selectedModality, index) => `
                    <div class="modality-row" data-modality-index="${index}">
                        <select class="setting-input modality-select" data-modality-index="${index}">
                            ${GUIDING_MODALITY_OPTIONS.map(option => `<option value="${option.replace(/"/g, '&quot;')}" ${option === selectedModality ? 'selected' : ''}>${option}</option>`).join('')}
                        </select>
                        <button type="button" class="modality-row-btn add-modality-btn" title="Add modality">+</button>
                        <button type="button" class="modality-row-btn remove-modality-btn" title="Remove modality" ${goalGeneratorModalities.length <= 1 ? 'disabled' : ''}>‚àí</button>
                    </div>
                `).join('');

                guidingModalityOtherEl.value = goalGeneratorModalityOther || '';
                const hasOtherSelected = goalGeneratorModalities.includes('Other (Specify)');
                guidingModalityOtherWrapEl.classList.toggle('hidden', !hasOtherSelected);
                guidingModalityOtherEl.disabled = !hasOtherSelected;
            };

            const saveGuidingModalities = () => {
                const selected = Array.from(guidingModalitiesListEl.querySelectorAll('.modality-select')).map(el => el.value);
                goalGeneratorModalities = selected.filter(Boolean);
                if (!goalGeneratorModalities.includes('Other (Specify)')) {
                    goalGeneratorModalityOther = '';
                    guidingModalityOtherEl.value = '';
                    guidingModalityOtherEl.disabled = true;
                    guidingModalityOtherWrapEl.classList.add('hidden');
                } else {
                    guidingModalityOtherWrapEl.classList.remove('hidden');
                    guidingModalityOtherEl.disabled = false;
                    goalGeneratorModalityOther = guidingModalityOtherEl.value || '';
                }
                saveClientGoalGenerationLens();
            };

            const renderCustomInstructionsModalities = () => {
                if (!customInstructionsModalitiesListEl || !customInstructionsModalityOtherWrapEl || !customInstructionsModalityOtherEl) return;

                if (!Array.isArray(goalGeneratorModalities) || goalGeneratorModalities.length === 0) {
                    goalGeneratorModalities = [...DEFAULT_GUIDING_MODALITIES];
                }

                customInstructionsModalitiesListEl.innerHTML = goalGeneratorModalities.map((selectedModality, index) => `
                    <div class="modality-row" data-modal-instructions-index="${index}">
                        <select class="setting-input custom-instructions-modality-select" data-modal-instructions-index="${index}">
                            ${GUIDING_MODALITY_OPTIONS.map(option => `<option value="${option.replace(/"/g, '&quot;')}" ${option === selectedModality ? 'selected' : ''}>${option}</option>`).join('')}
                        </select>
                        <button type="button" class="modality-row-btn add-custom-modality-btn" title="Add modality">+</button>
                        <button type="button" class="modality-row-btn remove-custom-modality-btn" title="Remove modality" ${goalGeneratorModalities.length <= 1 ? 'disabled' : ''}>‚àí</button>
                    </div>
                `).join('');

                customInstructionsModalityOtherEl.value = goalGeneratorModalityOther || '';
                const hasOtherSelected = goalGeneratorModalities.includes('Other (Specify)');
                customInstructionsModalityOtherWrapEl.classList.toggle('hidden', !hasOtherSelected);
                customInstructionsModalityOtherEl.disabled = !hasOtherSelected;
            };

            const saveCustomInstructionsModalities = () => {
                const selected = Array.from(customInstructionsModalitiesListEl.querySelectorAll('.custom-instructions-modality-select')).map(el => el.value);
                goalGeneratorModalities = selected.filter(Boolean);
                if (!goalGeneratorModalities.includes('Other (Specify)')) {
                    goalGeneratorModalityOther = '';
                    customInstructionsModalityOtherEl.value = '';
                    customInstructionsModalityOtherEl.disabled = true;
                    customInstructionsModalityOtherWrapEl.classList.add('hidden');
                } else {
                    customInstructionsModalityOtherWrapEl.classList.remove('hidden');
                    customInstructionsModalityOtherEl.disabled = false;
                    goalGeneratorModalityOther = customInstructionsModalityOtherEl.value || '';
                }
                saveClientGoalGenerationLens();
            };

            const makeGoalText = (problem, index, modalities) => {
                const modalityHint = modalities[0] ? ` using ${modalities[0]}` : '';
                const templates = [
                    `Client will demonstrate improved management of ${problem}${modalityHint}, resulting in decreased symptom burden.`,
                    `Client will strengthen adaptive coping around ${problem}${modalityHint}, resulting in decreased functional impairment.`,
                    `Client will increase emotional regulation related to ${problem}${modalityHint}, resulting in decreased distress and improved stability.`,
                    `Client will improve consistency in healthy responses to ${problem}${modalityHint}, resulting in decreased escalation and improved daily functioning.`
                ];
                return templates[index % templates.length];
            };

            const makeObjectiveText = (problem, goalText, objectiveIndex, format, modalities) => {
                const modalityPhrase = modalities.length > 0 ? ` aligned with ${modalities[0]}` : '';
                if (format === 'smart') {
                    const smartTemplates = [
                        `Client will identify 2 triggers related to ${problem}${modalityPhrase} and document them in writing at least 3 days per week.`,
                        `Client will practice one coping strategy tied to ${goalText.toLowerCase()}${modalityPhrase} in at least 2 real-life situations each week.`,
                        `Client will track intensity of ${problem} symptoms weekly${modalityPhrase} and report trend changes during session.`,
                        `Client will use a structured self-regulation routine${modalityPhrase} and report at least 50% adherence by target review date.`
                    ];
                    return smartTemplates[objectiveIndex % smartTemplates.length];
                }

                const actionTemplates = [
                    `Client will identify patterns that maintain ${problem}${modalityPhrase} and discuss them in session.`,
                    `Client will identify and practice coping responses for ${problem}${modalityPhrase} between sessions.`,
                    `Client will identify barriers to progress${modalityPhrase} and use one replacement action in real-time.`,
                    `Client will identify gains and next steps${modalityPhrase} to sustain progress related to ${problem}.`
                ];
                return actionTemplates[objectiveIndex % actionTemplates.length];
            };

            const goalGenerationSystemPrompt = `You are assisting a mental health clinician with treatment-plan writing.

Return ONLY valid JSON in this exact shape:
{
  "goals": [
    {
      "title": "...",
      "timelineMonths": 12,
      "objectives": [
        {
          "text": "...",
          "timelineMonths": 3,
          "format": "action"
        }
      ]
    }
  ]
}

Requirements:
- Generate exactly the requested number of goals.
- Generate exactly the requested number of objectives per goal.
- Goal language: concise and outcome-focused, written as "Client will ... resulting in ...".
- Goals use 12-month timeline unless explicitly requested otherwise.
- Objectives use staggered timeline anchors across 3, 6, 9, 12 months.
- Objective text must be client-action focused.
- If objective format is "action", use action-oriented statements (for example: "Client will identify...").
- If objective format is "smart", produce SMART-style objective language.
- Use guiding modalities as conceptual framing when provided.
- Do NOT reference or imply any modality that is not explicitly selected.
- Do not include extra keys, commentary, markdown, or prose outside JSON.`;

            const MODALITY_TERM_MAP = {
                'CBT (Cognitive Behavioral Therapy)': ['CBT', 'Cognitive Behavioral Therapy'],
                'DBT (Dialectical Behavior Therapy)': ['DBT', 'Dialectical Behavior Therapy'],
                'ACT (Acceptance and Commitment Therapy)': ['ACT', 'Acceptance and Commitment Therapy'],
                'REBT (Rational Emotive Behavior Therapy)': ['REBT', 'Rational Emotive Behavior Therapy'],
                'CPT (Cognitive Processing Therapy)': ['CPT', 'Cognitive Processing Therapy'],
                'ERP (Exposure and Response Prevention)': ['ERP', 'Exposure and Response Prevention'],
                'Behavioral Activation (BA)': ['Behavioral Activation', 'BA'],
                'TF-CBT (Trauma-Focused CBT)': ['TF-CBT', 'Trauma-Focused CBT'],
                'Psychodynamic Psychotherapy': ['Psychodynamic Psychotherapy', 'Psychodynamic'],
                'Psychoanalysis': ['Psychoanalysis', 'Psychoanalytic'],
                'IFS (Internal Family Systems)': ['IFS', 'Internal Family Systems'],
                'Object Relations Therapy': ['Object Relations Therapy', 'Object Relations'],
                'Attachment-Based Therapy': ['Attachment-Based Therapy', 'Attachment Focused'],
                'EFT (Emotionally Focused Therapy)': ['EFT', 'Emotionally Focused Therapy'],
                'Person-Centered Therapy': ['Person-Centered Therapy', 'Client-Centered Therapy'],
                'Gestalt Therapy': ['Gestalt Therapy', 'Gestalt'],
                'Existential Therapy': ['Existential Therapy', 'Existential'],
                'Narrative Therapy': ['Narrative Therapy', 'Narrative'],
                'Solution-Focused Brief Therapy (SFBT)': ['SFBT', 'Solution-Focused Brief Therapy', 'Solution Focused'],
                'Logotherapy': ['Logotherapy']
            };

            const escapeRegExp = (text) => text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

            const sanitizeGoalTextByModalities = (text, selectedModalities) => {
                if (!text) return '';
                const selectedSet = new Set((selectedModalities || []).filter(item => !item.startsWith('Other:')));
                let sanitized = text;

                Object.entries(MODALITY_TERM_MAP).forEach(([option, terms]) => {
                    if (selectedSet.has(option)) return;
                    terms.forEach(term => {
                        const regex = new RegExp(`\\b${escapeRegExp(term)}\\b`, 'gi');
                        sanitized = sanitized.replace(regex, 'selected-modality');
                    });
                });

                return sanitized;
            };

            const extractJsonObject = (rawText) => {
                const text = (rawText || '').trim();
                const firstBrace = text.indexOf('{');
                const lastBrace = text.lastIndexOf('}');
                if (firstBrace === -1 || lastBrace === -1 || lastBrace < firstBrace) {
                    throw new Error('AI did not return a valid JSON object.');
                }
                const jsonText = text.slice(firstBrace, lastBrace + 1);
                return JSON.parse(jsonText);
            };

            const normalizeGoalDraftsFromAi = (aiPayload, problem, goalCount, objectiveCount, format, modalities) => {
                const staggeredTimeline = [3, 6, 9, 12];
                const aiGoals = Array.isArray(aiPayload?.goals) ? aiPayload.goals : [];
                const normalizedGoals = [];

                for (let goalIndex = 0; goalIndex < goalCount; goalIndex++) {
                    const aiGoal = aiGoals[goalIndex] || {};
                    const fallbackGoalTitle = makeGoalText(problem, goalIndex, modalities);
                    const goalTitle = (aiGoal.title || fallbackGoalTitle || '').toString().trim() || fallbackGoalTitle;
                    const timelineMonths = parseInt(aiGoal.timelineMonths, 10) || 12;

                    const aiObjectives = Array.isArray(aiGoal.objectives) ? aiGoal.objectives : [];
                    const objectives = [];
                    for (let objectiveIndex = 0; objectiveIndex < objectiveCount; objectiveIndex++) {
                        const aiObjective = aiObjectives[objectiveIndex] || {};
                        const fallbackObjectiveText = makeObjectiveText(problem, goalTitle, objectiveIndex, format, modalities);
                        const objectiveText = (aiObjective.text || fallbackObjectiveText || '').toString().trim() || fallbackObjectiveText;
                        const fallbackTimeline = staggeredTimeline[Math.min(objectiveIndex, staggeredTimeline.length - 1)];
                        const objectiveTimeline = parseInt(aiObjective.timelineMonths, 10) || fallbackTimeline;
                        const objectiveFormat = aiObjective.format === 'smart' ? 'smart' : format;

                        objectives.push({
                            id: crypto.randomUUID(),
                            approved: false,
                            text: sanitizeGoalTextByModalities(objectiveText, modalities),
                            timelineMonths: objectiveTimeline,
                            format: objectiveFormat,
                            completed: false,
                            dateCreated: new Date().toISOString()
                        });
                    }

                    normalizedGoals.push({
                        id: crypto.randomUUID(),
                        approved: false,
                        title: sanitizeGoalTextByModalities(goalTitle, modalities),
                        timelineMonths,
                        objectives
                    });
                }

                return normalizedGoals;
            };

            const fetchGoalDraftsFromAI = async (problem, goalCount, objectiveCount, format, modalities) => {
                if (!selectedModel) {
                    throw new Error('Please connect to a provider and select a model in Settings.');
                }

                const styleDescriptor = format === 'smart' ? 'smart' : 'action-focused';
                const selectedModalityOptions = modalities.filter(item => !item.startsWith('Other:'));
                const forbiddenModalityOptions = GUIDING_MODALITY_OPTIONS
                    .filter(item => item !== 'Other (Specify)' && !selectedModalityOptions.includes(item));
                const modalityContext = modalities.length > 0 ? modalities.map(item => `- ${item}`).join('\n') : '- None specified';
                const forbiddenContext = forbiddenModalityOptions.length > 0
                    ? forbiddenModalityOptions.map(item => `- ${item}`).join('\n')
                    : '- None';

                const userPrompt = `Problem/Diagnosis Focus:\n${problem}\n\nRequested Output:\n- Goals: ${goalCount}\n- Objectives per goal: ${objectiveCount}\n- Objective format: ${styleDescriptor}\n\nGuiding Modalities (Allowed):\n${modalityContext}\n\nForbidden Modalities (Do not use):\n${forbiddenContext}\n\nReturn only JSON in the required schema.`;

                if (apiProvider === 'gemini') {
                    if (!geminiApiKey) throw new Error('Please connect Gemini in Settings first.');
                    const payload = {
                        contents: [{ parts: [{ text: `${goalGenerationSystemPrompt}\n\n${userPrompt}` }] }],
                        generationConfig: { response_mime_type: 'application/json' }
                    };
                    const url = `https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent?key=${geminiApiKey}`;
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Gemini API error: ${response.status} - ${errorText}`);
                    }
                    const result = await response.json();
                    const content = result?.candidates?.[0]?.content?.parts?.[0]?.text;
                    return extractJsonObject(content);
                }

                if (apiProvider === 'vertex') {
                    if (!vertexProjectId || !vertexLocation || (!vertexAccessToken && !hasVertexProxy())) throw new Error('Please connect Vertex in Settings first.');
                    const usingApiKey = isLikelyGoogleApiKey(vertexAccessToken);
                    const payload = usingApiKey
                        ? {
                            contents: [{ parts: [{ text: `${goalGenerationSystemPrompt}\n\n${userPrompt}` }] }],
                            generationConfig: { response_mime_type: 'application/json' }
                        }
                        : {
                            contents: [{ parts: [{ text: `${goalGenerationSystemPrompt}\n\n${userPrompt}` }] }],
                            generationConfig: { responseMimeType: 'application/json' }
                        };
                    if (hasVertexProxy()) {
                        const proxyResult = await callVertexProxyGenerate(selectedModel, payload);
                        const content = proxyResult?.candidates?.[0]?.content?.parts?.[0]?.text;
                        return extractJsonObject(content);
                    }
                    const auth = getVertexAuthConfig(vertexAccessToken);
                    const url = usingApiKey
                        ? `https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent${auth.query}`
                        : `https://${vertexLocation}-aiplatform.googleapis.com/v1/projects/${vertexProjectId}/locations/${vertexLocation}/publishers/google/models/${selectedModel}:generateContent${auth.query}`;
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            ...auth.headers
                        },
                        body: JSON.stringify(payload)
                    });
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Vertex API error: ${response.status} - ${errorText}`);
                    }
                    const result = await response.json();
                    const content = result?.candidates?.[0]?.content?.parts?.[0]?.text;
                    return extractJsonObject(content);
                }

                if (apiProvider === 'openai') {
                    if (!openaiApiKey) throw new Error('Please connect OpenAI in Settings first.');
                    const payload = {
                        model: selectedModel,
                        messages: [
                            { role: 'system', content: goalGenerationSystemPrompt },
                            { role: 'user', content: userPrompt }
                        ],
                        response_format: { type: 'json_object' }
                    };
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${openaiApiKey}`
                        },
                        body: JSON.stringify(payload)
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`OpenAI API error: ${response.status} - ${errorData?.error?.message || 'Unknown error'}`);
                    }
                    const result = await response.json();
                    const content = result?.choices?.[0]?.message?.content;
                    return extractJsonObject(content);
                }

                if (apiProvider === 'openwebui') {
                    if (!serverAddress) throw new Error('Please connect Open WebUI in Settings first.');
                    const payload = {
                        model: selectedModel,
                        messages: [
                            { role: 'system', content: goalGenerationSystemPrompt },
                            { role: 'user', content: userPrompt }
                        ],
                        response_format: { type: 'json_object' },
                        stream: false
                    };
                    const headers = new Headers({ 'Content-Type': 'application/json' });
                    if (apiKey) headers.append('Authorization', `Bearer ${apiKey}`);
                    const response = await fetch(`${serverAddress}/api/v1/chat/completions`, {
                        method: 'POST',
                        headers,
                        body: JSON.stringify(payload),
                        mode: 'cors'
                    });
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Open WebUI API error: ${response.status} - ${errorText}`);
                    }
                    const result = await response.json();
                    const content = result?.choices?.[0]?.message?.content;
                    return extractJsonObject(content);
                }

                throw new Error('Invalid API provider selected.');
            };

            const generateGoalDrafts = async () => {
                const problem = (goalProblemInput.value || '').trim();
                const goalCount = Math.max(1, Math.min(8, parseInt(goalCountInput.value, 10) || 1));
                const objectiveCount = Math.max(1, Math.min(6, parseInt(objectiveCountInput.value, 10) || 1));
                const format = objectiveStyleSelect.value === 'smart' ? 'smart' : 'action';
                const modalities = getGoalGenerationModalitiesContext();
                saveClientGoalGenerationLens();

                if (!problem) {
                    alert('Please enter a problem/diagnosis focus first.');
                    return;
                }

                runGoalGeneratorBtn.disabled = true;
                runGoalGeneratorBtn.textContent = 'Generating...';

                try {
                    const aiPayload = await fetchGoalDraftsFromAI(problem, goalCount, objectiveCount, format, modalities);
                    generatedGoalsDraft = normalizeGoalDraftsFromAi(aiPayload, problem, goalCount, objectiveCount, format, modalities);
                    renderGeneratedGoalsReview();
                } catch (error) {
                    console.error('Goal generation error:', error);
                    alert(`Failed to generate goals/objectives with AI. ${error.message}`);
                } finally {
                    runGoalGeneratorBtn.disabled = false;
                    runGoalGeneratorBtn.textContent = 'Generate Draft';
                }
            };

            const renderGeneratedGoalsReview = () => {
                if (!generatedGoalsReview) return;
                if (!generatedGoalsDraft.length) {
                    generatedGoalsReview.innerHTML = '<div class="no-selection">Generate a draft to review, edit, and approve.</div>';
                    applyGeneratedGoalsBtn.disabled = true;
                    return;
                }

                generatedGoalsReview.innerHTML = generatedGoalsDraft.map((goal, goalIndex) => `
                    <div class="generator-card" data-draft-goal-index="${goalIndex}">
                        <div class="generator-title">Goal ${goalIndex + 1}</div>
                        <div style="display:grid;grid-template-columns:1fr 110px 120px;gap:8px;align-items:end;margin-bottom:8px;">
                            <div>
                                <label style="font-size:0.82rem;font-weight:600;display:block;margin-bottom:4px;">Goal Text</label>
                                <textarea class="mini-input draft-goal-text" rows="2">${goal.title}</textarea>
                            </div>
                            <div>
                                <label style="font-size:0.82rem;font-weight:600;display:block;margin-bottom:4px;">Timeline (mo)</label>
                                <input type="number" class="mini-input draft-goal-timeline" min="1" max="24" value="${goal.timelineMonths || 12}">
                            </div>
                            <label style="display:flex;align-items:center;gap:6px;font-size:0.85rem;">
                                <input type="checkbox" class="draft-goal-approved" ${goal.approved ? 'checked' : ''}> Approve Goal
                            </label>
                        </div>
                        ${(goal.objectives || []).map((obj, objIndex) => `
                            <div style="display:grid;grid-template-columns:1fr 110px 140px;gap:8px;align-items:end;margin:6px 0 0 0;" data-draft-objective-index="${objIndex}">
                                <div>
                                    <label style="font-size:0.8rem;font-weight:600;display:block;margin-bottom:4px;">Objective ${objIndex + 1}</label>
                                    <textarea class="mini-input draft-obj-text" rows="2">${obj.text}</textarea>
                                </div>
                                <div>
                                    <label style="font-size:0.8rem;font-weight:600;display:block;margin-bottom:4px;">Timeline (mo)</label>
                                    <input type="number" class="mini-input draft-obj-timeline" min="1" max="24" value="${obj.timelineMonths || 3}">
                                </div>
                                <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
                                    <select class="mini-input draft-obj-format" style="max-width:120px;">
                                        <option value="action" ${obj.format === 'action' ? 'selected' : ''}>Action</option>
                                        <option value="smart" ${obj.format === 'smart' ? 'selected' : ''}>SMART</option>
                                    </select>
                                    <label style="display:flex;align-items:center;gap:6px;font-size:0.85rem;white-space:nowrap;">
                                        <input type="checkbox" class="draft-obj-approved" ${obj.approved ? 'checked' : ''}> Approve
                                    </label>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `).join('');

                syncGeneratedGoalsFromReview();
            };

            const syncGeneratedGoalsFromReview = () => {
                const goalCards = Array.from(generatedGoalsReview.querySelectorAll('[data-draft-goal-index]'));
                goalCards.forEach(card => {
                    const goalIndex = parseInt(card.dataset.draftGoalIndex, 10);
                    const draftGoal = generatedGoalsDraft[goalIndex];
                    if (!draftGoal) return;

                    draftGoal.title = (card.querySelector('.draft-goal-text')?.value || '').trim();
                    draftGoal.timelineMonths = parseInt(card.querySelector('.draft-goal-timeline')?.value || '12', 10) || 12;
                    draftGoal.approved = !!card.querySelector('.draft-goal-approved')?.checked;

                    const objectiveRows = Array.from(card.querySelectorAll('[data-draft-objective-index]'));
                    objectiveRows.forEach(row => {
                        const objIndex = parseInt(row.dataset.draftObjectiveIndex, 10);
                        const draftObj = draftGoal.objectives?.[objIndex];
                        if (!draftObj) return;
                        draftObj.text = (row.querySelector('.draft-obj-text')?.value || '').trim();
                        draftObj.timelineMonths = parseInt(row.querySelector('.draft-obj-timeline')?.value || '3', 10) || 3;
                        draftObj.format = row.querySelector('.draft-obj-format')?.value === 'smart' ? 'smart' : 'action';
                        draftObj.approved = !!row.querySelector('.draft-obj-approved')?.checked;
                    });
                });

                applyGeneratedGoalsBtn.disabled = generatedGoalsDraft.length === 0;
            };

            const applyGeneratedGoals = () => {
                const client = findClient(selectedClientId);
                if (!client) return;
                syncGeneratedGoalsFromReview();

                const approvedGoals = generatedGoalsDraft
                    .filter(goal => goal.approved && (goal.title || '').trim())
                    .map(goal => ({
                        ...goal,
                        objectives: (goal.objectives || []).filter(obj => obj.approved && (obj.text || '').trim())
                    }))
                    .filter(goal => goal.objectives.length > 0);

                if (approvedGoals.length === 0) {
                    alert('Approve at least one goal and one objective under it, then click Apply Approved Goals.');
                    return;
                }

                if (!Array.isArray(client.goals)) client.goals = [];
                approvedGoals.forEach(draftGoal => {
                    client.goals.push({
                        id: crypto.randomUUID(),
                        title: draftGoal.title,
                        timelineMonths: draftGoal.timelineMonths,
                        status: 'active',
                        objectives: (draftGoal.objectives || []).map(obj => ({
                            id: crypto.randomUUID(),
                            text: obj.text,
                            timelineMonths: obj.timelineMonths,
                            format: obj.format,
                            completed: false,
                            dateCreated: new Date().toISOString()
                        })),
                        dateCreated: new Date().toISOString()
                    });
                });

                generatedGoalsDraft = [];
                renderGeneratedGoalsReview();
                goalGeneratorModal.classList.add('hidden');
                markDirty();
                renderGoals();
            };
            
            // --- UI Rendering ---
            const renderClients = () => {
                // Note: Drag and drop reordering means we can't sort here anymore.
                // The array order is now the source of truth for display order.
                const clients = data.clients; 
                if (clients.length === 0) {
                    clientListEl.innerHTML = '<div class="no-selection">Click + to add a client</div>';
                    return;
                }
                clientListEl.innerHTML = clients.map(client => `
                    <div class="client-item ${client.id === selectedClientId ? 'active' : ''}" data-client-id="${client.id}" draggable="true">
                        ${client.name}
                        <div class="action-buttons">
                            <button class="action-btn edit-btn" title="Edit Name">‚úèÔ∏è</button>
                            <button class="action-btn archive-btn" title="Archive Client">A</button>
                            <button class="action-btn delete-btn" title="Delete Client">√ó</button>
                        </div>
                    </div>
                `).join('');
            };

            const renderAppointments = () => {
                const client = findClient(selectedClientId);
                addAppointmentBtn.disabled = !client;
                addIntakeBtn.disabled = !client;
                addNoteBtn.disabled = !client;
                if (!client) {
                    appointmentListEl.innerHTML = '<div class="no-selection">Select a client first</div>';
                    return;
                }

                if (!Array.isArray(client.notes)) client.notes = [];
                if (!Array.isArray(client.intakeSessions)) client.intakeSessions = [];
                const appointments = (client.appointments || []).sort((a, b) => new Date(b.date) - new Date(a.date));
                const notes = (client.notes || []).slice().sort((a, b) => new Date(b.updatedAt || b.createdAt || 0) - new Date(a.updatedAt || a.createdAt || 0));
                const intakeSessions = (client.intakeSessions || []).slice().sort((a, b) => new Date(b.createdAt || 0) - new Date(a.createdAt || 0));

                if (appointments.length === 0 && intakeSessions.length === 0 && notes.length === 0) {
                    appointmentListEl.innerHTML = '<div class="no-selection">Click + to add appointment, intake session, or note</div>';
                    return;
                }

                const appointmentsHtml = appointments.length > 0 ? `
                    <div class="list-subheader">Appointments</div>
                    ${appointments.map(appt => `
                        <div class="appointment-item ${appt.id === selectedAppointmentId ? 'active' : ''}" data-appointment-id="${appt.id}">
                            <div class="appointment-date">${new Date(appt.date).toLocaleDateString()}</div>
                            <div class="action-buttons">
                                <button class="action-btn delete-btn" title="Delete Appointment">√ó</button>
                            </div>
                        </div>
                    `).join('')}
                ` : '';

                const notesHtml = notes.length > 0 ? `
                    <div class="list-subheader">Notes</div>
                    ${notes.map(note => `
                        <div class="note-item ${note.id === selectedNoteId ? 'active' : ''}" data-note-id="${note.id}">
                            <div class="note-name">üìù ${note.name}</div>
                            <div class="action-buttons">
                                <button class="action-btn edit-btn" title="Rename Note">‚úèÔ∏è</button>
                                <button class="action-btn delete-btn" title="Delete Note">√ó</button>
                            </div>
                        </div>
                    `).join('')}
                ` : '';

                const intakeHtml = intakeSessions.length > 0 ? `
                    <div class="list-subheader">Intake Sessions</div>
                    ${intakeSessions.map(intake => `
                        <div class="intake-item ${intake.id === selectedIntakeId ? 'active' : ''}" data-intake-id="${intake.id}">
                            <div class="note-name">üìã Intake Session ${new Date(intake.createdAt).toLocaleDateString()}</div>
                            <div class="action-buttons">
                                <button class="action-btn delete-btn" title="Delete Intake Session">√ó</button>
                            </div>
                        </div>
                    `).join('')}
                ` : '';

                appointmentListEl.innerHTML = `${appointmentsHtml}${intakeHtml}${notesHtml}`;
            };

            const renderDetails = () => {
                const client = findClient(selectedClientId);
                const appointment = client ? findAppointment(client, selectedAppointmentId) : null;
                const note = client ? findNote(client, selectedNoteId) : null;
                const intakeSession = client ? findIntakeSession(client, selectedIntakeId) : null;
                
                persistentNotesEl.disabled = !client;
                persistentNotesEl.value = client ? client.persistentNotes || '' : '';
                persistentNotesEl.placeholder = client ? "Enter persistent notes for this client..." : "Select a client to enter persistent notes...";

                sessionInfoEl.disabled = !appointment && !note;
                sessionInfoEl.value = appointment
                    ? appointment.sessionInfo || ''
                    : (note ? note.sessionInfo || '' : '');
                sessionInfoEl.placeholder = appointment
                    ? "Enter session details..."
                    : (note ? "Enter freeform note details..." : "Select an appointment or note to begin...");

                const isNoteMode = !appointment && !!note && !intakeSession;
                if (appointment || isNoteMode) {
                    sessionInfoEl.rows = 20;
                    sessionInfoEl.style.minHeight = '20lh';
                    sessionInfoEl.style.resize = 'vertical';
                    sessionInfoEl.style.width = '100%';
                    sessionInfoEl.style.flex = isNoteMode ? '1 1 auto' : '0 0 auto';
                } else {
                    sessionInfoEl.rows = 8;
                    sessionInfoEl.style.minHeight = '';
                    sessionInfoEl.style.resize = 'vertical';
                    sessionInfoEl.style.width = '100%';
                    sessionInfoEl.style.flex = '0 0 auto';
                }

                regularSessionFieldsEl.classList.toggle('hidden', !!intakeSession);
                intakeSessionBlockEl.classList.toggle('hidden', !intakeSession);
                auditProofingBlockEl.classList.toggle('hidden', !appointment);
                renderIntakeFields(intakeSession);

                const auditProofing = getAuditProofingData(appointment);
                [
                    auditProofSymptomsEl,
                    auditProofFunctionalEl,
                    auditProofProgressEl,
                    auditProofGoalEl,
                    auditProofNecessityEl
                ].forEach(field => {
                    field.disabled = !appointment;
                });
                auditProofSymptomsEl.value = appointment ? auditProofing.symptoms : '';
                auditProofFunctionalEl.value = appointment ? auditProofing.functionalImpact : '';
                auditProofProgressEl.value = appointment ? auditProofing.progressResponse : '';
                auditProofGoalEl.value = appointment ? auditProofing.goalAlignment : '';
                auditProofNecessityEl.value = appointment ? auditProofing.medicalNecessity : '';
                
                persistentInstructions = client ? client.persistentInstructions || '' : '';
                sessionInstructions = appointment ? appointment.sessionInstructions || '' : '';
                customInstructionsBtn.disabled = !client;
                
                updateAppointmentDateBtn.disabled = !appointment;
                addAppointmentBtn.disabled = !client;
                addIntakeBtn.disabled = !client;
                renameNoteBtn.disabled = !note;
                noteNameInput.disabled = !client;
                generateGoalsBtn.disabled = !client;

                sessionTimerWrapper.style.display = appointment ? 'block' : 'none';
                if (appointment) {
                    renderSessionTimer(appointment);
                }

                renderGoals();
                renderSoap();
                
                generateNoteBtn.disabled = !appointment || !hasAppointmentGenerationInput(appointment);
            };

            const renderGoals = () => {
                const client = findClient(selectedClientId);
                addGoalBtnInTab.disabled = !client;
                generateGoalsBtn.disabled = !client;
                
                if (!client) {
                    goalsListInTabEl.innerHTML = '<div class="no-selection">Select a client to manage goals</div>';
                    return;
                }

                if (!client.goals) {
                    client.goals = [];
                }

                if (client.goals.length === 0) {
                    goalsListInTabEl.innerHTML = '<div class="no-selection">Click + to add a treatment goal</div>';
                    return;
                }

                goalsListInTabEl.innerHTML = client.goals.map(goal => `
                    <div class="goal-item" data-goal-id="${goal.id}">
                        <div class="goal-header">
                            <div class="goal-title">${goal.title}</div>
                            <div style="display: flex; align-items: center;">
                                <div class="goal-status" style="margin-right: 8px;">${goal.timelineMonths || 12} mo</div>
                                <div class="goal-status ${goal.status}">${goal.status.charAt(0).toUpperCase() + goal.status.slice(1)}</div>
                                <div class="goal-actions">
                                    <button class="action-btn edit-btn" title="Edit Goal">‚úèÔ∏è</button>
                                    <button class="action-btn timeline-btn" title="Edit Goal Timeline">‚è±</button>
                                    <button class="action-btn archive-btn" title="Change Status">‚ö°</button>
                                    <button class="action-btn delete-btn" title="Delete Goal">√ó</button>
                                </div>
                            </div>
                        </div>
                        <div class="objective-list">
                            ${(goal.objectives || []).map(obj => `
                                <div class="objective-item" data-objective-id="${obj.id}">
                                    <input type="checkbox" class="objective-checkbox" ${obj.completed ? 'checked' : ''}>
                                    <span class="objective-text ${obj.completed ? 'completed' : ''}">${obj.text}</span>
                                    <span class="goal-status" style="margin-left: 6px;">${obj.timelineMonths || 3} mo</span>
                                    <button class="action-btn edit-objective-btn" title="Edit Objective" style="opacity: 0; width: 16px; height: 16px; font-size: 10px; background:#3498db;">‚úèÔ∏è</button>
                                    <button class="action-btn timeline-objective-btn" title="Edit Objective Timeline" style="opacity: 0; width: 16px; height: 16px; font-size: 10px; background:#e67e22;">‚è±</button>
                                    <button class="action-btn delete-btn" title="Delete Objective" style="opacity: 0; width: 16px; height: 16px; font-size: 10px;">√ó</button>
                                </div>
                            `).join('')}
                            <button class="add-objective-btn" data-goal-id="${goal.id}">+ Add Objective</button>
                        </div>
                    </div>
                `).join('');
            };
            
            const renderSessionTimer = (appointment) => {
                clearInterval(sessionTimerInterval);

                if (appointment.startTime) {
                    startTimerBtn.textContent = `Start: ${new Date(appointment.startTime).toLocaleTimeString()}`;
                } else {
                    startTimerBtn.textContent = 'Start';
                }

                if (appointment.endTime) {
                    stopTimerBtn.textContent = `End: ${new Date(appointment.endTime).toLocaleTimeString()}`;
                } else {
                    stopTimerBtn.textContent = 'Stop';
                }

                const updateDuration = () => {
                    if (!appointment.startTime) {
                        sessionDurationEl.textContent = '00:00';
                        return;
                    }
                    
                    const start = new Date(appointment.startTime);
                    const end = appointment.endTime ? new Date(appointment.endTime) : new Date();
                    
                    let totalSeconds = Math.floor((end - start) / 1000);
                    if (totalSeconds < 0) totalSeconds = 0;

                    const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
                    const seconds = (totalSeconds % 60).toString().padStart(2, '0');
                    
                    sessionDurationEl.textContent = `${minutes}:${seconds}`;
                };

                updateDuration();

                // If the timer is running (start time exists but no end time), set an interval to update it.
                if (appointment.startTime && !appointment.endTime) {
                    sessionTimerInterval = setInterval(updateDuration, 1000);
                }
            };

            const renderSoap = () => {
                const client = findClient(selectedClientId);
                const appointment = client ? findAppointment(client, selectedAppointmentId) : null;
                const note = client ? findNote(client, selectedNoteId) : null;
                const intakeSession = client ? findIntakeSession(client, selectedIntakeId) : null;

                if (!appointment) {
                    if (intakeSession) {
                        soapContentEl.innerHTML = '<div class="no-selection">Selected item is an Intake Session. Intake sessions do not qualify for generated SOAP notes.</div>';
                        return;
                    }
                    if (note) {
                        soapContentEl.innerHTML = '<div class="no-selection">Selected item is a Note. SOAP note generation and SOAP editing are disabled for Notes.</div>';
                        return;
                    }
                    soapContentEl.innerHTML = '<div class="no-selection">Select an appointment to begin</div>';
                    return;
                }

                const soapData = appointment.soap || { s: '', o: '', a: '', p: '' };
                if (!Array.isArray(appointment.selectedInterventions)) appointment.selectedInterventions = [];
                const interventions = appointment.selectedInterventions.length > 0
                    ? appointment.selectedInterventions.map(item => `‚Ä¢ ${item}`).join('\n')
                    : (soapData.interventions || 'No interventions selected from the bank.');
                const auditResult = appointment.auditCheck || null;
                soapContentEl.innerHTML = `
                    <div class="soap-section">
                        <div class="soap-header"><span>Subjective</span><button class="copy-btn" data-target="soapS">Copy</button></div>
                        <textarea id="soapS" class="soap-textarea" placeholder="‚Ä¢ " autocorrect="off" autocapitalize="off" spellcheck="true">${soapData.s || ''}</textarea>
                        ${(soapData.s_suggestion || []).map((s, i) => renderSuggestionBox('s', s, i)).join('')}
                    </div>
                    <div class="soap-section">
                        <div class="soap-header"><span>Objective</span><button class="copy-btn" data-target="soapO">Copy</button></div>
                        <textarea id="soapO" class="soap-textarea" placeholder="‚Ä¢ " autocorrect="off" autocapitalize="off" spellcheck="true">${soapData.o || ''}</textarea>
                        ${(soapData.o_suggestion || []).map((s, i) => renderSuggestionBox('o', s, i)).join('')}
                    </div>
                    <div class="soap-section">
                        <div class="soap-header"><span>Assessment</span><button class="copy-btn" data-target="soapA">Copy</button></div>
                        <textarea id="soapA" class="soap-textarea" placeholder="‚Ä¢ " autocorrect="off" autocapitalize="off" spellcheck="true">${soapData.a || ''}</textarea>
                        ${(soapData.a_suggestion || []).map((s, i) => renderSuggestionBox('a', s, i)).join('')}
                    </div>
                    <div class="soap-section">
                        <div class="soap-header"><span>Plan</span><button class="copy-btn" data-target="soapP">Copy</button></div>
                        <textarea id="soapP" class="soap-textarea" placeholder="‚Ä¢ " autocorrect="off" autocapitalize="off" spellcheck="true">${soapData.p || ''}</textarea>
                        ${(soapData.p_suggestion || []).map((s, i) => renderSuggestionBox('p', s, i)).join('')}
                    </div>
                    <div class="soap-section">
                        <div class="soap-header"><span>Interventions</span><div><button id="selectInterventionsBtn" class="copy-btn" style="margin-right:6px;">Select from Bank</button><button class="copy-btn" data-target="interventions">Copy</button></div></div>
                        <textarea id="interventions" class="soap-textarea" readonly autocorrect="off" autocapitalize="off" spellcheck="true">${interventions}</textarea>
                    </div>
                    <div class="soap-section">
                        <div class="soap-header"><span>Audit Check</span><button id="runSoapAuditBtn" class="copy-btn">Run Audit Check</button></div>
                        ${renderAuditResults(auditResult)}
                    </div>`;
                
                // After rendering, resize all textareas
                soapContentEl.querySelectorAll('.soap-textarea').forEach(el => {
                    if (!el.readOnly) { // Don't auto-resize the read-only interventions box
                        autoResizeTextarea(el);
                    }
                });
            };

            const renderSuggestionBox = (type, suggestion, index) => {
                if (!suggestion) return '';

                let suggestionTitle;
                let suggestionContent;
                let actionsHtml;

                const isReplacement = typeof suggestion === 'object' && suggestion.original && suggestion.suggested;

                if (isReplacement) {
                    suggestionTitle = 'Clinical Language Suggestion:';
                    suggestionContent = `
                        <div><strong>Original:</strong> ${suggestion.original}</div>
                        <div style="margin-top: 4px;"><strong>Suggested:</strong> ${suggestion.suggested}</div>
                    `;
                    actionsHtml = `
                        <button class="suggestion-decline">Keep Original</button>
                        <button class="suggestion-accept-replace">Use Suggestion</button>
                    `;
                } else { // It's a new suggestion (string)
                    suggestionTitle = 'Suggestion for Addition:';
                    suggestionContent = `<strong>${suggestionTitle}</strong> ${suggestion}`;
                    actionsHtml = `
                        <button class="suggestion-accept">Accept</button>
                        <button class="suggestion-decline">Decline</button>
                    `;
                }

                return `
                    <div class="suggestion-box" data-suggestion-type="${type}" data-suggestion-index="${index}">
                        <div class="suggestion-text">${suggestionContent}</div>
                        <div class="suggestion-actions">
                            ${actionsHtml}
                        </div>
                    </div>
                `;
            };

            const renderDeletedLists = () => {
                deletedClientsListEl.innerHTML = '';
                clearDeletedClientsBtn.classList.toggle('hidden', deletedItems.clients.length === 0);
                deletedItems.clients.forEach(client => {
                    const div = document.createElement('div');
                    div.className = 'deleted-item';
                    div.innerHTML = `<span>${client.name}</span><button class="restore-btn" data-id="${client.id}">Restore</button>`;
                    deletedClientsListEl.appendChild(div);
                });

                deletedAppointmentsListEl.innerHTML = '';
                 clearDeletedAppointmentsBtn.classList.toggle('hidden', deletedItems.appointments.length === 0);
                deletedItems.appointments.forEach(appt => {
                    const clientName = findClient(appt.clientId)?.name?.substring(0, 5) + '...' || 'N/A';
                    const div = document.createElement('div');
                    div.className = 'deleted-item';
                    div.innerHTML = `<span>${new Date(appt.date).toLocaleDateString()} (${clientName})</span><button class="restore-btn" data-id="${appt.id}">Restore</button>`;
                    deletedAppointmentsListEl.appendChild(div);
                });
            };

            const renderArchivedClients = () => {
                archivedClientsListEl.innerHTML = '';
                (data.archivedClients || []).forEach(client => {
                     const div = document.createElement('div');
                     div.className = 'deleted-item';
                     div.innerHTML = `<span>${client.name}</span><button class="restore-btn" data-id="${client.id}">Unarchive</button>`;
                     archivedClientsListEl.appendChild(div);
                });
            };

            const fullRender = () => {
                renderClients();
                renderAppointments();
                renderDetails();
                renderDeletedLists();
                renderArchivedClients();
            };

            // --- Event Handlers & Actions ---
            const selectClient = (id) => {
                selectedClientId = id;
                selectedAppointmentId = null;
                selectedNoteId = null;
                selectedIntakeId = null;
                clearInterval(sessionTimerInterval); // Stop timer when switching clients
                fullRender();
            };

            const selectAppointment = (id) => {
                selectedAppointmentId = id;
                selectedNoteId = null;
                selectedIntakeId = null;
                fullRender();
            };

            const selectNote = (id) => {
                selectedNoteId = id;
                selectedAppointmentId = null;
                selectedIntakeId = null;
                fullRender();
            };

            const selectIntakeSession = (id) => {
                selectedIntakeId = id;
                selectedAppointmentId = null;
                selectedNoteId = null;
                fullRender();
            };

            const addGoal = () => {
                const client = findClient(selectedClientId);
                if (!client) return;
                
                const title = prompt("Enter goal title:");
                if (!title || !title.trim()) return;
                
                const newGoal = {
                    id: crypto.randomUUID(),
                    title: title.trim(),
                    timelineMonths: 12,
                    status: 'active',
                    objectives: [],
                    dateCreated: new Date().toISOString()
                };
                
                if (!client.goals) client.goals = [];
                client.goals.push(newGoal);
                markDirty();
                renderGoals();
            };

            const addObjective = (goalId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                
                const goal = client.goals.find(g => g.id === goalId);
                if (!goal) return;
                
                const text = prompt("Enter objective:");
                if (!text || !text.trim()) return;
                
                const newObjective = {
                    id: crypto.randomUUID(),
                    text: text.trim(),
                    timelineMonths: 3,
                    format: 'action',
                    completed: false,
                    dateCreated: new Date().toISOString()
                };
                
                if (!goal.objectives) goal.objectives = [];
                goal.objectives.push(newObjective);
                markDirty();
                renderGoals();
            };

            const toggleObjective = (goalId, objectiveId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                
                const goal = client.goals.find(g => g.id === goalId);
                if (!goal) return;
                
                const objective = goal.objectives.find(o => o.id === objectiveId);
                if (!objective) return;
                
                objective.completed = !objective.completed;
                if (objective.completed) {
                    objective.dateCompleted = new Date().toISOString();
                } else {
                    delete objective.dateCompleted;
                }
                
                markDirty();
                renderGoals();
            };

            const deleteGoal = (goalId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                
                const goalIndex = client.goals.findIndex(g => g.id === goalId);
                if (goalIndex === -1) return;
                
                const goal = client.goals[goalIndex];
                if (confirm(`Are you sure you want to delete the goal "${goal.title}"?`)) {
                    client.goals.splice(goalIndex, 1);
                    markDirty();
                    renderGoals();
                }
            };

            const deleteObjective = (goalId, objectiveId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                
                const goal = client.goals.find(g => g.id === goalId);
                if (!goal) return;
                
                const objIndex = goal.objectives.findIndex(o => o.id === objectiveId);
                if (objIndex === -1) return;
                
                goal.objectives.splice(objIndex, 1);
                markDirty();
                renderGoals();
            };

            const changeGoalStatus = (goalId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                
                const goal = client.goals.find(g => g.id === goalId);
                if (!goal) return;
                
                const statuses = ['active', 'completed', 'discontinued'];
                const currentIndex = statuses.indexOf(goal.status);
                const nextIndex = (currentIndex + 1) % statuses.length;
                
                goal.status = statuses[nextIndex];
                if (goal.status === 'completed') {
                    goal.dateCompleted = new Date().toISOString();
                } else {
                    delete goal.dateCompleted;
                }
                
                markDirty();
                renderGoals();
            };

            const editGoal = (goalId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                
                const goal = client.goals.find(g => g.id === goalId);
                if (!goal) return;
                
                const newTitle = prompt("Edit goal title:", goal.title);
                if (newTitle && newTitle.trim() && newTitle.trim() !== goal.title) {
                    goal.title = newTitle.trim();
                    markDirty();
                    renderGoals();
                }
            };

            const editGoalTimeline = (goalId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                const goal = client.goals.find(g => g.id === goalId);
                if (!goal) return;

                const response = prompt('Goal timeline (months):', String(goal.timelineMonths || 12));
                if (response === null) return;
                const months = Math.max(1, Math.min(36, parseInt(response, 10) || 12));
                goal.timelineMonths = months;
                markDirty();
                renderGoals();
            };

            const editObjective = (goalId, objectiveId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                const goal = client.goals.find(g => g.id === goalId);
                if (!goal) return;
                const objective = goal.objectives.find(o => o.id === objectiveId);
                if (!objective) return;

                const response = prompt('Edit objective:', objective.text);
                if (response && response.trim()) {
                    objective.text = response.trim();
                    markDirty();
                    renderGoals();
                }
            };

            const editObjectiveTimeline = (goalId, objectiveId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                const goal = client.goals.find(g => g.id === goalId);
                if (!goal) return;
                const objective = goal.objectives.find(o => o.id === objectiveId);
                if (!objective) return;

                const response = prompt('Objective timeline (months):', String(objective.timelineMonths || 3));
                if (response === null) return;
                objective.timelineMonths = Math.max(1, Math.min(36, parseInt(response, 10) || 3));
                markDirty();
                renderGoals();
            };

            const addClient = () => {
                const name = prompt("Enter new client's name:");
                if (!name || !name.trim()) return;
                const newClient = {
                    id: crypto.randomUUID(),
                    name: name.trim(),
                    persistentNotes: '',
                    persistentInstructions: '',
                    appointments: [],
                    intakeSessions: [],
                    notes: [],
                    goals: [],
                    goalGenerationLens: {
                        modalities: [...DEFAULT_GUIDING_MODALITIES],
                        other: ''
                    }
                };
                data.clients.push(newClient);
                selectClient(newClient.id);
                markDirty();
            };

            const addAppointment = () => {
                const client = findClient(selectedClientId);
                if (!client) return;
                const date = appointmentDateInput.value;
                if (!date) {
                    alert('Please select a date for the appointment.');
                    return;
                }
                const dateObj = new Date(date);
                const utcDate = new Date(dateObj.getUTCFullYear(), dateObj.getUTCMonth(), dateObj.getUTCDate());

                const newAppointment = {
                    id: crypto.randomUUID(),
                    date: utcDate.toISOString(),
                    sessionInfo: '',
                    sessionInstructions: '',
                    selectedInterventions: [],
                    startTime: null,
                    endTime: null,
                    soap: { s: '', o: '', a: '', p: '' }
                };
                client.appointments.push(newAppointment);
                selectAppointment(newAppointment.id);
                markDirty();
            };

            const addNote = () => {
                const client = findClient(selectedClientId);
                if (!client) return;

                const name = noteNameInput.value.trim();
                if (!name) {
                    alert('Please enter a note name.');
                    return;
                }

                if (!Array.isArray(client.notes)) client.notes = [];
                const newNote = {
                    id: crypto.randomUUID(),
                    name,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };
                client.notes.push(newNote);
                noteNameInput.value = '';
                selectNote(newNote.id);
                markDirty();
            };

            const addIntakeSession = () => {
                const client = findClient(selectedClientId);
                if (!client) return;

                if (!Array.isArray(client.intakeSessions)) client.intakeSessions = [];
                const newIntakeSession = {
                    id: crypto.randomUUID(),
                    createdAt: new Date().toISOString(),
                    fields: {}
                };

                client.intakeSessions.push(newIntakeSession);
                selectIntakeSession(newIntakeSession.id);
                markDirty();
            };

            const renameSelectedNote = () => {
                const client = findClient(selectedClientId);
                const note = findNote(client, selectedNoteId);
                if (!note) {
                    alert('Select a note to rename.');
                    return;
                }

                const proposedName = noteNameInput.value.trim();
                const newName = proposedName || prompt('Rename note:', note.name);
                if (!newName || !newName.trim()) return;

                note.name = newName.trim();
                note.updatedAt = new Date().toISOString();
                noteNameInput.value = note.name;
                markDirty();
                fullRender();
            };
            
            clientListEl.addEventListener('click', (e) => {
                const clientItem = e.target.closest('.client-item');
                if (!clientItem) return;

                const clientId = clientItem.dataset.clientId;

                if (e.target.classList.contains('delete-btn')) {
                     const client = findClient(clientId);
                     if (confirm(`Are you sure you want to delete ${client.name}?`)) {
                        const clientIndex = data.clients.findIndex(c => c.id === clientId);
                        if (clientIndex === -1) return;
                        const [removedClient] = data.clients.splice(clientIndex, 1);
                        if (removedClient.appointments) {
                             deletedItems.appointments.push(...removedClient.appointments.map(a => ({...a, clientId})));
                        }
                        deletedItems.clients.push(removedClient);
                        if (selectedClientId === clientId) {
                            selectedClientId = null;
                            selectedAppointmentId = null;
                            selectedNoteId = null;
                            selectedIntakeId = null;
                        }
                        markDirty();
                        fullRender();
                     }
                } else if (e.target.classList.contains('archive-btn')) {
                    const clientIndex = data.clients.findIndex(c => c.id === clientId);
                    if (clientIndex === -1) return;
                    const [client] = data.clients.splice(clientIndex, 1);
                    if (!data.archivedClients) data.archivedClients = [];
                    data.archivedClients.push(client);
                    if (selectedClientId === clientId) {
                        selectedClientId = null;
                        selectedAppointmentId = null;
                        selectedNoteId = null;
                        selectedIntakeId = null;
                    }
                    markDirty();
                    fullRender();
                } else if (e.target.classList.contains('edit-btn')) {
                    const client = findClient(clientId);
                    if (!client) return;
                    const newName = prompt(`Enter new name for ${client.name}:`, client.name);
                    if (newName && newName.trim() && newName.trim() !== client.name) {
                        client.name = newName.trim();
                        markDirty();
                        fullRender();
                    }
                } else {
                    selectClient(clientId);
                }
            });

            // --- Drag and Drop Client Reordering ---
            let draggedClientId = null;
            const closestClientItem = (eventTarget) =>
                eventTarget instanceof Element ? eventTarget.closest('.client-item') : null;

            clientListEl.addEventListener('dragstart', (e) => {
                const clientItem = closestClientItem(e.target);
                if (clientItem) {
                    draggedClientId = clientItem.dataset.clientId;
                    if (e.dataTransfer) {
                        e.dataTransfer.effectAllowed = 'move';
                        e.dataTransfer.setData('text/plain', draggedClientId || '');
                    }
                    // Add a class for visual feedback
                    setTimeout(() => clientItem.classList.add('dragging'), 0);
                }
            });

            clientListEl.addEventListener('dragend', (e) => {
                const clientItem = closestClientItem(e.target);
                if (clientItem) {
                    clientItem.classList.remove('dragging');
                }
                draggedClientId = null;
            });

            clientListEl.addEventListener('dragenter', (e) => {
                e.preventDefault();
            });

            clientListEl.addEventListener('dragover', (e) => {
                e.preventDefault(); // Necessary to allow dropping
                if (e.dataTransfer) {
                    e.dataTransfer.dropEffect = 'move';
                }
                const targetItem = closestClientItem(e.target);
                if (targetItem && targetItem.dataset.clientId !== draggedClientId) {
                    // This is where you could add a visual indicator if desired
                }
            });

            clientListEl.addEventListener('drop', (e) => {
                e.preventDefault();
                const targetItem = closestClientItem(e.target);
                const sourceId = draggedClientId || e.dataTransfer?.getData('text/plain');
                if (targetItem && sourceId) {
                    const targetId = targetItem.dataset.clientId;
                    
                    const draggedIndex = data.clients.findIndex(c => c.id === sourceId);
                    const targetIndex = data.clients.findIndex(c => c.id === targetId);

                    if (draggedIndex > -1 && targetIndex > -1) {
                        // Remove the dragged item
                        const [draggedItem] = data.clients.splice(draggedIndex, 1);
                        // Insert it at the target's position
                        const insertIndex = draggedIndex < targetIndex ? targetIndex - 1 : targetIndex;
                        data.clients.splice(insertIndex, 0, draggedItem);
                        
                        markDirty();
                        renderClients(); // Re-render to reflect the new order
                    }
                }
                draggedClientId = null;
            });

            appointmentListEl.addEventListener('click', (e) => {
                 const appointmentItem = e.target.closest('.appointment-item');
                 const intakeItem = e.target.closest('.intake-item');
                 const noteItem = e.target.closest('.note-item');
                 if (!appointmentItem && !noteItem && !intakeItem) {
                     selectedAppointmentId = null;
                     selectedNoteId = null;
                     selectedIntakeId = null;
                     fullRender();
                     return;
                 }

                 if (intakeItem) {
                    const intakeId = intakeItem.dataset.intakeId;
                    const client = findClient(selectedClientId);
                    if (!client) return;

                    if (e.target.classList.contains('delete-btn')) {
                        const intakeIndex = (client.intakeSessions || []).findIndex(i => i.id === intakeId);
                        if (intakeIndex > -1 && confirm('Delete this intake session?')) {
                            client.intakeSessions.splice(intakeIndex, 1);
                            if (selectedIntakeId === intakeId) selectedIntakeId = null;
                            markDirty();
                            fullRender();
                        }
                        return;
                    }

                    selectIntakeSession(intakeId);
                    return;
                 }

                 if (noteItem) {
                    const noteId = noteItem.dataset.noteId;
                    const client = findClient(selectedClientId);
                    if (!client) return;

                    if (e.target.classList.contains('delete-btn')) {
                        const noteIndex = (client.notes || []).findIndex(n => n.id === noteId);
                        if (noteIndex > -1 && confirm('Delete this note?')) {
                            const [removedNote] = client.notes.splice(noteIndex, 1);
                            deletedItems.notes.push({ ...removedNote, clientId: client.id });
                            if (selectedNoteId === noteId) selectedNoteId = null;
                            markDirty();
                            fullRender();
                        }
                        return;
                    }

                    if (e.target.classList.contains('edit-btn')) {
                        const note = findNote(client, noteId);
                        if (!note) return;
                        const newName = prompt('Rename note:', note.name);
                        if (newName && newName.trim() && newName.trim() !== note.name) {
                            note.name = newName.trim();
                            note.updatedAt = new Date().toISOString();
                            noteNameInput.value = note.name;
                            markDirty();
                            fullRender();
                        }
                        return;
                    }

                    selectNote(noteId);
                    const selectedNote = findNote(client, noteId);
                    noteNameInput.value = selectedNote?.name || '';
                    return;
                 }

                 const appointmentId = appointmentItem.dataset.appointmentId;
                 
                 if (e.target.classList.contains('delete-btn')) {
                    const client = findClient(selectedClientId);
                    if (!client) return;
                    const apptIndex = client.appointments.findIndex(a => a.id === appointmentId);
                    if (apptIndex > -1) {
                        const [appt] = client.appointments.splice(apptIndex, 1);
                        deletedItems.appointments.push({ ...appt, clientId: client.id });
                        if (selectedAppointmentId === appointmentId) {
                            selectedAppointmentId = null;
                        }
                        markDirty();
                        fullRender();
                    }
                 } else {
                     selectAppointment(appointmentId);
                 }
            });
            
            updateAppointmentDateBtn.addEventListener('click', () => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                const newDateStr = appointmentDateInput.value;

                if (client && appointment && newDateStr) {
                    const dateObj = new Date(newDateStr);
                    const utcDate = new Date(dateObj.getUTCFullYear(), dateObj.getUTCMonth(), dateObj.getUTCDate());
                    appointment.date = utcDate.toISOString();
                    markDirty();
                    renderAppointments(); // Just re-render appointments to see the change
                    alert('Appointment date updated.');
                } else {
                    alert('Could not update date. Ensure a client, appointment, and date are selected.');
                }
            });

            deletedClientsListEl.addEventListener('click', e => {
                if (e.target.classList.contains('restore-btn')) {
                    const id = e.target.dataset.id;
                    const clientIndex = deletedItems.clients.findIndex(c => c.id === id);
                    if (clientIndex === -1) return;
                    const [client] = deletedItems.clients.splice(clientIndex, 1);
                    data.clients.push(client);
                    markDirty();
                    fullRender();
                }
            });

            archivedClientsListEl.addEventListener('click', e => {
                if (e.target.classList.contains('restore-btn')) {
                    const id = e.target.dataset.id;
                    if (!data.archivedClients) return;
                    const clientIndex = data.archivedClients.findIndex(c => c.id === id);
                    if (clientIndex === -1) return;
                    const [client] = data.archivedClients.splice(clientIndex, 1);
                    data.clients.push(client);
                    markDirty();
                    fullRender();
                }
            });

            deletedAppointmentsListEl.addEventListener('click', e => {
                 if (e.target.classList.contains('restore-btn')) {
                    const id = e.target.dataset.id;
                    const apptIndex = deletedItems.appointments.findIndex(a => a.id === id);
                    if (apptIndex === -1) return;

                    const [appt] = deletedItems.appointments.splice(apptIndex, 1);
                    const client = findClient(appt.clientId);
                    if (client) {
                        if (!client.appointments) client.appointments = [];
                        client.appointments.push(appt);
                        markDirty();
                        fullRender();
                    } else {
                        deletedItems.appointments.push(appt);
                        alert('Cannot restore. Client not found.');
                    }
                 }
            });
            
            clearDeletedClientsBtn.addEventListener('click', () => {
                if(confirm('Permanently delete all recently deleted clients?')) {
                    deletedItems.clients = [];
                    markDirty();
                    fullRender();
                }
            });
            clearDeletedAppointmentsBtn.addEventListener('click', () => {
                 if(confirm('Permanently delete all recently deleted appointments?')) {
                    deletedItems.appointments = [];
                    markDirty();
                    fullRender();
                }
            });
            
            persistentNotesEl.addEventListener('input', () => {
                 const client = findClient(selectedClientId);
                 if (client) {
                     client.persistentNotes = persistentNotesEl.value;
                     markDirty();
                 }
            });

            const autoResizeTextarea = (el) => {
                // Only resize if the user hasn't manually resized it.
                // We check if the style.height is not set or is 'auto'.
                if (!el.style.height || el.style.height === 'auto') {
                    el.style.height = 'auto';
                    el.style.height = el.scrollHeight + 'px';
                }
            };

            // --- Generic Bullet Point Handlers ---
            const formatBulletPoints = (text) => {
                // Split text into individual bullet points and ensure each is on its own line
                let content = text.trim();
                if (!content) return '';
                
                // Replace any bullet points that are not at the start of a line
                content = content.replace(/([^\n])\s*‚Ä¢\s*/g, '$1\n‚Ä¢ ');
                
                // Split into lines and process each one
                let lines = content.split('\n');
                let newLines = lines.map(line => {
                    let trimmedLine = line.trim();
                    if (trimmedLine.length > 0) {
                        if (!trimmedLine.startsWith('‚Ä¢')) {
                            return '‚Ä¢ ' + trimmedLine;
                        } else {
                            // Ensure proper spacing after bullet
                            return trimmedLine.replace(/^‚Ä¢\s*/, '‚Ä¢ ');
                        }
                    }
                    return line; // Keep empty lines as-is
                });
                
                // Filter out consecutive empty lines but keep single empty lines
                let result = [];
                let lastWasEmpty = false;
                for (let line of newLines) {
                    let isEmpty = line.trim().length === 0;
                    if (!isEmpty || !lastWasEmpty) {
                        result.push(line);
                    }
                    lastWasEmpty = isEmpty;
                }
                
                return result.join('\n');
            };

            const handleBulletedInput = (e, saveDataCallback) => {
                const textarea = e.target;

                const shouldAutoResize = textarea.id !== 'sessionInfo';
                if (shouldAutoResize) {
                    textarea.style.height = 'auto';
                }
                
                // If textarea is empty or doesn't start with a bullet, add one
                if (textarea.value.length > 0 && !textarea.value.startsWith('‚Ä¢')) {
                    const cursorPos = textarea.selectionStart;
                    textarea.value = '‚Ä¢ ' + textarea.value;
                    textarea.selectionStart = textarea.selectionEnd = cursorPos + 2;
                }
                
                if (shouldAutoResize) {
                    autoResizeTextarea(textarea);
                }

                // Save changes using the provided callback
                saveDataCallback(textarea);
            };
            
            const handleBulletedKeyDown = (e) => {
                const textarea = e.target;
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const text = textarea.value;

                if (e.key === 'Enter') {
                    e.preventDefault();
                    
                    const currentLineStart = text.lastIndexOf('\n', start - 1) + 1;
                    const currentLine = text.substring(currentLineStart, start);
                    const restOfLine = text.substring(start, text.indexOf('\n', start) === -1 ? text.length : text.indexOf('\n', start));

                    // Check if current line is just bullet with optional spaces
                    const isJustBullet = currentLine.match(/^‚Ä¢\s*$/);
                    
                    // NEW: Check if cursor is right after bullet+space with content following
                    const hasBulletAndSpace = currentLine.match(/^‚Ä¢\s+$/);
                    const hasContentAfter = restOfLine.trim() !== '';

                    if (isJustBullet && !hasContentAfter) {
                        // Empty bullet point line with nothing after - remove it
                        textarea.value = text.substring(0, currentLineStart) + text.substring(end);
                        textarea.selectionStart = textarea.selectionEnd = currentLineStart;
                    } else if (currentLineStart === 0 && currentLine.trim() === '') {
                        // At very beginning with no content - just add bullet
                        textarea.value = '‚Ä¢ ' + text.substring(end);
                        textarea.selectionStart = textarea.selectionEnd = 2;
                    } else if (hasBulletAndSpace && hasContentAfter) {
                        // User is at "‚Ä¢ |content" - insert new bullet above
                        textarea.value = text.substring(0, currentLineStart) + '‚Ä¢ \n' + text.substring(currentLineStart);
                        textarea.selectionStart = textarea.selectionEnd = currentLineStart + 3;
                    } else {
                        // Normal case - create new line with bullet point
                        textarea.value = text.substring(0, start) + '\n‚Ä¢ ' + text.substring(end);
                        textarea.selectionStart = textarea.selectionEnd = start + 3;
                    }
                    
                    textarea.dispatchEvent(new Event('input', { bubbles: true }));
                    return;
                }

                if (e.key === 'Backspace' && start === end) {
                    const currentLineStart = text.lastIndexOf('\n', start - 1) + 1;
                    const lineText = text.substring(currentLineStart, start);
                    
                    if (lineText.trim() === '‚Ä¢' && start > 0) {
                        e.preventDefault();
                        const prevLineEnd = currentLineStart > 0 ? currentLineStart - 1 : 0;
                        textarea.value = text.substring(0, prevLineEnd) + text.substring(start);
                        textarea.selectionStart = textarea.selectionEnd = prevLineEnd;
                        textarea.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                }
            };

            // --- Specific Save Callbacks ---
            const saveSessionInfo = (textarea) => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                const note = findNote(client, selectedNoteId);
                if (appointment) {
                    appointment.sessionInfo = textarea.value;
                    delete appointment.auditCheck;
                    markDirty();
                } else if (note) {
                    note.sessionInfo = textarea.value;
                    note.updatedAt = new Date().toISOString();
                    markDirty();
                }
                generateNoteBtn.disabled = !appointment || !hasAppointmentGenerationInput(appointment);
            };

            const saveSoapNote = (textarea) => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (appointment) {
                    if (!appointment.soap) appointment.soap = {s:'', o:'', a:'', p:''};
                    
                    if (textarea.id === 'interventions') {
                        appointment.soap.interventions = textarea.value;
                    } else {
                        const key = textarea.id.slice(-1).toLowerCase();
                        appointment.soap[key] = textarea.value;
                    }
                    delete appointment.auditCheck;
                    markDirty();
                }
            };

            // --- Attach Bullet Point Handlers ---
            sessionInfoEl.addEventListener('input', (e) => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (appointment) {
                    handleBulletedInput(e, saveSessionInfo);
                } else {
                    saveSessionInfo(e.target);
                }
            });
            sessionInfoEl.addEventListener('keydown', (e) => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (appointment) {
                    handleBulletedKeyDown(e);
                }
            });
            sessionInfoEl.addEventListener('focus', (e) => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (!appointment) return;
                const textarea = e.target;
                if (textarea.value.length === 0) {
                    textarea.value = '‚Ä¢ ';
                    textarea.selectionStart = textarea.selectionEnd = 2;
                }
            });

            auditProofSymptomsEl.addEventListener('input', () => saveAuditProofingField('symptoms', auditProofSymptomsEl.value));
            auditProofFunctionalEl.addEventListener('input', () => saveAuditProofingField('functionalImpact', auditProofFunctionalEl.value));
            auditProofProgressEl.addEventListener('input', () => saveAuditProofingField('progressResponse', auditProofProgressEl.value));
            auditProofGoalEl.addEventListener('input', () => saveAuditProofingField('goalAlignment', auditProofGoalEl.value));
            auditProofNecessityEl.addEventListener('input', () => saveAuditProofingField('medicalNecessity', auditProofNecessityEl.value));

            guidingModalitiesListEl.addEventListener('change', (e) => {
                if (!e.target.matches('.modality-select')) return;
                saveGuidingModalities();
            });
            guidingModalitiesListEl.addEventListener('click', (e) => {
                if (e.target.classList.contains('add-modality-btn')) {
                    goalGeneratorModalities.push(DEFAULT_GUIDING_MODALITIES[0]);
                    renderGuidingModalities();
                    return;
                }
                if (e.target.classList.contains('remove-modality-btn')) {
                    if (goalGeneratorModalities.length <= 1) return;
                    const row = e.target.closest('.modality-row');
                    const index = row ? parseInt(row.dataset.modalityIndex, 10) : -1;
                    if (index >= 0) {
                        goalGeneratorModalities.splice(index, 1);
                        if (!goalGeneratorModalities.includes('Other (Specify)')) {
                            goalGeneratorModalityOther = '';
                        }
                        renderGuidingModalities();
                    }
                }
            });
            guidingModalityOtherEl.addEventListener('input', () => {
                goalGeneratorModalityOther = guidingModalityOtherEl.value;
                saveClientGoalGenerationLens();
            });

            intakeFieldsContainerEl.addEventListener('input', (e) => {
                if (!e.target.matches('.intake-field-input')) return;

                const client = findClient(selectedClientId);
                const intakeSession = findIntakeSession(client, selectedIntakeId);
                if (!intakeSession) return;

                if (!intakeSession.fields || typeof intakeSession.fields !== 'object') {
                    intakeSession.fields = {};
                }

                intakeSession.fields[e.target.dataset.intakeKey] = e.target.value;
                markDirty();
            });

            soapContentEl.addEventListener('input', (e) => {
                if (e.target.matches('.soap-textarea')) {
                    handleBulletedInput(e, saveSoapNote);
                }
            });
            soapContentEl.addEventListener('keydown', (e) => {
                if (e.target.matches('.soap-textarea')) {
                    handleBulletedKeyDown(e);
                }
            });
            soapContentEl.addEventListener('focus', (e) => {
                if (e.target.matches('.soap-textarea')) {
                    const textarea = e.target;
                    if (textarea.value.length === 0) {
                        textarea.value = '‚Ä¢ ';
                        textarea.selectionStart = textarea.selectionEnd = 2;
                    }
                }
            });
            soapContentEl.addEventListener('click', (e) => {
                 if (e.target.id === 'runSoapAuditBtn') {
                     const client = findClient(selectedClientId);
                     const appointment = findAppointment(client, selectedAppointmentId);
                     if (!client || !appointment) {
                        alert('Select an appointment before running an audit check.');
                        return;
                     }
                     appointment.auditCheck = runSoapAuditCheck(client, appointment);
                     markDirty();
                     renderSoap();
                     return;
                 }
                 if (e.target.id === 'selectInterventionsBtn') {
                     const client = findClient(selectedClientId);
                     const appointment = findAppointment(client, selectedAppointmentId);
                     if (!appointment) return;
                     renderInterventionPicker();
                     interventionPickerModal.classList.remove('hidden');
                     return;
                 }
                 if (e.target.classList.contains('copy-btn')) {
                     const targetId = e.target.dataset.target;
                     const textarea = document.getElementById(targetId);
                     if (!textarea) return;
                     navigator.clipboard.writeText(textarea.value).then(() => {
                         const originalText = e.target.textContent;
                         e.target.textContent = 'Copied!';
                         setTimeout(() => { e.target.textContent = originalText; }, 2000);
                     }).catch(err => {
                         console.error('Failed to copy text: ', err);
                         alert('Could not copy text to clipboard.');
                     });
                 }
                 if (e.target.classList.contains('suggestion-accept')) {
                    handleSuggestion(e.target, true);
                 }
                 if (e.target.classList.contains('suggestion-accept-replace')) {
                    handleSuggestion(e.target, true);
                 }
                 if (e.target.classList.contains('suggestion-decline')) {
                    handleSuggestion(e.target, false);
                 }
            });

            const handleSuggestion = (button, isAccepted) => {
                const suggestionBox = button.closest('.suggestion-box');
                const type = suggestionBox.dataset.suggestionType;
                const index = parseInt(suggestionBox.dataset.suggestionIndex, 10);
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);

                if (!appointment || !appointment.soap) return;

                const soapPanelContent = document.getElementById('soapContent');
                const scrollTop = soapPanelContent.scrollTop;

                const suggestionKey = `${type}_suggestion`;
                const suggestionData = appointment.soap[suggestionKey]?.[index];
                if (!suggestionData) return;

                const textarea = document.getElementById(`soap${type.toUpperCase()}`);
                const isReplacement = typeof suggestionData === 'object' && suggestionData.original && suggestionData.suggested;
                let textToAdd = '';

                if (isAccepted) {
                    if (isReplacement) {
                        // User clicked "Use Suggestion"
                        textToAdd = suggestionData.suggested;
                    } else {
                        // User clicked "Accept" for a new suggestion (string)
                        textToAdd = suggestionData;
                    }
                } else { // Declined
                    if (isReplacement) {
                        // User clicked "Keep Original"
                        textToAdd = suggestionData.original;
                    }
                    // If it's a new suggestion (string) and user clicks decline, textToAdd remains empty, which is correct.
                }

                if (textToAdd) {
                    const currentText = textarea.value.trim();
                    // Ensure the text to add is a proper bullet point.
                    const newText = `‚Ä¢ ${textToAdd.replace(/^‚Ä¢\s*/, '')}`;

                    if (currentText.length === 0 || currentText === '‚Ä¢') {
                        textarea.value = newText;
                    } else {
                        textarea.value = `${currentText}\n${newText}`;
                    }
                    
                    // Manually update the data model since we're not dispatching the 'input' event before re-rendering
                    const key = textarea.id.slice(-1).toLowerCase();
                    appointment.soap[key] = textarea.value;
                }

                // Remove the suggestion that was just handled.
                if (Array.isArray(appointment.soap[suggestionKey])) {
                    appointment.soap[suggestionKey].splice(index, 1);
                }
                
                markDirty();
                renderSoap(); 

                // Restore scroll position
                soapPanelContent.scrollTop = scrollTop;
            };


            const systemPrompt = `You are a helpful assistant for a therapist or clinician. Your primary function is to accurately categorize user-provided session notes into a structured SOAP note format.

**Your Task:**
Analyze the "Session Information" text provided by the user. Categorize every piece of information into one of the four SOAP sections based on the strict definitions below.

- **Subjective (S):** Information reported by the client (e.g., feelings, goals, history). This is for the client's voice and perspective.
  - **CRITICAL:** Each bullet point should be self-sufficient, without relying on other bullet points for context. It should convey a complete thought.
  
- **Objective (O):** Everything that *happens* in the therapy session. This includes all therapeutic interventions, actions taken, connections made, and reflections or psychoeducation provided by the writer. **Any sentence that describes the writer's actions or speech belongs here.** 
  - **CRITICAL:** Each bullet point should be self-sufficient, without relying on other bullet points for context. It should convey a complete thought.
  - **CRITICAL:** Objective content must contain an intervention connected to session content. Do not include observations without corresponding actions or therapeutic moves.
  - **GOLDEN THREAD:** When treatment goals are provided, weave connections between interventions and specific treatment goals/objectives in this section. For example: "Writer provided CBT techniques to address client's anxiety management goal" or "Explored coping strategies related to client's objective of improving emotional regulation." Only make these connections when they are clearly apparent from the session content - don't force connections that aren't naturally there.
    - **REQUIRED WHEN PROVIDED:** If interventions are pre-selected from the Intervention Bank and there is an active objective match, include explicit linkage phrasing such as: "Writer [intervention], addressing treatment plan objective of [objective]."

- **Assessment (A):** The writer's clinical analysis and observations. This includes notes on progress towards goals and direct observations of the client's state (e.g., "client appeared tired," "client's affect was bright"). This section should NOT contain actions or speech from the session.
  - **CRITICAL:** Each bullet point should be self-sufficient, without relying on other bullet points for context. It should convey a complete thought.
  
- **Plan (P):** The course of action for future sessions. This includes topics to be addressed, homework, and any modifications to the treatment plan.
  - **CRITICAL:** Each bullet point should be self-sufficient, without relying on other bullet points for context. It should convey a complete thought.
  
- **Interventions (I):** Identify specific clinical techniques and modalities used during the session. You have more freedom here to interpret the session notes and list the relevant interventions, even if the exact keyword isn't used.

**NEW: Suggestions**
- In addition to the main SOAP content, you will provide clinical language suggestions for all four sections when appropriate stronger clinical terminology is available.
- These suggestions should improve clinical precision and professional language without adding new information.
- The suggestions should be returned in four JSON keys: \`s_suggestion\`, \`o_suggestion\`, \`a_suggestion\`, and \`p_suggestion\`.
- For any section (S, O, A, P), the value for its suggestion key (e.g., \`s_suggestion\`) MUST be an array that can contain three types of items:
    1.  A JSON object for suggesting a *revision* to text you've already placed in the corresponding section: \`{"original": "[the exact original text to be replaced]", "suggested": "[the new suggested text]"}\`. The "original" text must be a direct, verbatim quote of one of the bullet points from the corresponding section you generated.
    2.  A simple string for suggesting a *new idea* not already in that section. Example: "Consider exploring coping mechanisms for social anxiety."
    3.  A standalone interpretive insight (no prefix text required) that infers what likely happened in session, assuming interventions when needed and leaning on Narrative/Psychodynamic modalities. These insights do not reference an "original" bullet and should read like complete clinical statements (e.g., "Writer reframed Ct's trauma narrative using Narrative exposure techniques to reinforce agency.").
- A mixed example for an \`a_suggestion\` key would look like: \`[{"original": "‚Ä¢ Ct is tired.", "suggested": "‚Ä¢ Ct presented with fatigue."}, "Recommend weekly check-ins.", "Writer linked Ct's family narrative to psychodynamic themes of loss, highlighting unresolved grief patterns."]\`
- Objective (\`o_suggestion\`) MUST include 7‚Äì10 interpretive insights of this type. Plan (\`p_suggestion\`) MUST include exactly 3 interpretive insights. Other sections may include or omit these insights as appropriate.
- If you have no suggestion for any section, return an empty array \`[]\` for that key.

**CRITICAL INSTRUCTIONS:**
- **THE GOLDEN RULE:** ONLY use information explicitly provided in the "Session Information" text. Do not use any information from the example output below, which is for formatting reference only.
- **MODALITY LENS HANDLING:** When User Input includes a "Client Modality Lens (Default)" section, use it as a default conceptual lens only. If User Input includes explicit interventions/techniques that indicate a different modality, preserve those interventions as written and do not force them into the default modality lens.
- **INSTRUCTION PRECEDENCE:** When both Persistent Instructions and Session Instructions are provided, Session Instructions override Persistent Instructions for this generated note.
- **PRESERVE SHORTHAND:** Do not expand abbreviations or shorthand. Keep "Ct" as "Ct" (not "Client"), "IBS" as "IBS" (not "Irritable Bowel Syndrome"), etc. Do not add expanded forms in parentheses.
- **CLINICIAN REFERENCE:** Always refer to the clinician as "Writer" (not "the Writer", "the clinician", "therapist", or any other variation).
- **Example of PERFECT Output (FOR FORMATTING ONLY):**
{"s":"‚Ä¢ Ct said they felt bad.","o":"‚Ä¢ Writer talked about coping.","a":"‚Ä¢ Ct displays affect congruent with mood.","p":"‚Ä¢ Continue to explore themes of loss.","i":"‚Ä¢ Psychoeducation\\n‚Ä¢ Cognitive Restructuring","s_suggestion":[{"original":"‚Ä¢ Ct said they felt bad.","suggested":"‚Ä¢ Ct reported experiencing significant distress."}],"o_suggestion":[{"original":"‚Ä¢ Writer talked about coping.","suggested":"‚Ä¢ Writer provided psychoeducation on coping strategies."}],"a_suggestion":["Client appears to be making progress toward treatment goals related to anxiety."],"p_suggestion":["Continue to utilize CBT techniques to challenge cognitive distortions in the next session."]};
            `;

            const generateSoapNote = async () => {
                if (selectedNoteId || selectedIntakeId) {
                    alert('SOAP note generation is only available for appointments, not Notes or Intake Sessions.');
                    return;
                }
                if (!selectedModel) {
                    alert('Please connect to a provider and select a model in Settings.');
                    return;
                }
                if (apiProvider === 'openwebui') {
                    await generateSoapNoteWithOpenWebUI();
                } else if (apiProvider === 'gemini') {
                    await generateSoapNoteWithGemini();
                } else if (apiProvider === 'vertex') {
                    await generateSoapNoteWithVertex();
                } else if (apiProvider === 'openai') {
                    await generateSoapNoteWithOpenAI();
                } else {
                    alert('Invalid API provider selected.');
                }
            };
            
            const processAndStoreSoapData = (soapData, appointment) => {
                 if (!appointment.soap) appointment.soap = {};
                  delete appointment.auditCheck;

                 // Process and store AI-generated interventions
                 appointment.soap.interventions = soapData.i ? formatBulletPoints(soapData.i) : 'No interventions identified.';

                 ['s', 'o', 'a', 'p'].forEach(key => {
                     const suggestionKey = `${key}_suggestion`;
                     const suggestions = soapData[suggestionKey] || [];
                     const fullText = soapData[key] ? formatBulletPoints(soapData[key]) : '';

                     // FIXED: Only add content that's NOT part of suggestions
                     // All suggestion content (both replacements and new additions) should be presented for user approval
                     if (suggestions.length === 0) {
                         // No suggestions - use all the generated content
                         appointment.soap[key] = fullText;
                     } else {
                         // There are suggestions - only include content that's NOT in any suggestions
                         const allSuggestionTexts = suggestions.map(s => {
                             if (typeof s === 'object' && s.original) {
                                 // For replacement suggestions, withhold the original text
                                 return s.original.replace(/^‚Ä¢\s*/, '').trim();
                             } else {
                                 // For new suggestions, withhold the suggestion text itself
                                 return s.replace(/^‚Ä¢\s*/, '').trim();
                             }
                         });

                         // Split the full generated text into bullet points
                         const allBulletPoints = fullText.split('\n').map(line => line.trim()).filter(line => line !== '');

                         // Only include bullet points that are NOT part of any suggestion
                         const immediateTextPoints = allBulletPoints.filter(point => {
                             const trimmedPoint = point.replace(/^‚Ä¢\s*/, '').trim();
                             return !allSuggestionTexts.some(suggestionText => suggestionText === trimmedPoint);
                         });

                         appointment.soap[key] = immediateTextPoints.join('\n');
                     }
                     
                     // Always store the full list of suggestions for user approval
                     appointment.soap[suggestionKey] = suggestions;
                 });
             };


            const generateSoapNoteWithGemini = async () => {
                if (!selectedModel || !geminiApiKey) {
                    alert('Please connect to Gemini with an API key and model first.');
                    return;
                }

                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (!client || !appointment || !hasAppointmentGenerationInput(appointment)) {
                    alert('Please select a client and appointment, and enter session information and/or audit-proofing details.');
                    return;
                }

                generateNoteBtn.disabled = true;
                generateNoteBtn.textContent = 'Generating...';

                const treatmentGoalsContext = getTreatmentGoalsContext(client);
                const selectedObjectivesContext = getSelectedObjectivesContext(client);
                const interventionContext = getInterventionContext(appointment);
                const modalityLensContext = getClientSoapModalityContext(client, appointment);
                const appointmentSessionInfo = appointment.sessionInfo || '';
                const instructionsContext = getInstructionsContext(client, appointment);
                const auditProofing = getAuditProofingData(appointment);
                const auditProofingLines = [
                    auditProofing.symptoms ? `  - Symptom Pattern / Severity Context: ${auditProofing.symptoms}` : null,
                    auditProofing.functionalImpact ? `  - Functional Impact: ${auditProofing.functionalImpact}` : null,
                    auditProofing.progressResponse ? `  - Progress / Response to Treatment: ${auditProofing.progressResponse}` : null,
                    auditProofing.goalAlignment ? `  - Treatment Goal Alignment: ${auditProofing.goalAlignment}` : null,
                    auditProofing.medicalNecessity ? `  - Medical Necessity Rationale: ${auditProofing.medicalNecessity}` : null
                ].filter(Boolean);
                const auditProofingContext = auditProofingLines.length > 0
                    ? `\n- **Audit-Proofing:**\n${auditProofingLines.join('\n')}`
                    : '';

                const userPrompt = `
- **Session Information (This Session):**
${appointmentSessionInfo}${treatmentGoalsContext}${selectedObjectivesContext}${interventionContext}${auditProofingContext}${modalityLensContext}${instructionsContext}
`;
                const fullPrompt = `${systemPrompt}\n\n**User Input:**\n${userPrompt}`;

                const payload = {
                    contents: [{
                        parts: [{ text: fullPrompt }]
                    }],
                    generationConfig: {
                        response_mime_type: "application/json",
                    }
                };

                try {
                    const url = `https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent?key=${geminiApiKey}`;
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        const error = new Error(`Gemini API error: ${response.status} - ${errorText}`);
                        error.response = response;
                        throw error;
                    }

                    const result = await response.json();
                    if (!result || !result.candidates || !result.candidates[0].content.parts[0].text) {
                         throw new Error("The Gemini API returned an invalid or empty response.");
                    }

                    let content = result.candidates[0].content.parts[0].text;
                    let soapData = JSON.parse(content);

                    processAndStoreSoapData(soapData, appointment);

                    markDirty();
                    renderSoap();

                } catch (error) {
                    console.error('Gemini SOAP Note Generation Error:', error);
                    alert(`Failed to generate SOAP note with Gemini. Please check your API Key, Model Name, and the console for details.\nError: ${error.message}`);
                } finally {
                    generateNoteBtn.disabled = false;
                    generateNoteBtn.textContent = 'Generate Note';
                }
            };
            
            const generateSoapNoteWithOpenAI = async () => {
                if (!selectedModel || !openaiApiKey) {
                    alert('Please connect to OpenAI with an API key and model first.');
                    return;
                }

                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (!client || !appointment || !hasAppointmentGenerationInput(appointment)) {
                    alert('Please select a client and appointment, and enter session information and/or audit-proofing details.');
                    return;
                }

                generateNoteBtn.disabled = true;
                generateNoteBtn.textContent = 'Generating...';

                const treatmentGoalsContext = getTreatmentGoalsContext(client);
                const selectedObjectivesContext = getSelectedObjectivesContext(client);
                const interventionContext = getInterventionContext(appointment);
                const modalityLensContext = getClientSoapModalityContext(client, appointment);
                const appointmentSessionInfo = appointment.sessionInfo || '';
                const instructionsContext = getInstructionsContext(client, appointment);
                const auditProofing = getAuditProofingData(appointment);
                const auditProofingLines = [
                    auditProofing.symptoms ? `  - Symptom Pattern / Severity Context: ${auditProofing.symptoms}` : null,
                    auditProofing.functionalImpact ? `  - Functional Impact: ${auditProofing.functionalImpact}` : null,
                    auditProofing.progressResponse ? `  - Progress / Response to Treatment: ${auditProofing.progressResponse}` : null,
                    auditProofing.goalAlignment ? `  - Treatment Goal Alignment: ${auditProofing.goalAlignment}` : null,
                    auditProofing.medicalNecessity ? `  - Medical Necessity Rationale: ${auditProofing.medicalNecessity}` : null
                ].filter(Boolean);
                const auditProofingContext = auditProofingLines.length > 0
                    ? `\n- **Audit-Proofing:**\n${auditProofingLines.join('\n')}`
                    : '';

                const userPrompt = `- **Session Information (This Session):**\n${appointmentSessionInfo}${treatmentGoalsContext}${selectedObjectivesContext}${interventionContext}${auditProofingContext}${modalityLensContext}${instructionsContext}`;

                const payload = {
                    model: selectedModel,
                    messages: [
                        { "role": "system", "content": systemPrompt },
                        { "role": "user", "content": userPrompt }
                    ],
                    response_format: { "type": "json_object" }
                };

                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${openaiApiKey}`
                        },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`OpenAI API error: ${response.status} - ${errorData.error.message}`);
                    }

                    const result = await response.json();
                    if (!result || !result.choices || !result.choices[0].message.content) {
                        throw new Error("The OpenAI API returned an invalid or empty response.");
                    }

                    let content = result.choices[0].message.content;
                    let soapData = JSON.parse(content);

                    processAndStoreSoapData(soapData, appointment);

                    markDirty();
                    renderSoap();

                } catch (error) {
                    console.error('OpenAI SOAP Note Generation Error:', error);
                    alert(`Failed to generate SOAP note with OpenAI. Please check your API Key, Model Name, and the console for details.\nError: ${error.message}`);
                } finally {
                    generateNoteBtn.disabled = false;
                    generateNoteBtn.textContent = 'Generate Note';
                }
            };

            const generateSoapNoteWithVertex = async () => {
                if (!selectedModel || !vertexProjectId || !vertexLocation || (!vertexAccessToken && !hasVertexProxy())) {
                    alert('Please connect to Vertex AI with project, location, and either credential or proxy URL first.');
                    return;
                }

                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (!client || !appointment || !hasAppointmentGenerationInput(appointment)) {
                    alert('Please select a client and appointment, and enter session information and/or audit-proofing details.');
                    return;
                }

                generateNoteBtn.disabled = true;
                generateNoteBtn.textContent = 'Generating...';

                const treatmentGoalsContext = getTreatmentGoalsContext(client);
                const selectedObjectivesContext = getSelectedObjectivesContext(client);
                const interventionContext = getInterventionContext(appointment);
                const modalityLensContext = getClientSoapModalityContext(client, appointment);
                const appointmentSessionInfo = appointment.sessionInfo || '';
                const instructionsContext = getInstructionsContext(client, appointment);
                const auditProofing = getAuditProofingData(appointment);
                const auditProofingLines = [
                    auditProofing.symptoms ? `  - Symptom Pattern / Severity Context: ${auditProofing.symptoms}` : null,
                    auditProofing.functionalImpact ? `  - Functional Impact: ${auditProofing.functionalImpact}` : null,
                    auditProofing.progressResponse ? `  - Progress / Response to Treatment: ${auditProofing.progressResponse}` : null,
                    auditProofing.goalAlignment ? `  - Treatment Goal Alignment: ${auditProofing.goalAlignment}` : null,
                    auditProofing.medicalNecessity ? `  - Medical Necessity Rationale: ${auditProofing.medicalNecessity}` : null
                ].filter(Boolean);
                const auditProofingContext = auditProofingLines.length > 0
                    ? `\n- **Audit-Proofing:**\n${auditProofingLines.join('\n')}`
                    : '';

                const userPrompt = `
- **Session Information (This Session):**
${appointmentSessionInfo}${treatmentGoalsContext}${selectedObjectivesContext}${interventionContext}${auditProofingContext}${modalityLensContext}${instructionsContext}
`;
                const fullPrompt = `${systemPrompt}\n\n**User Input:**\n${userPrompt}`;

                const payload = {
                    contents: [{
                        parts: [{ text: fullPrompt }]
                    }],
                    generationConfig: {
                        responseMimeType: 'application/json',
                    }
                };

                try {
                    const result = hasVertexProxy()
                        ? await callVertexProxyGenerate(selectedModel, payload)
                        : await (async () => {
                            const usingApiKey = isLikelyGoogleApiKey(vertexAccessToken);
                            const auth = getVertexAuthConfig(vertexAccessToken);
                            const url = usingApiKey
                                ? `https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent${auth.query}`
                                : `https://${vertexLocation}-aiplatform.googleapis.com/v1/projects/${vertexProjectId}/locations/${vertexLocation}/publishers/google/models/${selectedModel}:generateContent${auth.query}`;
                            const response = await fetch(url, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    ...auth.headers
                                },
                                body: JSON.stringify(payload)
                            });
                            if (!response.ok) {
                                const errorText = await response.text();
                                const error = new Error(`Vertex API error: ${response.status} - ${errorText}`);
                                error.response = response;
                                throw error;
                            }
                            return await response.json();
                        })();

                    if (!result || !result.candidates || !result.candidates[0]?.content?.parts?.[0]?.text) {
                        throw new Error('The Vertex API returned an invalid or empty response.');
                    }

                    const content = result.candidates[0].content.parts[0].text;
                    const soapData = JSON.parse(content);

                    processAndStoreSoapData(soapData, appointment);

                    markDirty();
                    renderSoap();

                } catch (error) {
                    console.error('Vertex SOAP Note Generation Error:', error);
                    alert(`Failed to generate SOAP note with Vertex AI. Check your token, project, location, model, and network connection.\nError: ${error.message}`);
                } finally {
                    generateNoteBtn.disabled = false;
                    generateNoteBtn.textContent = 'Generate Note';
                }
            };

            const generateSoapNoteWithOpenWebUI = async () => {
                if (!selectedModel) {
                    alert('Please connect to your server and select a model first.');
                    return;
                }

                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (!client || !appointment || !hasAppointmentGenerationInput(appointment)) {
                    alert('Please select a client and appointment, and enter session information and/or audit-proofing details.');
                    return;
                }

                generateNoteBtn.disabled = true;
                generateNoteBtn.textContent = 'Generating...';

                const treatmentGoalsContext = getTreatmentGoalsContext(client);
                const selectedObjectivesContext = getSelectedObjectivesContext(client);
                const interventionContext = getInterventionContext(appointment);
                const modalityLensContext = getClientSoapModalityContext(client, appointment);
                const appointmentSessionInfo = appointment.sessionInfo || '';
                const instructionsContext = getInstructionsContext(client, appointment);
                const auditProofing = getAuditProofingData(appointment);
                const auditProofingLines = [
                    auditProofing.symptoms ? `  - Symptom Pattern / Severity Context: ${auditProofing.symptoms}` : null,
                    auditProofing.functionalImpact ? `  - Functional Impact: ${auditProofing.functionalImpact}` : null,
                    auditProofing.progressResponse ? `  - Progress / Response to Treatment: ${auditProofing.progressResponse}` : null,
                    auditProofing.goalAlignment ? `  - Treatment Goal Alignment: ${auditProofing.goalAlignment}` : null,
                    auditProofing.medicalNecessity ? `  - Medical Necessity Rationale: ${auditProofing.medicalNecessity}` : null
                ].filter(Boolean);
                const auditProofingContext = auditProofingLines.length > 0
                    ? `\n- **Audit-Proofing:**\n${auditProofingLines.join('\n')}`
                    : '';

                const userPrompt = `
- **Client Name:** ${client.name}
- **Session Information (This Session):**
${appointmentSessionInfo}${treatmentGoalsContext}${selectedObjectivesContext}${interventionContext}${auditProofingContext}${modalityLensContext}${instructionsContext}`;

                const payload = {
                    model: selectedModel,
                    messages: [
                        { "role": "system", "content": systemPrompt },
                        { "role": "user", "content": userPrompt }
                    ],
                    response_format: { "type": "json_object" },
                    stream: false
                };
                
                try {
                    const headers = new Headers({ 'Content-Type': 'application/json' });
                     if (apiKey) {
                         headers.append('Authorization', `Bearer ${apiKey}`);
                    }
                    const response = await fetch(`${serverAddress}/api/v1/chat/completions`, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(payload),
                        mode: 'cors'
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        const error = new Error(`API error: ${response.status} - ${errorText}`);
                        error.response = response;
                        throw error;
                    }

                    const result = await response.json();
                    if (!result) {
                        throw new Error("The API returned an empty response. Please check the Open WebUI server logs for errors.");
                    }
                    let content = result.choices[0].message.content;
                    let soapData = {};

                    // Aggressive JSON extraction and cleanup
                    try {
                        // Find the first '{' and the last '}' to extract the JSON part.
                        const firstBrace = content.indexOf('{');
                        const lastBrace = content.lastIndexOf('}');
                        if (firstBrace === -1 || lastBrace === -1 || lastBrace < firstBrace) {
                            throw new Error('AI response did not contain a valid JSON object.');
                        }
                        let jsonString = content.substring(firstBrace, lastBrace + 1);
                        
                        // Attempt to parse it. If it fails, it's likely due to malformed content.
                        try {
                            soapData = JSON.parse(jsonString);
                        } catch (e) {
                            console.warn("Initial JSON.parse failed. Attempting to clean and re-parse.", e.message);
                            // This is a more robust fallback for models that fail to escape content correctly.
                            // It performs multiple passes to clean up common issues.
                            
                            // 1. Remove newlines within JSON strings, which is a common error.
                            let cleanedString = jsonString.replace(/:\s*"(.*?)"/gs, (match, group1) => {
                                const singleLineGroup = group1.replace(/\n/g, '\\n').replace(/\r/g, '');
                                return `: "${singleLineGroup}"`;
                            });

                            // 2. Fix unescaped quotes inside values. This is more complex.
                            // We look for a quote that is not preceded by a backslash.
                            cleanedString = cleanedString.replace(/:\s*"(.*?)"/g, (match, group1) => {
                                const fixedGroup = group1.replace(/(?<!\\)"/g, '\\"');
                                return `: "${fixedGroup}"`;
                            });

                            soapData = JSON.parse(cleanedString); // Retry parsing with the cleaned string
                        }

                    } catch (parseError) {
                        console.error("Failed to parse the following JSON string from the AI:", content);
                        throw new Error(`The AI model returned malformed JSON that could not be automatically fixed. Check the browser console for the raw output. Details: ${parseError.message}`);
                    }
                    
                    processAndStoreSoapData(soapData, appointment);
                    
                    markDirty();
                    renderSoap();

                } catch (error) {
                    console.error('SOAP Note Generation Error:', error);
                    let alertMessage = `Failed to generate SOAP note. Please check your connection and the console for details.\nError: ${error.message}`;
                    
                    if (error.response?.status === 401) {
                         alertMessage = `Authentication failed (401 Unauthorized) while trying to generate the note. Please re-check your API Key.`;
                    } else if (error instanceof TypeError && error.message.toLowerCase().includes('failed to fetch')) {
                        alertMessage = `Network Error: Failed to fetch. Check CORS policy on your server.`;
                    }
                    alert(alertMessage);
                } finally {
                    generateNoteBtn.disabled = false;
                    generateNoteBtn.textContent = 'Generate Note';
                }
            };
            
            const connectToServer = async () => {
                apiProvider = apiProviderSelect.value;
                if (apiProvider === 'openwebui') {
                    await connectToOpenWebUI();
                } else if (apiProvider === 'gemini') {
                    await connectToGemini();
                } else if (apiProvider === 'vertex') {
                    await connectToVertex();
                } else if (apiProvider === 'openai') {
                    await connectToOpenAI();
                }
            };
            
            const verifyApiConnection = async () => {
                if (!apiProvider) {
                    alert('Please connect to an API provider first.');
                    return;
                }

                apiStatus.textContent = 'Verifying...';
                apiStatus.style.color = 'orange';

                try {
                    if (apiProvider === 'gemini') {
                        if (!geminiApiKey || !selectedModel) {
                            throw new Error('Gemini API key or model not configured.');
                        }
                        // Test with a simple API call
                        const testUrl = `https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent?key=${geminiApiKey}`;
                        const response = await fetch(testUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{
                                    parts: [{ text: 'Test connection - respond with "OK"' }]
                                }]
                            })
                        });
                        if (!response.ok) {
                            throw new Error(`API test failed: ${response.status}`);
                        }
                        apiStatus.textContent = 'Verified ‚úì';
                        apiStatus.style.color = 'green';
                    } else if (apiProvider === 'vertex') {
                        if (!vertexProjectId || !vertexLocation || (!vertexAccessToken && !hasVertexProxy()) || !selectedModel) {
                            throw new Error('Vertex project/location/credential/model not configured.');
                        }
                        if (hasVertexProxy()) {
                            const proxyUrl = getVertexProxyUrl();
                            const healthResponse = await fetch(`${proxyUrl}/health`);
                            if (!healthResponse.ok) {
                                throw new Error(`Proxy health check failed: ${healthResponse.status}`);
                            }
                            await callVertexProxyGenerate(selectedModel, {
                                contents: [{ parts: [{ text: 'Reply with OK' }] }],
                                generationConfig: { temperature: 0 }
                            });
                            apiStatus.textContent = 'Verified ‚úì';
                            apiStatus.style.color = 'green';
                            return;
                        }
                        const usingApiKey = isLikelyGoogleApiKey(vertexAccessToken);
                        const auth = getVertexAuthConfig(vertexAccessToken);
                        const verifyUrl = usingApiKey
                            ? `https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent${auth.query}`
                            : `https://${vertexLocation}-aiplatform.googleapis.com/v1/projects/${vertexProjectId}/locations/${vertexLocation}/publishers/google/models/${selectedModel}:generateContent${auth.query}`;
                        const response = await fetch(verifyUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                ...auth.headers
                            },
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: 'Reply with OK' }] }],
                                generationConfig: { temperature: 0 }
                            })
                        });
                        if (!response.ok) {
                            const errorText = await response.text();
                            throw new Error(`API test failed: ${response.status} - ${errorText}`);
                        }
                        apiStatus.textContent = 'Verified ‚úì';
                        apiStatus.style.color = 'green';
                    } else if (apiProvider === 'openai') {
                        if (!openaiApiKey || !selectedModel) {
                            throw new Error('OpenAI API key or model not configured.');
                        }
                        const response = await fetch('https://api.openai.com/v1/models/' + selectedModel, {
                            headers: { 'Authorization': `Bearer ${openaiApiKey}` }
                        });
                        if (!response.ok) {
                            throw new Error(`API test failed: ${response.status}`);
                        }
                        apiStatus.textContent = 'Verified ‚úì';
                        apiStatus.style.color = 'green';
                    } else if (apiProvider === 'openwebui') {
                        if (!serverAddress) {
                            throw new Error('Server address not configured.');
                        }
                        const response = await fetch(`${serverAddress}/api/models`);
                        if (!response.ok) {
                            throw new Error(`API test failed: ${response.status}`);
                        }
                        apiStatus.textContent = 'Verified ‚úì';
                        apiStatus.style.color = 'green';
                    }
                } catch (error) {
                    console.error('API verification error:', error);
                    apiStatus.textContent = 'Verification Failed';
                    apiStatus.style.color = 'red';
                    if (
                        apiProvider === 'vertex' &&
                        error &&
                        typeof error.message === 'string' &&
                        (error.message.toLowerCase().includes('load failed') || error.message.toLowerCase().includes('failed to fetch'))
                    ) {
                        alert(`API verification failed: ${error.message}\n\nThis usually means the browser could not complete the network request (often CORS/network policy). Try serving this app over http://localhost and verify outbound access to *.googleapis.com.`);
                    } else {
                        alert(`API verification failed: ${error.message}`);
                    }
                }
            };

            const connectToVertex = async () => {
                const projectId = vertexProjectIdInput.value.trim();
                const location = (vertexLocationInput.value.trim() || 'us-central1');
                const token = vertexAccessTokenInput.value.trim();
                const proxyUrl = getVertexProxyUrl();
                const usingApiKey = isLikelyGoogleApiKey(token);
                const fallbackModels = usingApiKey
                    ? ['gemini-2.0-flash', 'gemini-1.5-flash-latest', 'gemini-1.5-pro']
                    : ['gemini-2.0-flash-001', 'gemini-1.5-flash-002', 'gemini-1.5-pro-002'];

                if (!projectId) {
                    alert('Please provide a Vertex Project ID.');
                    return;
                }
                if (!location) {
                    alert('Please provide a Vertex location.');
                    return;
                }
                if (!token && !proxyUrl) {
                    alert('Please provide a Vertex credential (API key or OAuth token), or a Vertex Proxy URL.');
                    return;
                }

                apiStatus.textContent = 'Connecting...';
                apiStatus.style.color = 'orange';
                vertexModelInput.innerHTML = '<option>Loading models...</option>';
                vertexModelInput.disabled = true;

                try {
                    let models = [...fallbackModels];
                    let modelDiscoveryWarning = null;

                    if (proxyUrl) {
                        modelDiscoveryWarning = 'Connected via Vertex proxy. Using fallback models from app settings.';
                    } else if (usingApiKey) {
                        modelDiscoveryWarning = 'Connected in API key mode. Vertex aiplatform blocks API keys; using Gemini API-compatible models.';
                    }

                    if (!proxyUrl && !usingApiKey) {
                    try {
                        const auth = getVertexAuthConfig(token);
                        const modelsUrl = `https://${location}-aiplatform.googleapis.com/v1/projects/${projectId}/locations/${location}/publishers/google/models${auth.query}`;
                        const response = await fetch(modelsUrl, {
                            headers: { ...auth.headers }
                        });

                        if (!response.ok) {
                            const errorText = await response.text();
                            throw new Error(`Failed to fetch models: ${response.status} - ${errorText}`);
                        }

                        const result = await response.json();
                        const apiModels = (result.models || [])
                            .map(m => (m.name || '').split('/').pop())
                            .filter(Boolean)
                            .filter(name => name.toLowerCase().includes('gemini'));

                        if (apiModels.length > 0) {
                            models = [...new Set([...apiModels, ...fallbackModels])];
                        }
                    } catch (discoveryError) {
                        console.warn('Vertex model discovery failed; using fallback model list.', discoveryError);
                        const message = (discoveryError && discoveryError.message) ? discoveryError.message : '';
                        if (message.toLowerCase().includes('load failed') || message.toLowerCase().includes('failed to fetch')) {
                            modelDiscoveryWarning = 'Connected using fallback models. Live model discovery failed (often browser CORS/network related).';
                        } else {
                            modelDiscoveryWarning = 'Connected using fallback models. Live model discovery failed.';
                        }
                    }
                    }

                    vertexModelInput.innerHTML = '';
                    models.forEach(modelId => {
                        const option = document.createElement('option');
                        option.value = modelId;
                        option.textContent = modelId;
                        vertexModelInput.appendChild(option);
                    });

                    vertexProjectId = projectId;
                    vertexLocation = location;
                    vertexAccessToken = token || '';

                    const savedModel = localStorage.getItem('vertexModel');
                    if (savedModel && models.includes(savedModel)) {
                        vertexModelInput.value = savedModel;
                    } else if (usingApiKey && models.includes('gemini-2.0-flash')) {
                        vertexModelInput.value = 'gemini-2.0-flash';
                    } else if (!usingApiKey && models.includes('gemini-2.0-flash-001')) {
                        vertexModelInput.value = 'gemini-2.0-flash-001';
                    } else {
                        vertexModelInput.value = models[0];
                    }

                    selectedModel = vertexModelInput.value;
                    vertexModelInput.disabled = false;

                    localStorage.setItem('apiProvider', 'vertex');
                    localStorage.setItem('vertexProjectId', vertexProjectId);
                    localStorage.setItem('vertexLocation', vertexLocation);
                    localStorage.setItem('vertexAccessToken', vertexAccessToken);
                    localStorage.setItem('vertexProxyUrl', proxyUrl);
                    localStorage.setItem('vertexModel', selectedModel);

                    apiStatus.textContent = modelDiscoveryWarning ? 'Connected (fallback models)' : 'Connected';
                    apiStatus.style.color = modelDiscoveryWarning ? 'orange' : 'green';
                    verifyApiBtn.classList.remove('hidden');

                    if (modelDiscoveryWarning) {
                        alert(`${modelDiscoveryWarning}\n\nYou can still choose a model and run Verify/Generate.`);
                    }

                } catch (error) {
                    console.error('Vertex connection error:', error);
                    apiStatus.textContent = 'Failed';
                    apiStatus.style.color = 'red';
                    vertexModelInput.innerHTML = '<option>Connection Failed</option>';
                    vertexProjectId = null;
                    vertexLocation = 'us-central1';
                    vertexAccessToken = null;
                    selectedModel = null;
                    alert(`Failed to connect to Vertex AI. Check your project ID, location, token, and network connection.\nError: ${error.message}`);
                } finally {
                    fullRender();
                }
            };
            
            const connectToOpenAI = async () => {
                const key = openaiApiKeyInput.value.trim();
                if (!key) {
                    alert('Please provide an OpenAI API Key.');
                    return;
                }

                apiStatus.textContent = 'Connecting...';
                apiStatus.style.color = 'orange';
                openaiModelInput.innerHTML = '<option>Loading models...</option>';
                openaiModelInput.disabled = true;

                try {
                    const response = await fetch('https://api.openai.com/v1/models', {
                        headers: {
                            'Authorization': `Bearer ${key}`
                        }
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`Failed to fetch models: ${response.status} - ${errorData.error.message}`);
                    }
                    const data = await response.json();

                    const models = data.data
                        .filter(m => m.id.includes('gpt') && m.id.includes('instruct') === false) // Filter for chat models
                        .sort((a, b) => a.id.localeCompare(b.id)) // Sort them
                        .map(m => m.id);

                    if (models.length === 0) {
                        throw new Error("No compatible GPT models found.");
                    }

                    openaiModelInput.innerHTML = '';
                    models.forEach(modelId => {
                        const option = document.createElement('option');
                        option.value = modelId;
                        option.textContent = modelId;
                        openaiModelInput.appendChild(option);
                    });

                    openaiApiKey = key;
                    
                    const savedModel = localStorage.getItem('openaiModel');
                    if (savedModel && models.includes(savedModel)) {
                        openaiModelInput.value = savedModel;
                    } else if (models.includes('gpt-4o')) { // Prefer gpt-4o
                        openaiModelInput.value = 'gpt-4o';
                    } else if (models.includes('gpt-3.5-turbo')) {
                        openaiModelInput.value = 'gpt-3.5-turbo';
                    } else {
                        openaiModelInput.value = models[0]; // Fallback
                    }
                    
                    selectedModel = openaiModelInput.value;
                    openaiModelInput.disabled = false;

                    localStorage.setItem('apiProvider', 'openai');
                    localStorage.setItem('openaiApiKey', openaiApiKey);
                    localStorage.setItem('openaiModel', selectedModel);

                    apiStatus.textContent = 'Connected';
                    apiStatus.style.color = 'green';
                    verifyApiBtn.classList.remove('hidden');

                } catch (error) {
                    console.error('OpenAI connection error:', error);
                    apiStatus.textContent = 'Failed';
                    apiStatus.style.color = 'red';
                    openaiModelInput.innerHTML = '<option>Connection Failed</option>';
                    openaiApiKey = null;
                    selectedModel = null;
                    alert(`Failed to connect to OpenAI. Check your API key and network connection.\nError: ${error.message}`);
                } finally {
                    fullRender();
                }
            };

            const connectToGemini = async () => {
                const key = geminiApiKeyInput.value.trim();
                if (!key) {
                    alert('Please provide a Gemini API Key.');
                    return;
                }

                apiStatus.textContent = 'Connecting...';
                apiStatus.style.color = 'orange';
                geminiModelInput.innerHTML = '<option>Loading models...</option>';
                geminiModelInput.disabled = true;

                try {
                    const url = `https://generativelanguage.googleapis.com/v1beta/models?key=${key}`;
                    const response = await fetch(url);
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Failed to fetch models: ${response.status} - ${errorText}`);
                    }
                    const data = await response.json();

                    const models = data.models.filter(m => 
                        m.supportedGenerationMethods.includes("generateContent") &&
                        m.name.includes("gemini")
                    ).map(m => m.name.replace('models/', ''));

                    if (models.length === 0) {
                        throw new Error("No compatible Gemini models found.");
                    }

                    geminiModelInput.innerHTML = '';
                    models.forEach(modelId => {
                        const option = document.createElement('option');
                        option.value = modelId;
                        option.textContent = modelId;
                        geminiModelInput.appendChild(option);
                    });

                    geminiApiKey = key;
                    
                    const savedModel = localStorage.getItem('geminiModel');
                    if (savedModel && models.includes(savedModel)) {
                        geminiModelInput.value = savedModel;
                    } else if (models.includes('gemini-1.5-flash-latest')) {
                        geminiModelInput.value = 'gemini-1.5-flash-latest';
                    } else {
                        geminiModelInput.value = models[0];
                    }
                    
                    selectedModel = geminiModelInput.value;
                    geminiModelInput.disabled = false;

                    localStorage.setItem('apiProvider', 'gemini');
                    localStorage.setItem('geminiApiKey', geminiApiKey);
                    localStorage.setItem('geminiModel', selectedModel);

                    apiStatus.textContent = 'Connected';
                    apiStatus.style.color = 'green';
                    verifyApiBtn.classList.remove('hidden');

                } catch (error) {
                    console.error('Gemini connection error:', error);
                    apiStatus.textContent = 'Failed';
                    apiStatus.style.color = 'red';
                    geminiModelInput.innerHTML = '<option>Connection Failed</option>';
                    geminiApiKey = null;
                    selectedModel = null;
                    alert(`Failed to connect to Gemini. Check your API key and network connection.\nError: ${error.message}`);
                } finally {
                    fullRender();
                }
            };

            const connectToOpenWebUI = async () => {
                const address = serverAddressInput.value.trim();
                if (!address) {
                    alert('Please enter an Open WebUI address.');
                    return;
                }
                serverAddress = address.endsWith('/') ? address.slice(0, -1) : address;
                apiKey = apiKeyInput.value.trim();

                // Save settings to local storage immediately
                localStorage.setItem('apiProvider', 'openwebui');
                localStorage.setItem('serverAddress', serverAddress);
                if (apiKey) {
                    localStorage.setItem('apiKey', apiKey);
                } else {
                    localStorage.removeItem('apiKey');
                }

                apiStatus.textContent = 'Connecting...';
                apiStatus.style.color = 'orange';
                modelSelect.innerHTML = '<option>Loading models...</option>';
                modelSelect.disabled = true;

                try {
                    const headers = new Headers();
                    if (apiKey) {
                        headers.append('Authorization', `Bearer ${apiKey}`);
                    }
                    const response = await fetch(`${serverAddress}/api/v1/models`, { headers, mode: 'cors' });
                    if (!response.ok) {
                        const error = new Error(`Failed to connect to Open WebUI. Status: ${response.status}`);
                        error.response = response;
                        throw error;
                    }
                    const data = await response.json();
                    
                    apiStatus.textContent = 'Connected';
                    apiStatus.style.color = 'green';
                    
                    // localStorage.setItem('serverAddress', serverAddress);
                    // if (apiKey) localStorage.setItem('apiKey', apiKey);
                    // else localStorage.removeItem('apiKey');
                    
                    modelSelect.innerHTML = '';
                    const models = data.data;

                    if (models && models.length > 0) {
                        models.forEach(model => {
                            const option = document.createElement('option');
                            option.value = model.id;
                                                         option.textContent = model.id;
                            modelSelect.appendChild(option);
                        });

                        let autoSelectedModelId = null;
                        const llamaModel = models.find(m => m.id === 'llama3.2:3b');
                        const deepseekModel = models.find(m => m.id === 'deepseek-r1:1.5b');

                        if (llamaModel) {
                            autoSelectedModelId = llamaModel.id;
                        } else if (deepseekModel) {
                            autoSelectedModelId = deepseekModel.id;
                        } else {
                            const fallbackModel = models.find(m => 
                                m.id !== 'arena-model' && 
                                !m.id.toLowerCase().includes('coder') && 
                                !m.id.toLowerCase().includes('coding')
                            );
                            if (fallbackModel) {
                                autoSelectedModelId = fallbackModel.id;
                            }
                        }

                        if (autoSelectedModelId) {
                            modelSelect.value = autoSelectedModelId;
                        } else if (models.length > 0) {
                            modelSelect.value = models[0].id;
                        }

                        selectedModel = modelSelect.value;
                        modelSelect.disabled = false;
                        
                    } else {

                        modelSelect.innerHTML = '<option>No models found</option>';
                        selectedModel = null;
                        modelSelect.disabled = true;
                    }

                } catch (error) {
                    console.error('API connection error:', error);
                    apiStatus.textContent = 'Failed';
                    apiStatus.style.color = 'red';
                    serverAddress = null;
                    modelSelect.innerHTML = '<option>Connection failed</option>';
                    
                                        
                    let alertMessage = `Connection to "${address}" failed.`;
                    
                    if (error.response?.status === 401) {
                         alertMessage += `\n\nError: Authentication failed (401 Unauthorized). Please check if your API Key is correct and has the necessary permissions. Some servers require an API key even if it's optional in the UI.`;
                    } else if (error instanceof TypeError && error.message.toLowerCase().includes('failed to fetch')) {
                        alertMessage = `Network Error: Failed to fetch.

This is the most common error and is almost always caused by one of two things:

1.  **CORS Policy:** Your browser is blocking the request for security reasons. The Open WebUI server must be configured to allow requests from this webpage.
    *SOLUTION:* In your Open WebUI settings, find the "Allowed Origins" configuration and add the URL of this page. You can often just add "*" to allow all origins, but this is less secure.

2.  **Server Not Reachable:** The address "${address}" is incorrect, or the Open WebUI server is not running. Please double-check the address and ensure the server is active.

This error cannot be fixed within this application's code; it requires a configuration change on the server you are trying to connect to.`;
                    } else {
                         alertMessage += `\n\nError: ${error.message}`;
                    }
                    alert(alertMessage);

                } finally {
                    fullRender();
                }
            };


            // --- Data Persistence (Save/Load/AutoSave) ---
            const updateSaveStatus = (message, isGood = true, duration = 0) => {
                autoSaveIndicator.style.opacity = '1';
                saveStatus.textContent = message;
                saveStatus.style.color = isGood ? 'white' : '#f1c40f'; // Gold for warning
                if (duration > 0) {
                    setTimeout(() => {
                        if (saveStatus.textContent === message) {
                            autoSaveIndicator.style.opacity = '0';
                        }
                    }, duration);
                }
            }

            const markDirty = () => {
                if (!isDirty) {
                    isDirty = true;
                    updateSaveStatus('Unsaved changes...', false);
                }
                debouncedAutoSave();
            };

            const saveDataToLocalStorage = () => {
                try {
                    const state = { data, deletedItems, selectedClientId, selectedAppointmentId, selectedNoteId, selectedIntakeId };
                    const dataStr = JSON.stringify(state);
                    localStorage.setItem('clientData', dataStr);
                    isDirty = false;
                } catch (e) {
                    console.error("Failed to save to localStorage", e);
                    updateSaveStatus('Save failed!', false, 3000);
                    // Handle potential quota exceeded error
                    if (e.name === 'QuotaExceededError') {
                        alert('Failed to save data: Storage quota exceeded. Please export your data to a file and consider clearing some old records.');
                    }
                }
            };

            const loadDataFromLocalStorage = () => {
                const dataStr = localStorage.getItem('clientData');
                if (dataStr) {
                    try {
                        const state = JSON.parse(dataStr);
                        data = state.data || getInitialData();
                        if (!data.archivedClients) data.archivedClients = [];
                        deletedItems = state.deletedItems || { clients: [], appointments: [], notes: [] };
                        selectedClientId = null;
                        selectedAppointmentId = null;
                        selectedNoteId = null;
                        selectedIntakeId = null;
                        normalizeClientData();

                        // Load API settings
                        const savedProvider = localStorage.getItem('apiProvider');
                        if (savedProvider) {
                            apiProvider = savedProvider;
                            apiProviderSelect.value = apiProvider;
                            toggleProviderSettings();
                        }
                        serverAddressInput.value = localStorage.getItem('serverAddress') || '';
                        apiKeyInput.value = localStorage.getItem('apiKey') || '';
                        geminiApiKeyInput.value = localStorage.getItem('geminiApiKey') || '';
                        vertexProjectIdInput.value = localStorage.getItem('vertexProjectId') || '';
                        vertexLocationInput.value = localStorage.getItem('vertexLocation') || 'us-central1';
                        vertexProxyUrlInput.value = localStorage.getItem('vertexProxyUrl') || '';
                        vertexGoogleClientIdInput.value = localStorage.getItem('vertexGoogleClientId') || '';
                        vertexAccessTokenInput.value = localStorage.getItem('vertexAccessToken') || '';
                        openaiApiKeyInput.value = localStorage.getItem('openaiApiKey') || '';
                        // We don't load the gemini model name here, it's set after connection

                    } catch (e) {
                        console.error("Failed to load from localStorage", e);
                        alert("Error loading data from storage. Data might be corrupt. Starting fresh.");
                        data = getInitialData();
                        deletedItems = { clients: [], appointments: [], notes: [] };
                    }
                }
            };

            const exportFile = () => {
                try {
                    const stateToSave = { data, deletedItems, selectedClientId, selectedAppointmentId, selectedNoteId, selectedIntakeId };
                    const stateJSON = JSON.stringify(stateToSave, null, 2);
                    const blob = new Blob([stateJSON], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `client-data-${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    updateSaveStatus('Exported.', true, 2000);
                } catch (err) {
                    console.error('Failed to export file:', err);
                    alert('Export failed!');
                    updateSaveStatus('Export failed!', false, 3000);
                }
            };

            let saveTimeout;
            const debouncedAutoSave = () => {
                clearTimeout(saveTimeout);
                saveTimeout = setTimeout(() => {
                    saveDataToLocalStorage();
                    updateSaveStatus('Auto-saved', true, 2000);
                }, 1500);
            };

            const loadFile = () => {
                 if (isDirty && !confirm('You have unsaved changes that will be lost. Are you sure you want to import a new file?')) {
                     return;
                 }
                fileInput.click();
            };

            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const contents = e.target.result;
                        const state = JSON.parse(contents);

                        if (!state.data || !state.deletedItems) {
                            throw new Error("Invalid file structure. Required properties are missing.");
                        }

                        data = state.data;
                        deletedItems = state.deletedItems;
                        selectedClientId = state.selectedClientId || null;
                        selectedAppointmentId = state.selectedAppointmentId || null;
                        selectedNoteId = state.selectedNoteId || null;
                        selectedIntakeId = state.selectedIntakeId || null;

                        if (!data.archivedClients) {
                            data.archivedClients = [];
                        }
                        normalizeClientData();

                        isDirty = false;
                        saveDataToLocalStorage();

                        alert(`Imported ${file.name} successfully.`);
                        fullRender();
                    } catch (err) {
                        console.error('Failed to load file:', err);
                        alert(`Import failed! Invalid file.\n\nError: ${err.message}`);
                    } finally {
                        // Reset file input so the same file can be loaded again
                        fileInput.value = '';
                    }
                };
                reader.readAsText(file);
            });

            const eraseAllData = () => {
                const confirmationText = "DELETE ALL DATA";
                const userInput = prompt(`This action will permanently erase all client data from this browser. This cannot be undone.\n\nTo confirm, please type "${confirmationText}" in the box below.`);
                if (userInput === confirmationText) {
                    data = getInitialData();
                    deletedItems = { clients: [], appointments: [], notes: [] };
                    selectedClientId = null;
                    selectedAppointmentId = null;
                    selectedNoteId = null;
                    selectedIntakeId = null;
                    isDirty = false;
                    localStorage.removeItem('clientData');
                    localStorage.removeItem('serverAddress');
                    localStorage.removeItem('apiKey');
                    localStorage.removeItem('geminiApiKey');
                    localStorage.removeItem('vertexProjectId');
                    localStorage.removeItem('vertexLocation');
                    localStorage.removeItem('vertexProxyUrl');
                    localStorage.removeItem('vertexGoogleClientId');
                    localStorage.removeItem('vertexAccessToken');
                    localStorage.removeItem('openaiApiKey');
                    localStorage.removeItem('geminiModel');
                    localStorage.removeItem('vertexModel');
                    localStorage.removeItem('openaiModel');
                    localStorage.removeItem('apiProvider');
                    localStorage.removeItem('columnSizes');
                    localStorage.removeItem('rowSizes');
                    localStorage.removeItem('theme');
                    alert('All data has been permanently erased. The page will now reload.');
                    window.location.reload();
                } else if (userInput !== null) {
                    alert('The text you entered did not match. No data has been erased.');
                }
            };

            // --- Event Listeners ---
            addClientBtn.addEventListener('click', addClient);
            sortClientsBtn.addEventListener('click', () => {
                data.clients.sort((a, b) => a.name.localeCompare(b.name));
                markDirty();
                renderClients();
            });
            addAppointmentBtn.addEventListener('click', addAppointment);
            addIntakeBtn.addEventListener('click', addIntakeSession);
            addNoteBtn.addEventListener('click', addNote);
            renameNoteBtn.addEventListener('click', renameSelectedNote);
            noteNameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (selectedNoteId) {
                        renameSelectedNote();
                    } else {
                        addNote();
                    }
                }
            });
            addGoalBtnInTab.addEventListener('click', addGoal);

            // Tab switching functionality
            appointmentsTabBtn.addEventListener('click', () => {
                appointmentsTabBtn.style.color = 'var(--text-color-primary)';
                appointmentsTabBtn.style.borderBottomColor = '#3498db';
                goalsTabBtn.style.color = 'var(--text-color-secondary)';
                goalsTabBtn.style.borderBottomColor = 'transparent';
                appointmentsTabContent.style.display = 'flex';
                goalsTabContent.style.display = 'none';
            });

            goalsTabBtn.addEventListener('click', () => {
                goalsTabBtn.style.color = 'var(--text-color-primary)';
                goalsTabBtn.style.borderBottomColor = '#3498db';
                appointmentsTabBtn.style.color = 'var(--text-color-secondary)';
                appointmentsTabBtn.style.borderBottomColor = 'transparent';
                goalsTabContent.style.display = 'flex';
                appointmentsTabContent.style.display = 'none';
            });

            // Goals event delegation
            goalsListInTabEl.addEventListener('click', (e) => {
                const goalItem = e.target.closest('.goal-item');
                if (!goalItem) return;
                
                const goalId = goalItem.dataset.goalId;
                
                if (e.target.classList.contains('add-objective-btn')) {
                    addObjective(goalId);
                } else if (e.target.classList.contains('objective-checkbox')) {
                    const objectiveItem = e.target.closest('.objective-item');
                    const objectiveId = objectiveItem.dataset.objectiveId;
                    toggleObjective(goalId, objectiveId);
                } else if (e.target.classList.contains('edit-objective-btn')) {
                    const objectiveItem = e.target.closest('.objective-item');
                    const objectiveId = objectiveItem.dataset.objectiveId;
                    editObjective(goalId, objectiveId);
                } else if (e.target.classList.contains('timeline-objective-btn')) {
                    const objectiveItem = e.target.closest('.objective-item');
                    const objectiveId = objectiveItem.dataset.objectiveId;
                    editObjectiveTimeline(goalId, objectiveId);
                } else if (e.target.closest('.objective-item') && e.target.classList.contains('delete-btn')) {
                    const objectiveItem = e.target.closest('.objective-item');
                    const objectiveId = objectiveItem.dataset.objectiveId;
                    deleteObjective(goalId, objectiveId);
                } else if (e.target.classList.contains('edit-btn')) {
                    editGoal(goalId);
                } else if (e.target.classList.contains('timeline-btn')) {
                    editGoalTimeline(goalId);
                } else if (e.target.classList.contains('archive-btn')) {
                    changeGoalStatus(goalId);
                } else if (e.target.classList.contains('delete-btn')) {
                    deleteGoal(goalId);
                }
            });

            // Show/hide objective delete buttons on hover
            goalsListInTabEl.addEventListener('mouseover', (e) => {
                const objectiveItem = e.target.closest('.objective-item');
                if (objectiveItem) {
                    objectiveItem.querySelectorAll('.action-btn').forEach(btn => {
                        btn.style.opacity = '1';
                    });
                }
            });

            goalsListInTabEl.addEventListener('mouseout', (e) => {
                const objectiveItem = e.target.closest('.objective-item');
                if (objectiveItem) {
                    objectiveItem.querySelectorAll('.action-btn').forEach(btn => {
                        btn.style.opacity = '0';
                    });
                }
            });

            generateGoalsBtn.addEventListener('click', () => {
                const client = findClient(selectedClientId);
                if (!client) return;
                generatedGoalsDraft = [];
                const clientLens = getClientGoalGenerationLens(client);
                goalGeneratorModalities = [...clientLens.modalities];
                goalGeneratorModalityOther = clientLens.other || '';
                goalProblemInput.value = '';
                goalCountInput.value = '2';
                objectiveCountInput.value = '4';
                objectiveStyleSelect.value = 'action';
                renderGuidingModalities();
                renderGeneratedGoalsReview();
                goalGeneratorModal.classList.remove('hidden');
            });
            closeGoalGeneratorBtn.addEventListener('click', () => goalGeneratorModal.classList.add('hidden'));
            goalGeneratorModal.addEventListener('click', (e) => {
                if (e.target.id === 'goalGeneratorModal') {
                    goalGeneratorModal.classList.add('hidden');
                }
            });
            runGoalGeneratorBtn.addEventListener('click', generateGoalDrafts);
            applyGeneratedGoalsBtn.addEventListener('click', applyGeneratedGoals);
            generatedGoalsReview.addEventListener('input', syncGeneratedGoalsFromReview);
            generatedGoalsReview.addEventListener('change', syncGeneratedGoalsFromReview);

            interventionBankBtn.addEventListener('click', () => {
                renderInterventionBank();
                interventionBankModal.classList.remove('hidden');
            });
            closeInterventionBankBtn.addEventListener('click', () => interventionBankModal.classList.add('hidden'));
            interventionBankModal.addEventListener('click', (e) => {
                if (e.target.id === 'interventionBankModal') {
                    interventionBankModal.classList.add('hidden');
                }
            });
            addInterventionBtn.addEventListener('click', () => {
                const text = (newInterventionInput.value || '').trim();
                if (!text) return;
                if (!Array.isArray(data.interventionBank)) data.interventionBank = [];
                if (!data.interventionBank.includes(text)) {
                    data.interventionBank.push(text);
                    data.interventionBank.sort((a, b) => a.localeCompare(b));
                    newInterventionInput.value = '';
                    markDirty();
                    renderInterventionBank();
                }
            });
            interventionBankList.addEventListener('click', (e) => {
                const btn = e.target.closest('[data-bank-index]');
                if (!btn) return;
                const index = parseInt(btn.dataset.bankIndex, 10);
                if (Number.isNaN(index)) return;
                const [removed] = data.interventionBank.splice(index, 1);
                if (removed) {
                    [...(data.clients || []), ...(data.archivedClients || [])].forEach(client => {
                        (client.appointments || []).forEach(appt => {
                            if (Array.isArray(appt.selectedInterventions)) {
                                appt.selectedInterventions = appt.selectedInterventions.filter(item => item !== removed);
                            }
                        });
                    });
                    markDirty();
                    renderInterventionBank();
                    renderSoap();
                }
            });

            closeInterventionPickerBtn.addEventListener('click', () => interventionPickerModal.classList.add('hidden'));
            interventionPickerModal.addEventListener('click', (e) => {
                if (e.target.id === 'interventionPickerModal') {
                    interventionPickerModal.classList.add('hidden');
                }
            });
            saveInterventionSelectionBtn.addEventListener('click', () => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (!appointment) return;
                const selected = Array.from(interventionPickerList.querySelectorAll('.picker-intervention:checked')).map(input => input.value);
                appointment.selectedInterventions = selected;
                if (!appointment.soap) appointment.soap = { s: '', o: '', a: '', p: '' };
                appointment.soap.interventions = selected.length > 0
                    ? selected.map(item => `‚Ä¢ ${item}`).join('\n')
                    : 'No interventions selected from the bank.';
                delete appointment.auditCheck;
                markDirty();
                interventionPickerModal.classList.add('hidden');
                renderSoap();
            });
            exportBtn.addEventListener('click', exportFile);
            importBtn.addEventListener('click', loadFile);
            eraseAllBtn.addEventListener('click', eraseAllData);
            generateNoteBtn.addEventListener('click', generateSoapNote);
            connectApiBtn.addEventListener('click', connectToServer);
            verifyApiBtn.addEventListener('click', verifyApiConnection);
            manualSaveBtn.addEventListener('click', () => {
                saveDataToLocalStorage();
                updateSaveStatus('Data saved!', true, 2000);
            });
            settingsBtn.addEventListener('click', () => settingsModal.classList.remove('hidden'));
            closeSettingsBtn.addEventListener('click', () => settingsModal.classList.add('hidden'));
            settingsModal.addEventListener('click', (e) => {
                if(e.target.id === 'settingsModal') {
                    settingsModal.classList.add('hidden');
                }
            });
            cssrsBtn.addEventListener('click', () => {
                window.open('https://therapytools.github.io/ClientRecords/CSSRS.html', 'cssrsPopup', 'width=1024,height=860,resizable=yes,scrollbars=yes');
            });
            informedConsentBtn.addEventListener('click', () => informedConsentModal.classList.remove('hidden'));
            closeConsentBtn.addEventListener('click', () => informedConsentModal.classList.add('hidden'));
            closeConsentBtnBottom.addEventListener('click', () => informedConsentModal.classList.add('hidden'));
            informedConsentModal.addEventListener('click', (e) => {
                if(e.target.id === 'informedConsentModal') {
                    informedConsentModal.classList.add('hidden');
                }
            });
            soapAuditGuideBtn.addEventListener('click', () => soapAuditGuideModal.classList.remove('hidden'));
            closeSoapAuditGuideBtn.addEventListener('click', () => soapAuditGuideModal.classList.add('hidden'));
            closeSoapAuditGuideBtnBottom.addEventListener('click', () => soapAuditGuideModal.classList.add('hidden'));
            soapAuditGuideModal.addEventListener('click', (e) => {
                if (e.target.id === 'soapAuditGuideModal') {
                    soapAuditGuideModal.classList.add('hidden');
                }
            });
            customInstructionsBtn.addEventListener('click', () => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                const clientLens = getClientGoalGenerationLens(client);
                goalGeneratorModalities = [...clientLens.modalities];
                goalGeneratorModalityOther = clientLens.other || '';
                persistentInstructions = client ? client.persistentInstructions || '' : '';
                sessionInstructions = appointment ? appointment.sessionInstructions || '' : '';
                customInstructionsModal.classList.remove('hidden');
                persistentInstructionsInput.value = persistentInstructions;
                sessionInstructionsInput.value = sessionInstructions;
                sessionInstructionsInput.disabled = !appointment;
                sessionInstructionsInput.placeholder = appointment
                    ? 'Applies only to the selected appointment/session.'
                    : 'Select an appointment to edit Session Instructions.';
                renderCustomInstructionsModalities();
                persistentInstructionsInput.focus();
            });
            closeCustomInstructionsBtn.addEventListener('click', () => customInstructionsModal.classList.add('hidden'));
            customInstructionsModal.addEventListener('click', (e) => {
                if(e.target.id === 'customInstructionsModal') {
                    customInstructionsModal.classList.add('hidden');
                }
            });
            saveCustomInstructionsBtn.addEventListener('click', () => {
                persistentInstructions = persistentInstructionsInput.value;
                sessionInstructions = sessionInstructionsInput.value;
                customInstructionsModal.classList.add('hidden');
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (client) {
                    client.persistentInstructions = persistentInstructions;
                }
                if (appointment) {
                    appointment.sessionInstructions = sessionInstructions;
                    if (!appointment.sessionInstructions.trim()) delete appointment.sessionInstructions;
                    if (appointment.customInstructions !== undefined) delete appointment.customInstructions;
                }
                markDirty();
            });
            clearCustomInstructionsBtn.addEventListener('click', () => {
                persistentInstructionsInput.value = '';
                sessionInstructionsInput.value = '';
                persistentInstructions = '';
                sessionInstructions = '';
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (client) {
                    client.persistentInstructions = '';
                }
                if (appointment) {
                    delete appointment.sessionInstructions;
                    if (appointment.customInstructions !== undefined) delete appointment.customInstructions;
                }
                markDirty();
            });
            customInstructionsModalitiesListEl.addEventListener('change', (e) => {
                if (!e.target.matches('.custom-instructions-modality-select')) return;
                saveCustomInstructionsModalities();
            });
            customInstructionsModalitiesListEl.addEventListener('click', (e) => {
                if (e.target.classList.contains('add-custom-modality-btn')) {
                    goalGeneratorModalities.push(DEFAULT_GUIDING_MODALITIES[0]);
                    renderCustomInstructionsModalities();
                    saveClientGoalGenerationLens();
                    return;
                }
                if (e.target.classList.contains('remove-custom-modality-btn')) {
                    if (goalGeneratorModalities.length <= 1) return;
                    const row = e.target.closest('.modality-row');
                    const index = row ? parseInt(row.dataset.modalInstructionsIndex, 10) : -1;
                    if (index >= 0) {
                        goalGeneratorModalities.splice(index, 1);
                        if (!goalGeneratorModalities.includes('Other (Specify)')) {
                            goalGeneratorModalityOther = '';
                        }
                        renderCustomInstructionsModalities();
                        saveClientGoalGenerationLens();
                    }
                }
            });
            customInstructionsModalityOtherEl.addEventListener('input', () => {
                goalGeneratorModalityOther = customInstructionsModalityOtherEl.value;
                saveClientGoalGenerationLens();
            });
            modelSelect.addEventListener('change', (e) => {
                selectedModel = e.target.value;
                localStorage.setItem('openWebUIModel', selectedModel);
                fullRender();
            });

            geminiModelInput.addEventListener('change', (e) => {
                selectedModel = e.target.value;
                localStorage.setItem('geminiModel', selectedModel);
                fullRender();
            });

            openaiModelInput.addEventListener('change', (e) => {
                selectedModel = e.target.value;
                localStorage.setItem('openaiModel', selectedModel);
                fullRender();
            });

            vertexModelInput.addEventListener('change', (e) => {
                selectedModel = e.target.value;
                localStorage.setItem('vertexModel', selectedModel);
                fullRender();
            });

            vertexGoogleLoginBtn.addEventListener('click', requestVertexGoogleAccessToken);
            vertexGoogleClientIdInput.addEventListener('change', () => {
                localStorage.setItem('vertexGoogleClientId', vertexGoogleClientIdInput.value.trim());
                vertexGoogleTokenClient = null;
            });

            const toggleProviderSettings = () => {
                const provider = apiProviderSelect.value;
                apiProvider = provider;
                openwebuiSettings.classList.add('hidden');
                geminiSettings.classList.add('hidden');
                vertexSettings.classList.add('hidden');
                openaiSettings.classList.add('hidden');
                modelSelectWrapper.classList.add('hidden'); // This is for OpenWebUI

                if (provider === 'openwebui') {
                    openwebuiSettings.classList.remove('hidden');
                    modelSelectWrapper.classList.remove('hidden'); // Show the OpenWebUI model select
                } else if (provider === 'gemini') {
                    geminiSettings.classList.remove('hidden');
                } else if (provider === 'vertex') {
                    vertexSettings.classList.remove('hidden');
                } else if (provider === 'openai') {
                    openaiSettings.classList.remove('hidden');
                }
            };
            apiProviderSelect.addEventListener('change', toggleProviderSettings);

            startTimerBtn.addEventListener('click', () => {
                const appointment = findAppointment(findClient(selectedClientId), selectedAppointmentId);
                if (appointment) {
                    appointment.startTime = new Date().toISOString();
                    appointment.endTime = null; // Clear end time if starting again
                    delete appointment.auditCheck;
                    markDirty();
                    renderSessionTimer(appointment);
                }
            });

            stopTimerBtn.addEventListener('click', () => {
                const appointment = findAppointment(findClient(selectedClientId), selectedAppointmentId);
                if (appointment && appointment.startTime) { // Can only stop if started
                    appointment.endTime = new Date().toISOString();
                    clearInterval(sessionTimerInterval);
                    delete appointment.auditCheck;
                    markDirty();
                    renderSessionTimer(appointment);
                }
            });

            // --- Theme Management ---
            const updateThemeButton = () => {
                const savedTheme = localStorage.getItem('theme') || 'automatic';
                if (savedTheme === 'dark') {
                    themeToggleBtn.textContent = 'üåô';
                    themeToggleBtn.title = 'Switch to Automatic Theme';
                } else if (savedTheme === 'automatic') {
                    themeToggleBtn.textContent = 'üîÑ';
                    themeToggleBtn.title = 'Switch to Light Theme';
                } else {
                    themeToggleBtn.textContent = '‚òÄÔ∏è';
                    themeToggleBtn.title = 'Switch to Dark Theme';
                }
            };

            const cycleTheme = () => {
                const savedTheme = localStorage.getItem('theme') || 'automatic';
                let newTheme;
                if (savedTheme === 'light') {
                    newTheme = 'dark';
                } else if (savedTheme === 'dark') {
                    newTheme = 'automatic';
                } else {
                    newTheme = 'light';
                }
                applyTheme(newTheme);
            };

            const applyTheme = (theme) => {
                if (theme === 'automatic') {
                    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                    document.body.dataset.theme = prefersDark ? 'dark' : 'light';
                } else {
                    document.body.dataset.theme = theme;
                }
                localStorage.setItem('theme', theme);
                updateThemeButton();
            };

            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
                const savedTheme = localStorage.getItem('theme') || 'automatic';
                if (savedTheme === 'automatic') {
                    applyTheme('automatic');
                }
            });

            themeToggleBtn.addEventListener('click', cycleTheme);

            // --- Collapsible Sections ---
            const handleCollapsibleClick = (e) => {
                const header = e.target.closest('.collapsible-header');
                if (!header) return;

                const targetId = header.dataset.target;
                const content = document.getElementById(targetId);
                const icon = header.querySelector('.collapse-icon');
                const wrapper = header.parentElement;

                if (content && icon) {
                    const isCollapsed = content.classList.contains('collapsed');
                    
                    if (isCollapsed) {
                        // Expand - restore original size and remove pinning
                        content.classList.remove('collapsed', 'pinned');
                        icon.classList.remove('collapsed');
                        wrapper.style.flexBasis = '33.33%';
                        wrapper.style.minHeight = '';
                        wrapper.style.maxHeight = '';
                        wrapper.style.order = ''; // Reset order
                    } else {
                        // Collapse - add pinning class and force minimal size
                        content.classList.add('collapsed', 'pinned');
                        icon.classList.add('collapsed');
                        wrapper.style.flexBasis = '50px';
                        wrapper.style.minHeight = '50px';
                        wrapper.style.maxHeight = '50px';
                        // Order is now handled by CSS class
                        wrapper.style.order = ''; // Clear inline order to let CSS handle it
                    }
                    
                    // Save collapsed state
                    const sectionName = targetId.replace('Content', '');
                    localStorage.setItem(`${sectionName}Collapsed`, !isCollapsed);
                    saveColumnSizes(); // Update saved sizes
                }
            };

            // Add event listeners for collapsible headers
            document.addEventListener('click', handleCollapsibleClick);

            // Load collapsed states
            const loadCollapsedStates = () => {
                const notesCollapsed = localStorage.getItem('notesCollapsed') === 'true';

                if (notesCollapsed) {
                    const notesContent = document.getElementById('notesContent');
                    const notesIcon = document.querySelector('[data-target="notesContent"] .collapse-icon');
                    const notesWrapper = document.getElementById('notesWrapper');
                    
                    notesContent?.classList.add('collapsed', 'pinned');
                    notesIcon?.classList.add('collapsed');
                    if (notesWrapper) {
                        notesWrapper.style.flexBasis = '50px';
                        notesWrapper.style.minHeight = '50px';
                        notesWrapper.style.maxHeight = '50px';
                        notesWrapper.style.order = ''; // Clear order to let CSS handle it
                    }
                }
            };

            // --- Resizable Panels ---
            function saveColumnSizes() {
                const panels = ['panelClients', 'panelAppointments', 'panelSession', 'panelSoap'];
                const sizes = panels.map(id => document.getElementById(id).style.flexBasis);
                localStorage.setItem('columnSizes', JSON.stringify(sizes));
                const sessionInfoHeight = document.getElementById('sessionInfoWrapper').style.flexBasis;
                const notesHeight = document.getElementById('notesWrapper').style.flexBasis;
                localStorage.setItem('rowSizes', JSON.stringify({ sessionInfoHeight, notesHeight }));
            }

            function loadColumnSizes() {
                const sizes = JSON.parse(localStorage.getItem('columnSizes'));
                if (sizes && sizes.length === 4) {
                    ['panelClients', 'panelAppointments', 'panelSession', 'panelSoap'].forEach((id, index) => {
                        const panel = document.getElementById(id);
                        if (panel) panel.style.flexBasis = sizes[index];
                    });
                }
                const rowSizes = JSON.parse(localStorage.getItem('rowSizes'));
                if (rowSizes) {
                    const sessionWrapper = document.getElementById('sessionInfoWrapper');
                    const notesWrapper = document.getElementById('notesWrapper');
                    if (sessionWrapper) sessionWrapper.style.flexBasis = rowSizes.sessionInfoHeight;
                    if (notesWrapper) notesWrapper.style.flexBasis = rowSizes.notesHeight;
                }
            }

            function makeResizable(resizer, prev, next, direction = 'x') {
                let x = 0;
                let y = 0;
                let prevSize = 0;
                let nextSize = 0;
                let containerSize = 0;

                resizer.addEventListener('mousedown', function (e) {
                    e.preventDefault();
                    if (direction === 'x') {
                        x = e.clientX;
                        prevSize = prev.getBoundingClientRect().width;
                        nextSize = next.getBoundingClientRect().width;
                        containerSize = prev.parentElement.getBoundingClientRect().width;
                    } else {
                        y = e.clientY;
                        prevSize = prev.getBoundingClientRect().height;
                        nextSize = next.getBoundingClientRect().height;
                        containerSize = prev.parentElement.getBoundingClientRect().height;
                    }
                    
                    document.body.style.cursor = direction === 'x' ? 'col-resize' : 'row-resize';
                    document.body.style.userSelect = 'none';

                    document.addEventListener('mousemove', mousemove);
                    document.addEventListener('mouseup', mouseup);
                });

                function mousemove(e) {
                    if (direction === 'x') {
                        const dx = e.clientX - x;
                        const newPrevSize = prevSize + dx;
                        const newNextSize = nextSize - dx;
                        
                        if(newPrevSize > 150 && newNextSize > 150) {
                            prev.style.flexBasis = `${(newPrevSize / containerSize) * 100}%`;
                            next.style.flexBasis = `${(newNextSize / containerSize) * 100}%`;
                        }
                    } else {
                        const dy = e.clientY - y;
                        const newPrevSize = prevSize + dy;
                        const newNextSize = nextSize - dy;

                        if(newPrevSize > 100 && newNextSize > 100) {
                            prev.style.flexBasis = `${(newPrevSize / containerSize) * 100}%`;
                            next.style.flexBasis = `${(newNextSize / containerSize) * 100}%`;
                        }
                    }
                }

                function mouseup() {
                    document.removeEventListener('mousemove', mousemove);
                    document.removeEventListener('mouseup', mouseup);
                    document.body.style.cursor = 'default';
                    document.body.style.userSelect = 'auto';
                    saveColumnSizes();
                }
            }
            
            // --- Initial Load & Render ---
            const loadServerSettings = () => {
                const savedProvider = localStorage.getItem('apiProvider');
                if (savedProvider) {
                    apiProvider = savedProvider;
                    apiProviderSelect.value = apiProvider;
                }
                
                const savedAddress = localStorage.getItem('serverAddress');
                const savedApiKey = localStorage.getItem('apiKey');
                const savedGeminiKey = localStorage.getItem('geminiApiKey');
                const savedVertexProjectId = localStorage.getItem('vertexProjectId');
                const savedVertexLocation = localStorage.getItem('vertexLocation');
                const savedVertexProxyUrl = localStorage.getItem('vertexProxyUrl');
                const savedVertexAccessToken = localStorage.getItem('vertexAccessToken');
                const savedOpenAIKey = localStorage.getItem('openaiApiKey');
                
                toggleProviderSettings(); // Set initial UI state

                if (apiProvider === 'openwebui' && savedAddress) {
                    serverAddressInput.value = savedAddress;
                    if(savedApiKey) apiKeyInput.value = savedApiKey;
                    connectToOpenWebUI();
                } else if (apiProvider === 'gemini' && savedGeminiKey) {
                    geminiApiKeyInput.value = savedGeminiKey;
                    connectToGemini();
                } else if (apiProvider === 'vertex' && savedVertexProjectId && (savedVertexAccessToken || savedVertexProxyUrl)) {
                    vertexProjectIdInput.value = savedVertexProjectId;
                    vertexLocationInput.value = savedVertexLocation || 'us-central1';
                    vertexProxyUrlInput.value = savedVertexProxyUrl || '';
                    vertexAccessTokenInput.value = savedVertexAccessToken;
                    connectToVertex();
                } else if (apiProvider === 'openai' && savedOpenAIKey) {
                    openaiApiKeyInput.value = savedOpenAIKey;
                    connectToOpenAI();
                }
            };
            
            const loadTheme = () => {
                const savedTheme = localStorage.getItem('theme') || 'automatic';
                applyTheme(savedTheme);
            };

            // Set appointment date to today (local timezone, not UTC)
            const today = new Date();
            const localDateString = today.getFullYear() + '-' + 
                String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                String(today.getDate()).padStart(2, '0');
            appointmentDateInput.value = localDateString;
            loadDataFromLocalStorage(); // This now loads API settings too
            normalizeClientData();
            loadServerSettings();
            loadColumnSizes();
            loadCollapsedStates();
            loadTheme();
            fullRender();
            
            makeResizable(document.getElementById('resizer1'), document.getElementById('panelClients'), document.getElementById('panelAppointments'));
            makeResizable(document.getElementById('resizer2'), document.getElementById('panelAppointments'), document.getElementById('panelSession'));
            makeResizable(document.getElementById('resizer3'), document.getElementById('panelSession'), document.getElementById('panelSoap'));
            makeResizable(document.getElementById('resizer-session-notes'), document.getElementById('sessionInfoWrapper'), document.getElementById('notesWrapper'), 'y');

        });
    </script>
</body>
</html>

