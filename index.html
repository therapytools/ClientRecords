<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mental Health Client Data Organizer</title>
    <style>
        :root {
            --bg-main: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --bg-container: white;
            --text-color-primary: #2c3e50;
            --text-color-secondary: #7f8c8d;
            --text-color-inverted: white;
            --panel-bg: #fafafa;
            --panel-border: #ecf0f1;
            --panel-footer-bg: #fdfdfd;
            --panel-header-bg: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            --item-bg: white;
            --item-active-bg: #e3f2fd;
            --item-border-color: #3498db;
            --item-active-border-color: #2196f3;
            --textarea-bg: white;
            --textarea-border: #ddd;
            --textarea-focus-border: #3498db;
            --textarea-focus-shadow: rgba(52, 152, 219, 0.2);
            --modal-bg: white;
            --modal-text: #333;
            --modal-header-border: #ccc;
            --input-bg: white;
            --input-text: #333;
            --input-border: #ccc;
            --suggestion-bg: #fff5f5;
            --suggestion-border: #e53e3e;
            --suggestion-text: #c53030;
            --resizer-bg: #ecf0f1;
            --deleted-item-text: #000;
        }

        [data-theme="dark"] {
            --bg-main: linear-gradient(135deg, #2c3e50 0%, #1a2533 100%);
            --bg-container: #2d3748;
            --text-color-primary: #e2e8f0;
            --text-color-secondary: #a0aec0;
            --text-color-inverted: #e2e8f0; /* Changed for better contrast on dark headers */
            --panel-bg: #283141;
            --panel-border: #4a5568;
            --panel-footer-bg: #232b38;
            --panel-header-bg: linear-gradient(135deg, #1a2533 0%, #2c3e50 100%);
            --item-bg: #4a5568;
            --item-active-bg: #718096;
            --item-border-color: #63b3ed;
            --item-active-border-color: #90cdf4;
            --appointment-item-active-bg: #5a4a63; /* Dark mode specific */
            --appointment-item-active-border: #c084fc; /* Dark mode specific */
            --textarea-bg: #2d3748;
            --textarea-border: #4a5568;
            --textarea-focus-border: #63b3ed;
            --textarea-focus-shadow: rgba(99, 179, 237, 0.3);
            --modal-bg: #2d3748;
            --modal-text: #e2e8f0;
            --modal-header-border: #4a5568;
            --input-bg: #4a5568;
            --input-text: #e2e8f0;
            --input-border: #718096;
            --suggestion-bg: #4c3030;
            --suggestion-border: #e53e3e;
            --suggestion-text: #fed7d7;
            --resizer-bg: #4a5568;
            --deleted-item-text: #e2e8f0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-main);
            min-height: 100vh;
            padding: 10px;
            overflow: hidden;
            color: var(--text-color-primary);
        }

        .container {
            width: 100%;
            margin: 0 auto;
            background: var(--bg-container);
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
            height: calc(100vh - 20px);
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: var(--text-color-inverted);
            padding: 12px 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }
        
        .header h1 {
            font-size: 1.5rem;
            margin-right: auto;
        }

        .btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        .btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }

        .btn.settings-btn {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
        }

        .btn.save-btn {
             background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        }

        .btn.theme-btn {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            padding: 0;
        }

        .main-content {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }

        .panel {
            border-right: 2px solid var(--panel-border);
            background: var(--panel-bg);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex-grow: 1; /* Allow panels to grow/shrink */
            flex-shrink: 1;
        }

        .panel:last-child {
            border-right: none;
        }
        
        .clients-panel { flex-basis: 20%; min-width: 180px; }
        .appointments-panel { flex-basis: 20%; min-width: 180px;}
        .session-panel { flex-basis: 30%; display: flex; flex-direction: column; min-width: 250px; }
        .soap-panel { flex-basis: 30%; min-width: 250px;}


        .panel-header {
            background: var(--panel-header-bg);
            color: var(--text-color-inverted);
            padding: 12px 15px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            height: 50px;
            min-height: 50px;
        }

        .add-btn {
            background: #27ae60;
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .add-btn:hover {
            background: #229954;
            transform: scale(1.1);
        }
        
        .add-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }

        .panel-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        .panel-footer {
            padding: 10px;
            border-top: 1px solid var(--panel-border);
            background: var(--panel-footer-bg);
            flex-shrink: 0;
        }
        
        input[type="date"] {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--input-border);
            border-radius: 4px;
            font-size: 14px;
            font-family: inherit;
            background-color: var(--input-bg);
            color: var(--input-text);
        }

        /* Client Panel */
        .client-item {
            background: var(--item-bg);
            margin-bottom: 8px;
            padding: 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 4px solid var(--item-border-color);
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .client-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .client-item.active {
            background: var(--item-active-bg);
            border-left-color: var(--item-active-border-color);
            font-weight: bold;
        }
        
        .client-item.dragging {
            opacity: 0.5;
        }
        
        .action-buttons {
            position: absolute;
            top: 5px; right: 5px;
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }
        .client-item:hover .action-buttons, .appointment-item:hover .action-buttons {
            opacity: 1;
        }
        .action-btn {
            border: none; color: white;
            width: 20px; height: 20px;
            border-radius: 50%;
            cursor: pointer; font-size: 12px;
            display: flex; align-items: center; justify-content: center;
        }
        .archive-btn { background: #f39c12; }
        .delete-btn { background: #e74c3c; }
        .edit-btn { background: #3498db; }

        /* Appointments Panel */
        .appointment-item {
            background: var(--item-bg); margin-bottom: 8px; padding: 10px;
            border-radius: 6px; cursor: pointer; transition: all 0.2s ease;
            border-left: 4px solid #9b59b6; position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .appointment-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
        }
        .appointment-item.active {
            background: var(--appointment-item-active-bg, #f3e5f5);
            border-left-color: var(--appointment-item-active-border, #9c27b0);
        }
        .appointment-date { font-weight: 600; color: var(--text-color-primary); }

        /* Session and SOAP Panels */
        textarea {
            width: 100%; border: 1px solid var(--textarea-border); border-radius: 6px;
            padding: 12px; font-family: inherit; font-size: 14px;
            resize: both; /* Allow vertical and horizontal resizing */
            transition: all 0.2s;
            min-height: 50px; /* Ensure a minimum height */
            overflow: auto; /* Show scrollbars when content overflows */
            background-color: var(--textarea-bg);
            color: var(--text-color-primary);
        }
        textarea:focus {
            outline: none; border-color: var(--textarea-focus-border);
            box-shadow: 0 0 0 2px var(--textarea-focus-shadow);
        }
        
        .session-section {
            display: flex; flex-direction: column;
            flex-grow: 1; min-height: 0;
        }
        .session-section .panel-header {
             background: linear-gradient(135deg, #16a085 0%, #138d75 100%);
        }
        .session-section .panel-content {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
        }
        .session-section textarea {
            flex-grow: 1;
        }
        .persistent-notes-section .panel-header {
             background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }
        
        .goals-section .panel-header {
             background: linear-gradient(135deg, #8e44ad 0%, #9b59b6 100%);
        }

        /* Collapsible Section Styles */
        .collapsible-header {
            cursor: pointer;
            user-select: none;
        }

        .collapsible-header:hover {
            opacity: 0.9;
        }

        .collapse-icon {
            transition: transform 0.3s ease;
            font-size: 0.8rem;
            margin-left: 8px;
        }

        .collapse-icon.collapsed {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .collapsible-content.collapsed {
            flex-basis: 0 !important;
            min-height: 0 !important;
            opacity: 0;
        }

        .collapsible-content .panel-content {
            transition: opacity 0.2s ease;
        }

        .collapsible-content.collapsed .panel-content {
            opacity: 0;
        }

        /* Goals Section Scrolling */
        .goals-section .panel-content {
            overflow-y: auto;
            max-height: 100%;
        }

        /* Goals and Objectives Styling */
        .goal-item {
            background: var(--item-bg);
            margin-bottom: 12px;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid #8e44ad;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        .goal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .goal-title {
            font-weight: 600;
            color: var(--text-color-primary);
            flex-grow: 1;
            margin-right: 8px;
        }

        .goal-actions {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        .goal-item:hover .goal-actions {
            opacity: 1;
        }

        .goal-status {
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-right: 8px;
        }

        .goal-status.active {
            background: #d4edda;
            color: #155724;
        }

        .goal-status.completed {
            background: #cce5ff;
            color: #004085;
        }

        .goal-status.discontinued {
            background: #f8d7da;
            color: #721c24;
        }

        .objective-list {
            margin-top: 8px;
            padding-left: 16px;
        }

        .objective-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            font-size: 0.9rem;
        }

        .objective-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .objective-text {
            flex-grow: 1;
            color: var(--text-color-primary);
        }

        .objective-text.completed {
            text-decoration: line-through;
            color: var(--text-color-secondary);
        }

        .add-objective-btn {
            background: none;
            border: 1px dashed #8e44ad;
            color: #8e44ad;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            margin-top: 8px;
            width: 100%;
        }

        .add-objective-btn:hover {
            background: rgba(142, 68, 173, 0.1);
        }

        .soap-section { margin-bottom: 15px; }
        .soap-header {
            background: linear-gradient(135deg, #5D6D7E 0%, #34495E 100%);
            color: var(--text-color-inverted); padding: 8px 12px;
            border-radius: 6px 6px 0 0; font-weight: 600;
            display: flex; justify-content: space-between; align-items: center;
        }
        .copy-btn {
            background: rgba(255, 255, 255, 0.2); border: none; color: var(--text-color-inverted);
            padding: 4px 8px; border-radius: 4px; cursor: pointer;
            font-size: 12px; transition: all 0.2s;
        }
        .copy-btn:hover { background: rgba(255, 255, 255, 0.3); }
        .soap-textarea {
            border-radius: 0 0 6px 6px; border-top: none;
            flex-grow: 1;
            /* overflow-y: hidden; is removed to allow manual resize */
        }

        .suggestion-box {
            background-color: var(--suggestion-bg);
            border: 1px solid var(--suggestion-border);
            border-radius: 6px;
            padding: 10px;
            margin-top: 8px;
            font-size: 14px;
        }
        .suggestion-text {
            color: var(--suggestion-text);
            margin-bottom: 8px;
        }
        .suggestion-actions button {
            background: none;
            border: 1px solid;
            border-radius: 4px;
            padding: 2px 8px;
            font-size: 12px;
            cursor: pointer;
            margin-right: 5px;
        }
        .suggestion-accept { color: #27ae60; border-color: #27ae60; }
        .suggestion-accept-replace { color: #27ae60; border-color: #27ae60; }
        .suggestion-decline { color: #e74c3c; border-color: #e74c3c; }

        .no-selection {
            color: var(--text-color-secondary); text-align: center;
            margin-top: 50px; font-style: italic;
        }
        .autosave-indicator { color: var(--text-color-inverted); font-size: 12px; margin-left: auto; }
        
        .deleted-list { max-height: 100px; overflow-y: auto; }
        .deleted-item { display: flex; justify-content: space-between; align-items: center; font-size: 0.8rem; padding: 2px 0; color: var(--deleted-item-text); }
        .restore-btn {
             background: #3498db; color: white; border: none;
             padding: 2px 6px; border-radius: 4px; cursor: pointer;
        }
        .clear-deleted-btn {
            background: #e74c3c; color: white; border: none;
            padding: 2px 6px; border-radius: 4px; cursor: pointer;
            width: 100%; margin-top: 5px;
        }

        .resizer {
            background: var(--resizer-bg);
            cursor: col-resize;
            width: 6px;
            flex-shrink: 0;
            z-index: 10;
        }
        .resizer-y {
            background: var(--resizer-bg);
            cursor: row-resize;
            height: 6px;
            flex-shrink: 0;
            z-index: 10;
        }
        
        .hidden {
            display: none !important;
        }
        
        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: var(--modal-bg);
            padding: 24px;
            border-radius: 12px;
            width: 100%;
            max-width: 512px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            position: relative; /* For the close button */
            color: var(--modal-text);
        }


    </style>
</head>
<body data-theme="light">
    <div class="container">
        <div class="header">
            <h1>Client Data Organizer <span style="font-size: 0.8rem; font-weight: normal; vertical-align: middle;">v.0.0.30</span></h1>
            <div id="autoSaveIndicator" class="autosave-indicator" style="opacity: 0;">
                <span id="saveStatus"></span>
            </div>
            <button id="manualSaveBtn" class="btn save-btn">Save Now</button>
            <button id="settingsBtn" class="btn settings-btn">Settings</button>
            <button id="themeToggleBtn" class="btn theme-btn" title="Toggle Theme">üåô</button>
        </div>

        <div class="main-content" id="mainGrid">
            <!-- Clients Panel -->
            <div class="panel clients-panel" id="panelClients">
                <div class="panel-header">
                    <span>Clients</span>
                    <div style="display: flex; align-items: center;">
                        <button id="sortClientsBtn" title="Sort A-Z" class="btn" style="padding: 2px 6px; font-size: 12px; margin-right: 8px;">A-Z</button>
                        <button id="addClientBtn" class="add-btn">+</button>
                    </div>
                </div>
                <div class="panel-content" id="clientList">
                    <div class="no-selection">Click + to add a client</div>
                </div>
                <div class="panel-footer">
                     <h3 style="color: var(--text-color-secondary); font-weight: 600; margin-bottom: 0.5rem; font-size: 0.875rem;">Recently Deleted</h3>
                     <div id="deletedClientsList" class="deleted-list"></div>
                     <button id="clearDeletedClientsBtn" class="clear-deleted-btn hidden">Clear All</button>
                </div>
                 <div class="panel-footer">
                     <h3 style="color: var(--text-color-secondary); font-weight: 600; margin-bottom: 0.5rem; font-size: 0.875rem;">Archived</h3>
                     <div id="archivedClientsList" class="deleted-list"></div>
                </div>
            </div>

            <div class="resizer" id="resizer1"></div>

            <!-- Appointments Panel -->
            <div class="panel appointments-panel" id="panelAppointments">
                <div class="panel-header">
                    <span>Appointments</span>
                </div>
                <div class="panel-content" id="appointmentList">
                    <div class="no-selection">Select a client first</div>
                </div>
                <div class="panel-footer">
                     <label for="appointmentDateInput" style="font-weight: 600; color: var(--text-color-secondary); font-size: 0.875rem; margin-bottom: 4px; display: block;">Appointment Date</label>
                     <div style="display: flex; align-items: center; gap: 8px;">
                         <input type="date" id="appointmentDateInput" style="flex-grow: 1;">
                         <button class="add-btn" id="addAppointmentBtn" disabled>+</button>
                         <button id="updateAppointmentDateBtn" class="btn hidden" style="padding: 4px 8px; font-size: 0.8rem;">Update</button>
                     </div>
                </div>
                 <div class="panel-footer">
                     <h3 style="color: var(--text-color-secondary); font-weight: 600; margin-bottom: 0.5rem; font-size: 0.875rem;">Recently Deleted</h3>
                     <div id="deletedAppointmentsList" class="deleted-list"></div>
                     <button id="clearDeletedAppointmentsBtn" class="clear-deleted-btn hidden">Clear All</button>
                </div>
            </div>

            <div class="resizer" id="resizer2"></div>

            <!-- Session & Notes Panel -->
            <div class="panel session-panel" id="panelSession">
                 <div id="sessionInfoWrapper" class="session-section" style="flex-basis: 33.33%;">
                     <div class="panel-header">
                         <span>Session Information</span>
                         <button id="generateNoteBtn" class="btn" style="padding: 4px 8px; font-size: 0.8rem;" disabled>Generate Note</button>
                     </div>
                     <div class="panel-content">
                         <textarea id="sessionInfo" placeholder="Select an appointment to enter session details..." disabled autocorrect="off" autocapitalize="off" spellcheck="true"></textarea>
                     </div>
                     <div class="panel-footer" id="sessionTimerWrapper" style="display: none;">
                         <div style="display: flex; justify-content: space-between; align-items: center; gap: 10px;">
                             <button id="startTimerBtn" class="btn" style="flex-grow: 1;">Start</button>
                             <button id="stopTimerBtn" class="btn" style="flex-grow: 1;">Stop</button>
                             <div id="sessionDuration" style="font-weight: 600; white-space: nowrap;">00:00</div>
                         </div>
                     </div>
                 </div>
                 <div class="resizer-y" id="resizer-session-goals"></div>
                 <div id="goalsWrapper" class="session-section goals-section" style="flex-basis: 33.33%;">
                     <div class="panel-header collapsible-header" data-target="goalsContent">
                         <span>Treatment Goals <span class="collapse-icon">‚ñº</span></span>
                         <button id="addGoalBtn" class="add-btn" disabled>+</button>
                     </div>
                     <div id="goalsContent" class="panel-content collapsible-content" id="goalsList">
                         <div class="no-selection">Select a client to manage goals</div>
                     </div>
                 </div>
                 <div class="resizer-y" id="resizer-goals-notes"></div>
                 <div id="notesWrapper" class="session-section persistent-notes-section" style="flex-basis: 33.33%;">
                     <div class="panel-header collapsible-header" data-target="notesContent">
                         <span>Persistent Notes <span class="collapse-icon">‚ñº</span></span>
                     </div>
                     <div id="notesContent" class="panel-content collapsible-content">
                         <textarea id="persistentNotes" placeholder="Select a client to enter persistent notes..." disabled autocorrect="off" autocapitalize="off" spellcheck="true"></textarea>
                     </div>
                 </div>
            </div>

            <div class="resizer" id="resizer3"></div>

            <!-- SOAP Notes Panel -->
            <div class="panel soap-panel" id="panelSoap">
                <div class="panel-header">
                    <span>SOAP Note</span>
                </div>
                <div class="panel-content" id="soapContent">
                    <div class="no-selection">Select an appointment to begin</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div id="settingsModal" class="modal-overlay hidden">
        <div class="modal-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid var(--modal-header-border);">
                <h2 style="font-size: 1.5rem; font-weight: bold;">Settings</h2>
                <button id="closeSettingsBtn" style="font-size: 2rem; background: none; border: none; cursor: pointer; color: inherit;">&times;</button>
            </div>

            <div style="margin-bottom: 1.5rem;">
                <h3 style="font-size: 1.25rem; font-weight: 600; margin-bottom: 0.75rem;">Connection</h3>
                <div style="display: flex; flex-direction: column; gap: 1rem;">
                    <div>
                        <label for="apiProviderSelect" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">API Provider</label>
                        <select id="apiProviderSelect" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);">
                            <option value="openwebui">Open WebUI</option>
                            <option value="gemini">Google Gemini</option>
                            <option value="openai">OpenAI</option>
                        </select>
                    </div>

                    <div id="openwebuiSettings">
                        <div>
                            <label for="serverAddressInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">Open WebUI Address</label>
                            <input type="text" id="serverAddressInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);" placeholder="e.g., http://localhost:3000">
                        </div>
                        <div>
                            <label for="apiKeyInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">API Key (optional)</label>
                            <input type="password" id="apiKeyInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);">
                        </div>
                    </div>

                    <div id="geminiSettings" class="hidden">
                        <div>
                            <label for="geminiApiKeyInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">Gemini API Key</label>
                            <input type="password" id="geminiApiKeyInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);">
                        </div>
                         <div>
                            <label for="geminiModelInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">Gemini Model</label>
                            <select id="geminiModelInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);" disabled>
                                <option>Enter API Key first</option>
                            </select>
                        </div>
                    </div>
                    
                    <div id="openaiSettings" class="hidden">
                        <div>
                            <label for="openaiApiKeyInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">OpenAI API Key</label>
                            <input type="password" id="openaiApiKeyInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);">
                        </div>
                        <div>
                            <label for="openaiModelInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">OpenAI Model</label>
                            <select id="openaiModelInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);" disabled>
                                <option>Enter API Key first</option>
                            </select>
                        </div>
                    </div>

                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <button id="connectApiBtn" class="btn">Connect</button>
                        <span id="apiStatus" style="font-size: 0.875rem; font-weight: 600;"></span>
                    </div>
                    <div id="modelSelectWrapper">
                         <label for="modelSelect" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">AI Model</label>
                         <select id="modelSelect" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);" disabled>
                            <option>Connect to server first</option>
                        </select>
                    </div>
                </div>
            </div>

            <div style="margin-bottom: 1.5rem;">
                <h3 style="font-size: 1.25rem; font-weight: 600; margin-bottom: 0.75rem;">Data Management</h3>
                <div style="display: flex; flex-wrap: wrap; gap: 1rem;">
                     <button id="exportBtn" class="btn">Export Data</button>
                     <button id="importBtn" class="btn" style="background: linear-gradient(135deg, #7f8c8d 0%, #95a5a6 100%);">Import Data</button>
                     <button id="eraseAllBtn" class="btn save-btn">Erase All Data</button>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" class="hidden" accept="application/json">

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const clientListEl = document.getElementById('clientList');
            const addClientBtn = document.getElementById('addClientBtn');
            const sortClientsBtn = document.getElementById('sortClientsBtn');
            const appointmentListEl = document.getElementById('appointmentList');
            const addAppointmentBtn = document.getElementById('addAppointmentBtn');
            const appointmentDateInput = document.getElementById('appointmentDateInput');
            const updateAppointmentDateBtn = document.getElementById('updateAppointmentDateBtn');
            const deletedClientsListEl = document.getElementById('deletedClientsList');
            const clearDeletedClientsBtn = document.getElementById('clearDeletedClientsBtn');
            const archivedClientsListEl = document.getElementById('archivedClientsList');
            const deletedAppointmentsListEl = document.getElementById('deletedAppointmentsList');
            const clearDeletedAppointmentsBtn = document.getElementById('clearDeletedAppointmentsBtn');
            const persistentNotesEl = document.getElementById('persistentNotes');
            const sessionInfoEl = document.getElementById('sessionInfo');
            const soapContentEl = document.getElementById('soapContent');
            const autoSaveIndicator = document.getElementById('autoSaveIndicator');
            const saveStatus = document.getElementById('saveStatus');
            // Session Timer Elements
            const sessionTimerWrapper = document.getElementById('sessionTimerWrapper');
            const startTimerBtn = document.getElementById('startTimerBtn');
            const stopTimerBtn = document.getElementById('stopTimerBtn');
            const sessionDurationEl = document.getElementById('sessionDuration');
            // Settings and Modal Elements
            const settingsBtn = document.getElementById('settingsBtn');
            const settingsModal = document.getElementById('settingsModal');
            const closeSettingsBtn = document.getElementById('closeSettingsBtn');
            const manualSaveBtn = document.getElementById('manualSaveBtn');
            const exportBtn = document.getElementById('exportBtn');
            const importBtn = document.getElementById('importBtn');
            const eraseAllBtn = document.getElementById('eraseAllBtn');
            // AI Integration Elements
            const apiProviderSelect = document.getElementById('apiProviderSelect');
            const openwebuiSettings = document.getElementById('openwebuiSettings');
            const serverAddressInput = document.getElementById('serverAddressInput');
            const apiKeyInput = document.getElementById('apiKeyInput');
            const geminiSettings = document.getElementById('geminiSettings');
            const geminiApiKeyInput = document.getElementById('geminiApiKeyInput');
            const geminiModelInput = document.getElementById('geminiModelInput');
            const openaiSettings = document.getElementById('openaiSettings');
            const openaiApiKeyInput = document.getElementById('openaiApiKeyInput');
            const openaiModelInput = document.getElementById('openaiModelInput');
            const connectApiBtn = document.getElementById('connectApiBtn');
            const apiStatus = document.getElementById('apiStatus');
            const modelSelect = document.getElementById('modelSelect');
            const modelSelectWrapper = document.getElementById('modelSelectWrapper');
            const generateNoteBtn = document.getElementById('generateNoteBtn');
            const fileInput = document.getElementById('fileInput');
            const themeToggleBtn = document.getElementById('themeToggleBtn');
            // Goals Elements
            const goalsListEl = document.getElementById('goalsContent');
            const addGoalBtn = document.getElementById('addGoalBtn');

            // App State
            let data = { clients: [], archivedClients: [] };
            let deletedItems = { clients: [], appointments: [] };
            let selectedClientId = null;
            let selectedAppointmentId = null;
            let isDirty = false;
            let apiProvider = 'openwebui';
            let serverAddress = null;
            let apiKey = null;
            let geminiApiKey = null;
            let openaiApiKey = null;
            let selectedModel = null;
            let sessionTimerInterval = null;
            const getInitialData = () => ({ clients: [], archivedClients: [] });

            // --- Data Management ---
            const findClient = id => data.clients.find(c => c.id === id) || data.archivedClients.find(c => c.id === id);
            const findAppointment = (client, id) => client?.appointments.find(a => a.id === id);
            
            // --- UI Rendering ---
            const renderClients = () => {
                // Note: Drag and drop reordering means we can't sort here anymore.
                // The array order is now the source of truth for display order.
                const clients = data.clients; 
                if (clients.length === 0) {
                    clientListEl.innerHTML = '<div class="no-selection">Click + to add a client</div>';
                    return;
                }
                clientListEl.innerHTML = clients.map(client => `
                    <div class="client-item ${client.id === selectedClientId ? 'active' : ''}" data-client-id="${client.id}" draggable="true">
                        ${client.name}
                        <div class="action-buttons">
                            <button class="action-btn edit-btn" title="Edit Name">‚úèÔ∏è</button>
                            <button class="action-btn archive-btn" title="Archive Client">A</button>
                            <button class="action-btn delete-btn" title="Delete Client">√ó</button>
                        </div>
                    </div>
                `).join('');
            };

            const renderAppointments = () => {
                const client = findClient(selectedClientId);
                addAppointmentBtn.disabled = !client;
                if (!client) {
                    appointmentListEl.innerHTML = '<div class="no-selection">Select a client first</div>';
                    return;
                }
                const appointments = (client.appointments || []).sort((a, b) => new Date(b.date) - new Date(a.date));
                if (appointments.length === 0) {
                    appointmentListEl.innerHTML = '<div class="no-selection">Click + to add appointment</div>';
                    return;
                }
                appointmentListEl.innerHTML = appointments.map(appt => `
                    <div class="appointment-item ${appt.id === selectedAppointmentId ? 'active' : ''}" data-appointment-id="${appt.id}">
                        <div class="appointment-date">${new Date(appt.date).toLocaleDateString()}</div>
                        <div class="action-buttons">
                            <button class="action-btn delete-btn" title="Delete Appointment">√ó</button>
                        </div>
                    </div>
                `).join('');
            };

            const renderDetails = () => {
                const client = findClient(selectedClientId);
                const appointment = client ? findAppointment(client, selectedAppointmentId) : null;
                
                persistentNotesEl.disabled = !client;
                persistentNotesEl.value = client ? client.persistentNotes || '' : '';
                persistentNotesEl.placeholder = client ? "Enter persistent notes for this client..." : "Select a client to enter persistent notes...";

                sessionInfoEl.disabled = !appointment;
                sessionInfoEl.value = appointment ? appointment.sessionInfo || '' : '';
                sessionInfoEl.placeholder = appointment ? "Enter session details..." : "Select an appointment to begin...";
                
                updateAppointmentDateBtn.classList.toggle('hidden', !appointment);
                addAppointmentBtn.classList.toggle('hidden', !!appointment);

                sessionTimerWrapper.style.display = appointment ? 'block' : 'none';
                if (appointment) {
                    renderSessionTimer(appointment);
                }

                renderGoals();
                renderSoap();
                
                generateNoteBtn.disabled = !appointment || !selectedModel || !sessionInfoEl.value.trim();
            };

            const renderGoals = () => {
                const client = findClient(selectedClientId);
                const goalsContentEl = document.getElementById('goalsContent');
                addGoalBtn.disabled = !client;
                
                if (!client) {
                    goalsContentEl.innerHTML = '<div class="no-selection">Select a client to manage goals</div>';
                    return;
                }

                if (!client.goals) {
                    client.goals = [];
                }

                if (client.goals.length === 0) {
                    goalsContentEl.innerHTML = '<div class="no-selection">Click + to add a treatment goal</div>';
                    return;
                }

                goalsContentEl.innerHTML = client.goals.map(goal => `
                    <div class="goal-item" data-goal-id="${goal.id}">
                        <div class="goal-header">
                            <div class="goal-title">${goal.title}</div>
                            <div style="display: flex; align-items: center;">
                                <div class="goal-status ${goal.status}">${goal.status.charAt(0).toUpperCase() + goal.status.slice(1)}</div>
                                <div class="goal-actions">
                                    <button class="action-btn edit-btn" title="Edit Goal">‚úèÔ∏è</button>
                                    <button class="action-btn archive-btn" title="Change Status">‚ö°</button>
                                    <button class="action-btn delete-btn" title="Delete Goal">√ó</button>
                                </div>
                            </div>
                        </div>
                        <div class="objective-list">
                            ${(goal.objectives || []).map(obj => `
                                <div class="objective-item" data-objective-id="${obj.id}">
                                    <input type="checkbox" class="objective-checkbox" ${obj.completed ? 'checked' : ''}>
                                    <span class="objective-text ${obj.completed ? 'completed' : ''}">${obj.text}</span>
                                    <button class="action-btn delete-btn" title="Delete Objective" style="opacity: 0; width: 16px; height: 16px; font-size: 10px;">√ó</button>
                                </div>
                            `).join('')}
                            <button class="add-objective-btn" data-goal-id="${goal.id}">+ Add Objective</button>
                        </div>
                    </div>
                `).join('');
            };
            
            const renderSessionTimer = (appointment) => {
                clearInterval(sessionTimerInterval);

                if (appointment.startTime) {
                    startTimerBtn.textContent = `Start: ${new Date(appointment.startTime).toLocaleTimeString()}`;
                } else {
                    startTimerBtn.textContent = 'Start';
                }

                if (appointment.endTime) {
                    stopTimerBtn.textContent = `End: ${new Date(appointment.endTime).toLocaleTimeString()}`;
                } else {
                    stopTimerBtn.textContent = 'Stop';
                }

                const updateDuration = () => {
                    if (!appointment.startTime) {
                        sessionDurationEl.textContent = '00:00';
                        return;
                    }
                    
                    const start = new Date(appointment.startTime);
                    const end = appointment.endTime ? new Date(appointment.endTime) : new Date();
                    
                    let totalSeconds = Math.floor((end - start) / 1000);
                    if (totalSeconds < 0) totalSeconds = 0;

                    const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
                    const seconds = (totalSeconds % 60).toString().padStart(2, '0');
                    
                    sessionDurationEl.textContent = `${minutes}:${seconds}`;
                };

                updateDuration();

                // If the timer is running (start time exists but no end time), set an interval to update it.
                if (appointment.startTime && !appointment.endTime) {
                    sessionTimerInterval = setInterval(updateDuration, 1000);
                }
            };

            const renderSoap = () => {
                const client = findClient(selectedClientId);
                const appointment = client ? findAppointment(client, selectedAppointmentId) : null;

                if (!appointment) {
                    soapContentEl.innerHTML = '<div class="no-selection">Select an appointment to begin</div>';
                    return;
                }

                const soapData = appointment.soap || { s: '', o: '', a: '', p: '' };
                const interventions = soapData.interventions || 'No interventions identified.';
                soapContentEl.innerHTML = `
                    <div class="soap-section">
                        <div class="soap-header"><span>Subjective</span><button class="copy-btn" data-target="soapS">Copy</button></div>
                        <textarea id="soapS" class="soap-textarea" placeholder="‚Ä¢ " autocorrect="off" autocapitalize="off" spellcheck="true">${soapData.s || ''}</textarea>
                        ${(soapData.s_suggestion || []).map((s, i) => renderSuggestionBox('s', s, i)).join('')}
                    </div>
                    <div class="soap-section">
                        <div class="soap-header"><span>Objective</span><button class="copy-btn" data-target="soapO">Copy</button></div>
                        <textarea id="soapO" class="soap-textarea" placeholder="‚Ä¢ " autocorrect="off" autocapitalize="off" spellcheck="true">${soapData.o || ''}</textarea>
                        ${(soapData.o_suggestion || []).map((s, i) => renderSuggestionBox('o', s, i)).join('')}
                    </div>
                    <div class="soap-section">
                        <div class="soap-header"><span>Assessment</span><button class="copy-btn" data-target="soapA">Copy</button></div>
                        <textarea id="soapA" class="soap-textarea" placeholder="‚Ä¢ " autocorrect="off" autocapitalize="off" spellcheck="true">${soapData.a || ''}</textarea>
                        ${(soapData.a_suggestion || []).map((s, i) => renderSuggestionBox('a', s, i)).join('')}
                    </div>
                    <div class="soap-section">
                        <div class="soap-header"><span>Plan</span><button class="copy-btn" data-target="soapP">Copy</button></div>
                        <textarea id="soapP" class="soap-textarea" placeholder="‚Ä¢ " autocorrect="off" autocapitalize="off" spellcheck="true">${soapData.p || ''}</textarea>
                        ${(soapData.p_suggestion || []).map((s, i) => renderSuggestionBox('p', s, i)).join('')}
                    </div>
                    <div class="soap-section">
                        <div class="soap-header"><span>Interventions</span><button class="copy-btn" data-target="interventions">Copy</button></div>
                        <textarea id="interventions" class="soap-textarea" autocorrect="off" autocapitalize="off" spellcheck="true">${interventions}</textarea>
                    </div>`;
                
                // After rendering, resize all textareas
                soapContentEl.querySelectorAll('.soap-textarea').forEach(el => {
                    if (!el.readOnly) { // Don't auto-resize the read-only interventions box
                        autoResizeTextarea(el);
                    }
                });
            };

            const renderSuggestionBox = (type, suggestion, index) => {
                if (!suggestion) return '';

                let suggestionTitle;
                let suggestionContent;
                let actionsHtml;

                const isReplacement = typeof suggestion === 'object' && suggestion.original && suggestion.suggested;

                if (isReplacement) {
                    suggestionTitle = 'Clinical Language Suggestion:';
                    suggestionContent = `
                        <div><strong>Original:</strong> ${suggestion.original}</div>
                        <div style="margin-top: 4px;"><strong>Suggested:</strong> ${suggestion.suggested}</div>
                    `;
                    actionsHtml = `
                        <button class="suggestion-decline">Keep Original</button>
                        <button class="suggestion-accept-replace">Use Suggestion</button>
                    `;
                } else { // It's a new suggestion (string)
                    suggestionTitle = 'Suggestion for Addition:';
                    suggestionContent = `<strong>${suggestionTitle}</strong> ${suggestion}`;
                    actionsHtml = `
                        <button class="suggestion-accept">Accept</button>
                        <button class="suggestion-decline">Decline</button>
                    `;
                }

                return `
                    <div class="suggestion-box" data-suggestion-type="${type}" data-suggestion-index="${index}">
                        <div class="suggestion-text">${suggestionContent}</div>
                        <div class="suggestion-actions">
                            ${actionsHtml}
                        </div>
                    </div>
                `;
            };

            const renderDeletedLists = () => {
                deletedClientsListEl.innerHTML = '';
                clearDeletedClientsBtn.classList.toggle('hidden', deletedItems.clients.length === 0);
                deletedItems.clients.forEach(client => {
                    const div = document.createElement('div');
                    div.className = 'deleted-item';
                    div.innerHTML = `<span>${client.name}</span><button class="restore-btn" data-id="${client.id}">Restore</button>`;
                    deletedClientsListEl.appendChild(div);
                });

                deletedAppointmentsListEl.innerHTML = '';
                 clearDeletedAppointmentsBtn.classList.toggle('hidden', deletedItems.appointments.length === 0);
                deletedItems.appointments.forEach(appt => {
                    const clientName = findClient(appt.clientId)?.name?.substring(0, 5) + '...' || 'N/A';
                    const div = document.createElement('div');
                    div.className = 'deleted-item';
                    div.innerHTML = `<span>${new Date(appt.date).toLocaleDateString()} (${clientName})</span><button class="restore-btn" data-id="${appt.id}">Restore</button>`;
                    deletedAppointmentsListEl.appendChild(div);
                });
            };

            const renderArchivedClients = () => {
                archivedClientsListEl.innerHTML = '';
                (data.archivedClients || []).forEach(client => {
                     const div = document.createElement('div');
                     div.className = 'deleted-item';
                     div.innerHTML = `<span>${client.name}</span><button class="restore-btn" data-id="${client.id}">Unarchive</button>`;
                     archivedClientsListEl.appendChild(div);
                });
            };

            const fullRender = () => {
                renderClients();
                renderAppointments();
                renderDetails();
                renderDeletedLists();
                renderArchivedClients();
            };

            // --- Event Handlers & Actions ---
            const selectClient = (id) => {
                selectedClientId = id;
                selectedAppointmentId = null;
                clearInterval(sessionTimerInterval); // Stop timer when switching clients
                fullRender();
            };

            const selectAppointment = (id) => {
                selectedAppointmentId = id;
                fullRender();
            };

            const addGoal = () => {
                const client = findClient(selectedClientId);
                if (!client) return;
                
                const title = prompt("Enter goal title:");
                if (!title || !title.trim()) return;
                
                const newGoal = {
                    id: crypto.randomUUID(),
                    title: title.trim(),
                    status: 'active',
                    objectives: [],
                    dateCreated: new Date().toISOString()
                };
                
                if (!client.goals) client.goals = [];
                client.goals.push(newGoal);
                markDirty();
                renderGoals();
            };

            const addObjective = (goalId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                
                const goal = client.goals.find(g => g.id === goalId);
                if (!goal) return;
                
                const text = prompt("Enter objective:");
                if (!text || !text.trim()) return;
                
                const newObjective = {
                    id: crypto.randomUUID(),
                    text: text.trim(),
                    completed: false,
                    dateCreated: new Date().toISOString()
                };
                
                if (!goal.objectives) goal.objectives = [];
                goal.objectives.push(newObjective);
                markDirty();
                renderGoals();
            };

            const toggleObjective = (goalId, objectiveId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                
                const goal = client.goals.find(g => g.id === goalId);
                if (!goal) return;
                
                const objective = goal.objectives.find(o => o.id === objectiveId);
                if (!objective) return;
                
                objective.completed = !objective.completed;
                if (objective.completed) {
                    objective.dateCompleted = new Date().toISOString();
                } else {
                    delete objective.dateCompleted;
                }
                
                markDirty();
                renderGoals();
            };

            const deleteGoal = (goalId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                
                const goalIndex = client.goals.findIndex(g => g.id === goalId);
                if (goalIndex === -1) return;
                
                const goal = client.goals[goalIndex];
                if (confirm(`Are you sure you want to delete the goal "${goal.title}"?`)) {
                    client.goals.splice(goalIndex, 1);
                    markDirty();
                    renderGoals();
                }
            };

            const deleteObjective = (goalId, objectiveId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                
                const goal = client.goals.find(g => g.id === goalId);
                if (!goal) return;
                
                const objIndex = goal.objectives.findIndex(o => o.id === objectiveId);
                if (objIndex === -1) return;
                
                goal.objectives.splice(objIndex, 1);
                markDirty();
                renderGoals();
            };

            const changeGoalStatus = (goalId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                
                const goal = client.goals.find(g => g.id === goalId);
                if (!goal) return;
                
                const statuses = ['active', 'completed', 'discontinued'];
                const currentIndex = statuses.indexOf(goal.status);
                const nextIndex = (currentIndex + 1) % statuses.length;
                
                goal.status = statuses[nextIndex];
                if (goal.status === 'completed') {
                    goal.dateCompleted = new Date().toISOString();
                } else {
                    delete goal.dateCompleted;
                }
                
                markDirty();
                renderGoals();
            };

            const editGoal = (goalId) => {
                const client = findClient(selectedClientId);
                if (!client) return;
                
                const goal = client.goals.find(g => g.id === goalId);
                if (!goal) return;
                
                const newTitle = prompt("Edit goal title:", goal.title);
                if (newTitle && newTitle.trim() && newTitle.trim() !== goal.title) {
                    goal.title = newTitle.trim();
                    markDirty();
                    renderGoals();
                }
            };

            const addClient = () => {
                const name = prompt("Enter new client's name:");
                if (!name || !name.trim()) return;
                const newClient = {
                    id: crypto.randomUUID(),
                    name: name.trim(),
                    persistentNotes: '',
                    appointments: [],
                    goals: []
                };
                data.clients.push(newClient);
                selectClient(newClient.id);
                markDirty();
            };

            const addAppointment = () => {
                const client = findClient(selectedClientId);
                if (!client) return;
                const date = appointmentDateInput.value;
                if (!date) {
                    alert('Please select a date for the appointment.');
                    return;
                }
                const dateObj = new Date(date);
                const utcDate = new Date(dateObj.getUTCFullYear(), dateObj.getUTCMonth(), dateObj.getUTCDate());

                const newAppointment = {
                    id: crypto.randomUUID(),
                    date: utcDate.toISOString(),
                    sessionInfo: '',
                    startTime: null,
                    endTime: null,
                    soap: { s: '', o: '', a: '', p: '' }
                };
                client.appointments.push(newAppointment);
                selectAppointment(newAppointment.id);
                markDirty();
            };
            
            clientListEl.addEventListener('click', (e) => {
                const clientItem = e.target.closest('.client-item');
                if (!clientItem) return;

                const clientId = clientItem.dataset.clientId;

                if (e.target.classList.contains('delete-btn')) {
                     const client = findClient(clientId);
                     if (confirm(`Are you sure you want to delete ${client.name}?`)) {
                        const clientIndex = data.clients.findIndex(c => c.id === clientId);
                        if (clientIndex === -1) return;
                        const [removedClient] = data.clients.splice(clientIndex, 1);
                        if (removedClient.appointments) {
                             deletedItems.appointments.push(...removedClient.appointments.map(a => ({...a, clientId})));
                        }
                        deletedItems.clients.push(removedClient);
                        if (selectedClientId === clientId) {
                            selectedClientId = null;
                            selectedAppointmentId = null;
                        }
                        markDirty();
                        fullRender();
                     }
                } else if (e.target.classList.contains('archive-btn')) {
                    const clientIndex = data.clients.findIndex(c => c.id === clientId);
                    if (clientIndex === -1) return;
                    const [client] = data.clients.splice(clientIndex, 1);
                    if (!data.archivedClients) data.archivedClients = [];
                    data.archivedClients.push(client);
                    if (selectedClientId === clientId) {
                        selectedClientId = null;
                        selectedAppointmentId = null;
                    }
                    markDirty();
                    fullRender();
                } else if (e.target.classList.contains('edit-btn')) {
                    const client = findClient(clientId);
                    if (!client) return;
                    const newName = prompt(`Enter new name for ${client.name}:`, client.name);
                    if (newName && newName.trim() && newName.trim() !== client.name) {
                        client.name = newName.trim();
                        markDirty();
                        fullRender();
                    }
                } else {
                    selectClient(clientId);
                }
            });

            // --- Drag and Drop Client Reordering ---
            let draggedClientId = null;

            clientListEl.addEventListener('dragstart', (e) => {
                const clientItem = e.target.closest('.client-item');
                if (clientItem) {
                    draggedClientId = clientItem.dataset.clientId;
                    // Add a class for visual feedback
                    setTimeout(() => clientItem.classList.add('dragging'), 0);
                }
            });

            clientListEl.addEventListener('dragend', (e) => {
                const clientItem = e.target.closest('.client-item');
                if (clientItem) {
                    clientItem.classList.remove('dragging');
                }
                draggedClientId = null;
            });

            clientListEl.addEventListener('dragover', (e) => {
                e.preventDefault(); // Necessary to allow dropping
                const targetItem = e.target.closest('.client-item');
                if (targetItem && targetItem.dataset.clientId !== draggedClientId) {
                    // This is where you could add a visual indicator if desired
                }
            });

            clientListEl.addEventListener('drop', (e) => {
                e.preventDefault();
                const targetItem = e.target.closest('.client-item');
                if (targetItem && draggedClientId) {
                    const targetId = targetItem.dataset.clientId;
                    
                    const draggedIndex = data.clients.findIndex(c => c.id === draggedClientId);
                    const targetIndex = data.clients.findIndex(c => c.id === targetId);

                    if (draggedIndex > -1 && targetIndex > -1) {
                        // Remove the dragged item
                        const [draggedItem] = data.clients.splice(draggedIndex, 1);
                        // Insert it at the target's position
                        data.clients.splice(targetIndex, 0, draggedItem);
                        
                        markDirty();
                        renderClients(); // Re-render to reflect the new order
                    }
                }
            });

            appointmentListEl.addEventListener('click', (e) => {
                 const appointmentItem = e.target.closest('.appointment-item');
                 if (!appointmentItem) {
                     selectAppointment(null);
                     return;
                 }

                 const appointmentId = appointmentItem.dataset.appointmentId;
                 
                 if (e.target.classList.contains('delete-btn')) {
                    const client = findClient(selectedClientId);
                    if (!client) return;
                    const apptIndex = client.appointments.findIndex(a => a.id === appointmentId);
                    if (apptIndex > -1) {
                        const [appt] = client.appointments.splice(apptIndex, 1);
                        deletedItems.appointments.push({ ...appt, clientId: client.id });
                        if (selectedAppointmentId === appointmentId) {
                            selectedAppointmentId = null;
                        }
                        markDirty();
                        fullRender();
                    }
                 } else {
                     selectAppointment(appointmentId);
                 }
            });
            
            updateAppointmentDateBtn.addEventListener('click', () => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                const newDateStr = appointmentDateInput.value;

                if (client && appointment && newDateStr) {
                    const dateObj = new Date(newDateStr);
                    const utcDate = new Date(dateObj.getUTCFullYear(), dateObj.getUTCMonth(), dateObj.getUTCDate());
                    appointment.date = utcDate.toISOString();
                    markDirty();
                    renderAppointments(); // Just re-render appointments to see the change
                    alert('Appointment date updated.');
                } else {
                    alert('Could not update date. Ensure a client, appointment, and date are selected.');
                }
            });

            deletedClientsListEl.addEventListener('click', e => {
                if (e.target.classList.contains('restore-btn')) {
                    const id = e.target.dataset.id;
                    const clientIndex = deletedItems.clients.findIndex(c => c.id === id);
                    if (clientIndex === -1) return;
                    const [client] = deletedItems.clients.splice(clientIndex, 1);
                    data.clients.push(client);
                    markDirty();
                    fullRender();
                }
            });

            archivedClientsListEl.addEventListener('click', e => {
                if (e.target.classList.contains('restore-btn')) {
                    const id = e.target.dataset.id;
                    if (!data.archivedClients) return;
                    const clientIndex = data.archivedClients.findIndex(c => c.id === id);
                    if (clientIndex === -1) return;
                    const [client] = data.archivedClients.splice(clientIndex, 1);
                    data.clients.push(client);
                    markDirty();
                    fullRender();
                }
            });

            deletedAppointmentsListEl.addEventListener('click', e => {
                 if (e.target.classList.contains('restore-btn')) {
                    const id = e.target.dataset.id;
                    const apptIndex = deletedItems.appointments.findIndex(a => a.id === id);
                    if (apptIndex === -1) return;

                    const [appt] = deletedItems.appointments.splice(apptIndex, 1);
                    const client = findClient(appt.clientId);
                    if (client) {
                        if (!client.appointments) client.appointments = [];
                        client.appointments.push(appt);
                        markDirty();
                        fullRender();
                    } else {
                        deletedItems.appointments.push(appt);
                        alert('Cannot restore. Client not found.');
                    }
                 }
            });
            
            clearDeletedClientsBtn.addEventListener('click', () => {
                if(confirm('Permanently delete all recently deleted clients?')) {
                    deletedItems.clients = [];
                    markDirty();
                    fullRender();
                }
            });
            clearDeletedAppointmentsBtn.addEventListener('click', () => {
                 if(confirm('Permanently delete all recently deleted appointments?')) {
                    deletedItems.appointments = [];
                    markDirty();
                    fullRender();
                }
            });
            
            persistentNotesEl.addEventListener('input', () => {
                 const client = findClient(selectedClientId);
                 if (client) {
                     client.persistentNotes = persistentNotesEl.value;
                     markDirty();
                 }
            });

            const autoResizeTextarea = (el) => {
                // Only resize if the user hasn't manually resized it.
                // We check if the style.height is not set or is 'auto'.
                if (!el.style.height || el.style.height === 'auto') {
                    el.style.height = 'auto';
                    el.style.height = el.scrollHeight + 'px';
                }
            };

            // --- Generic Bullet Point Handlers ---
            const formatBulletPoints = (text) => {
                // Split text into individual bullet points and ensure each is on its own line
                let content = text.trim();
                if (!content) return '';
                
                // Replace any bullet points that are not at the start of a line
                content = content.replace(/([^\n])\s*‚Ä¢\s*/g, '$1\n‚Ä¢ ');
                
                // Split into lines and process each one
                let lines = content.split('\n');
                let newLines = lines.map(line => {
                    let trimmedLine = line.trim();
                    if (trimmedLine.length > 0) {
                        if (!trimmedLine.startsWith('‚Ä¢')) {
                            return '‚Ä¢ ' + trimmedLine;
                        } else {
                            // Ensure proper spacing after bullet
                            return trimmedLine.replace(/^‚Ä¢\s*/, '‚Ä¢ ');
                        }
                    }
                    return line; // Keep empty lines as-is
                });
                
                // Filter out consecutive empty lines but keep single empty lines
                let result = [];
                let lastWasEmpty = false;
                for (let line of newLines) {
                    let isEmpty = line.trim().length === 0;
                    if (!isEmpty || !lastWasEmpty) {
                        result.push(line);
                    }
                    lastWasEmpty = isEmpty;
                }
                
                return result.join('\n');
            };

            const handleBulletedInput = (e, saveDataCallback) => {
                const textarea = e.target;

                // When user types, reset height to allow auto-resizing again
                textarea.style.height = 'auto';
                
                // If textarea is empty or doesn't start with a bullet, add one
                if (textarea.value.length > 0 && !textarea.value.startsWith('‚Ä¢')) {
                    const cursorPos = textarea.selectionStart;
                    textarea.value = '‚Ä¢ ' + textarea.value;
                    textarea.selectionStart = textarea.selectionEnd = cursorPos + 2;
                }
                
                // Auto-resize
                autoResizeTextarea(textarea);

                // Save changes using the provided callback
                saveDataCallback(textarea);
            };
            
            const handleBulletedKeyDown = (e) => {
                const textarea = e.target;
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const text = textarea.value;

                if (e.key === 'Enter') {
                    e.preventDefault();
                    
                    const currentLineStart = text.lastIndexOf('\n', start - 1) + 1;
                    const currentLine = text.substring(currentLineStart, start);

                    if (currentLine.trim() === '‚Ä¢') {
                        textarea.value = text.substring(0, currentLineStart) + text.substring(end);
                        textarea.selectionStart = textarea.selectionEnd = currentLineStart;
                    } else {
                        textarea.value = text.substring(0, start) + '\n‚Ä¢ ' + text.substring(end);
                        textarea.selectionStart = textarea.selectionEnd = start + 3;
                    }
                    
                    textarea.dispatchEvent(new Event('input', { bubbles: true }));
                    return;
                }

                if (e.key === 'Backspace' && start === end) {
                    const currentLineStart = text.lastIndexOf('\n', start - 1) + 1;
                    const lineText = text.substring(currentLineStart, start);
                    
                    if (lineText.trim() === '‚Ä¢' && start > 0) {
                        e.preventDefault();
                        const prevLineEnd = currentLineStart > 0 ? currentLineStart - 1 : 0;
                        textarea.value = text.substring(0, prevLineEnd) + text.substring(start);
                        textarea.selectionStart = textarea.selectionEnd = prevLineEnd;
                        textarea.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                }
            };

            // --- Specific Save Callbacks ---
            const saveSessionInfo = (textarea) => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (appointment) {
                    appointment.sessionInfo = textarea.value;
                    markDirty();
                }
                generateNoteBtn.disabled = !appointment || !selectedModel || !textarea.value.trim();
            };

            const saveSoapNote = (textarea) => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (appointment) {
                    if (!appointment.soap) appointment.soap = {s:'', o:'', a:'', p:''};
                    
                    if (textarea.id === 'interventions') {
                        appointment.soap.interventions = textarea.value;
                    } else {
                        const key = textarea.id.slice(-1).toLowerCase();
                        appointment.soap[key] = textarea.value;
                    }
                    markDirty();
                }
            };

            // --- Attach Bullet Point Handlers ---
            sessionInfoEl.addEventListener('input', (e) => handleBulletedInput(e, saveSessionInfo));
            sessionInfoEl.addEventListener('keydown', handleBulletedKeyDown);
            sessionInfoEl.addEventListener('focus', (e) => {
                const textarea = e.target;
                if (textarea.value.length === 0) {
                    textarea.value = '‚Ä¢ ';
                    textarea.selectionStart = textarea.selectionEnd = 2;
                }
            });

            soapContentEl.addEventListener('input', (e) => {
                if (e.target.matches('.soap-textarea')) {
                    handleBulletedInput(e, saveSoapNote);
                }
            });
            soapContentEl.addEventListener('keydown', (e) => {
                if (e.target.matches('.soap-textarea')) {
                    handleBulletedKeyDown(e);
                }
            });
            soapContentEl.addEventListener('focus', (e) => {
                if (e.target.matches('.soap-textarea')) {
                    const textarea = e.target;
                    if (textarea.value.length === 0) {
                        textarea.value = '‚Ä¢ ';
                        textarea.selectionStart = textarea.selectionEnd = 2;
                    }
                }
            });
            soapContentEl.addEventListener('click', (e) => {
                 if (e.target.classList.contains('copy-btn')) {
                     const targetId = e.target.dataset.target;
                     const textarea = document.getElementById(targetId);
                     if (!textarea) return;
                     navigator.clipboard.writeText(textarea.value).then(() => {
                         const originalText = e.target.textContent;
                         e.target.textContent = 'Copied!';
                         setTimeout(() => { e.target.textContent = originalText; }, 2000);
                     }).catch(err => {
                         console.error('Failed to copy text: ', err);
                         alert('Could not copy text to clipboard.');
                     });
                 }
                 if (e.target.classList.contains('suggestion-accept')) {
                    handleSuggestion(e.target, true);
                 }
                 if (e.target.classList.contains('suggestion-accept-replace')) {
                    handleSuggestion(e.target, true);
                 }
                 if (e.target.classList.contains('suggestion-decline')) {
                    handleSuggestion(e.target, false);
                 }
            });

            const handleSuggestion = (button, isAccepted) => {
                const suggestionBox = button.closest('.suggestion-box');
                const type = suggestionBox.dataset.suggestionType;
                const index = parseInt(suggestionBox.dataset.suggestionIndex, 10);
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);

                if (!appointment || !appointment.soap) return;

                const soapPanelContent = document.getElementById('soapContent');
                const scrollTop = soapPanelContent.scrollTop;

                const suggestionKey = `${type}_suggestion`;
                const suggestionData = appointment.soap[suggestionKey]?.[index];
                if (!suggestionData) return;

                const textarea = document.getElementById(`soap${type.toUpperCase()}`);
                const isReplacement = typeof suggestionData === 'object' && suggestionData.original && suggestionData.suggested;
                let textToAdd = '';

                if (isAccepted) {
                    if (isReplacement) {
                        // User clicked "Use Suggestion"
                        textToAdd = suggestionData.suggested;
                    } else {
                        // User clicked "Accept" for a new suggestion (string)
                        textToAdd = suggestionData;
                    }
                } else { // Declined
                    if (isReplacement) {
                        // User clicked "Keep Original"
                        textToAdd = suggestionData.original;
                    }
                    // If it's a new suggestion (string) and user clicks decline, textToAdd remains empty, which is correct.
                }

                if (textToAdd) {
                    const currentText = textarea.value.trim();
                    // Ensure the text to add is a proper bullet point.
                    const newText = `‚Ä¢ ${textToAdd.replace(/^‚Ä¢\s*/, '')}`;

                    if (currentText.length === 0 || currentText === '‚Ä¢') {
                        textarea.value = newText;
                    } else {
                        textarea.value = `${currentText}\n${newText}`;
                    }
                    
                    // Manually update the data model since we're not dispatching the 'input' event before re-rendering
                    const key = textarea.id.slice(-1).toLowerCase();
                    appointment.soap[key] = textarea.value;
                }

                // Remove the suggestion that was just handled.
                if (Array.isArray(appointment.soap[suggestionKey])) {
                    appointment.soap[suggestionKey].splice(index, 1);
                }
                
                markDirty();
                renderSoap(); 

                // Restore scroll position
                soapPanelContent.scrollTop = scrollTop;
            };


            const systemPrompt = `You are a helpful assistant for a therapist or clinician. Your primary function is to accurately categorize user-provided session notes into a structured SOAP note format.

**Your Task:**
Analyze the "Session Information" text provided by the user. Categorize every piece of information into one of the four SOAP sections based on the strict definitions below.

- **Subjective (S):** Information reported by the client (e.g., feelings, goals, history). This is for the client's voice and perspective.
- **Objective (O):** Everything that *happens* in the therapy session. This includes all therapeutic interventions, actions taken, connections made, and reflections or psychoeducation provided by the writer. **Any sentence that describes the writer's actions or speech belongs here.** 
  
  **GOLDEN THREAD:** When treatment goals are provided, weave connections between interventions and specific treatment goals/objectives in this section. For example: "Writer provided CBT techniques to address client's anxiety management goal" or "Explored coping strategies related to client's objective of improving emotional regulation." Only make these connections when they are clearly apparent from the session content - don't force connections that aren't naturally there.

- **Assessment (A):** The writer's clinical analysis and observations. This includes notes on progress towards goals and direct observations of the client's state (e.g., "client appeared tired," "client's affect was bright"). This section should NOT contain actions or speech from the session.
- **Plan (P):** The course of action for future sessions. This includes topics to be addressed, homework, and any modifications to the treatment plan.
- **Interventions (I):** Identify specific clinical techniques and modalities used during the session. You have more freedom here to interpret the session notes and list the relevant interventions, even if the exact keyword isn't used.

**NEW: Suggestions**
- In addition to the main SOAP content, you will provide clinical language suggestions for all four sections when appropriate stronger clinical terminology is available.
- These suggestions should improve clinical precision and professional language without adding new information.
- The suggestions should be returned in four JSON keys: \`s_suggestion\`, \`o_suggestion\`, \`a_suggestion\`, and \`p_suggestion\`.
- For any section (S, O, A, P), the value for its suggestion key (e.g., \`s_suggestion\`) MUST be an array that can contain two types of items:
    1.  A JSON object for suggesting a *revision* to text you've already placed in the corresponding section: \`{"original": "[the exact original text to be replaced]", "suggested": "[the new suggested text]"}\`. The "original" text must be a direct, verbatim quote of one of the bullet points from the corresponding section you generated.
    2.  A simple string for suggesting a *new idea* not already in that section. Example: "Consider exploring coping mechanisms for social anxiety."
- A mixed example for an \`a_suggestion\` key would look like: \`[{"original": "‚Ä¢ Ct is tired.", "suggested": "‚Ä¢ Ct presented with fatigue."}, "Recommend weekly check-ins."]\`
- If you have no suggestion for any section, return an empty array \`[]\` for that key.

**CRITICAL INSTRUCTIONS:**
- **THE GOLDEN RULE:** ONLY use information explicitly provided in the "Session Information" text. Do not use any information from the example output below, which is for formatting reference only.
- **PRESERVE SHORTHAND:** Do not expand abbreviations or shorthand. Keep "Ct" as "Ct" (not "Client"), "IBS" as "IBS" (not "Irritable Bowel Syndrome"), etc. Do not add expanded forms in parentheses.
- **CLINICIAN REFERENCE:** Always refer to the clinician as "Writer" (not "the Writer", "the clinician", "therapist", or any other variation).
- **Example of PERFECT Output (FOR FORMATTING ONLY):**
{"s":"‚Ä¢ Ct said they felt bad.","o":"‚Ä¢ Writer talked about coping.","a":"‚Ä¢ Ct displays affect congruent with mood.","p":"‚Ä¢ Continue to explore themes of loss.","i":"‚Ä¢ Psychoeducation\\n‚Ä¢ Cognitive Restructuring","s_suggestion":[{"original":"‚Ä¢ Ct said they felt bad.","suggested":"‚Ä¢ Ct reported experiencing significant distress."}],"o_suggestion":[{"original":"‚Ä¢ Writer talked about coping.","suggested":"‚Ä¢ Writer provided psychoeducation on coping strategies."}],"a_suggestion":["Client appears to be making progress toward treatment goals related to anxiety."],"p_suggestion":["Continue to utilize CBT techniques to challenge cognitive distortions in the next session."]};
            `;

            const generateSoapNote = async () => {
                if (!selectedModel) {
                    alert('Please connect to a provider and select a model in Settings.');
                    return;
                }
                if (apiProvider === 'openwebui') {
                    await generateSoapNoteWithOpenWebUI();
                } else if (apiProvider === 'gemini') {
                    await generateSoapNoteWithGemini();
                } else if (apiProvider === 'openai') {
                    await generateSoapNoteWithOpenAI();
                } else {
                    alert('Invalid API provider selected.');
                }
            };
            
            const processAndStoreSoapData = (soapData, appointment) => {
                 if (!appointment.soap) appointment.soap = {};

                 // NEW: Process and store AI-generated interventions
                 appointment.soap.interventions = soapData.i ? formatBulletPoints(soapData.i) : 'No interventions identified.';

                 ['s', 'o', 'a', 'p'].forEach(key => {
                     const suggestionKey = `${key}_suggestion`;
                     const suggestions = soapData[suggestionKey] || [];
                     const fullText = soapData[key] ? formatBulletPoints(soapData[key]) : '';

                     // If there are no suggestions, just use the full text.
                     if (suggestions.length === 0) {
                         appointment.soap[key] = fullText;
                     } else {
                         // Identify all "original" texts from replacement suggestions.
                         const originalsToWithhold = suggestions
                             .filter(s => typeof s === 'object' && s.original)
                             .map(s => s.original.trim());

                         // Split the full generated text into bullet points.
                         const allBulletPoints = fullText.split('\n').map(line => line.trim());

                         // Filter out the bullet points that are part of a suggestion.
                         const immediateTextPoints = allBulletPoints.filter(point => {
                             if (point === '') return false; // Ignore empty lines
                             // A point should be included if it's NOT in the withhold list.
                             const trimmedPoint = point.replace(/^‚Ä¢\s*/, '');
                             return !originalsToWithhold.some(o => o.replace(/^‚Ä¢\s*/, '') === trimmedPoint);
                         });

                         appointment.soap[key] = immediateTextPoints.join('\n');
                     }
                     
                     // Always store the full list of suggestions.
                     appointment.soap[suggestionKey] = suggestions;
                 });
             };


            const generateSoapNoteWithGemini = async () => {
                if (!selectedModel || !geminiApiKey) {
                    alert('Please connect to Gemini with an API key and model first.');
                    return;
                }

                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (!client || !appointment || !sessionInfoEl.value.trim()) {
                    alert('Please select a client and appointment, and enter some session information.');
                    return;
                }

                generateNoteBtn.disabled = true;
                generateNoteBtn.textContent = 'Generating...';

                // Gather treatment goals context for Golden Thread
                let treatmentGoalsContext = '';
                if (client.goals && client.goals.length > 0) {
                    const activeGoals = client.goals.filter(g => g.status === 'active');
                    if (activeGoals.length > 0) {
                        treatmentGoalsContext = `\n- **Current Treatment Goals:**\n${activeGoals.map(goal => {
                            const objectives = goal.objectives && goal.objectives.length > 0 
                                ? goal.objectives.map(obj => `  - ${obj.text} ${obj.completed ? '(Completed)' : '(In Progress)'}`).join('\n')
                                : '  - No specific objectives defined';
                            return `  ‚Ä¢ ${goal.title}\n${objectives}`;
                        }).join('\n')}\n`;
                    }
                }

                const userPrompt = `
- **Session Information (This Session):**
${sessionInfoEl.value}${treatmentGoalsContext}
`;
                const fullPrompt = `${systemPrompt}\n\n**User Input:**\n${userPrompt}`;

                const payload = {
                    contents: [{
                        parts: [{ text: fullPrompt }]
                    }],
                    generationConfig: {
                        response_mime_type: "application/json",
                    }
                };

                try {
                    const url = `https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent?key=${geminiApiKey}`;
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        const error = new Error(`Gemini API error: ${response.status} - ${errorText}`);
                        error.response = response;
                        throw error;
                    }

                    const result = await response.json();
                    if (!result || !result.candidates || !result.candidates[0].content.parts[0].text) {
                         throw new Error("The Gemini API returned an invalid or empty response.");
                    }

                    let content = result.candidates[0].content.parts[0].text;
                    let soapData = JSON.parse(content);

                    processAndStoreSoapData(soapData, appointment);

                    markDirty();
                    renderSoap();

                } catch (error) {
                    console.error('Gemini SOAP Note Generation Error:', error);
                    alert(`Failed to generate SOAP note with Gemini. Please check your API Key, Model Name, and the console for details.\nError: ${error.message}`);
                } finally {
                    generateNoteBtn.disabled = false;
                    generateNoteBtn.textContent = 'Generate Note';
                }
            };
            
            const generateSoapNoteWithOpenAI = async () => {
                if (!selectedModel || !openaiApiKey) {
                    alert('Please connect to OpenAI with an API key and model first.');
                    return;
                }

                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (!client || !appointment || !sessionInfoEl.value.trim()) {
                    alert('Please select a client and appointment, and enter some session information.');
                    return;
                }

                generateNoteBtn.disabled = true;
                generateNoteBtn.textContent = 'Generating...';

                // Gather treatment goals context for Golden Thread
                let treatmentGoalsContext = '';
                if (client.goals && client.goals.length > 0) {
                    const activeGoals = client.goals.filter(g => g.status === 'active');
                    if (activeGoals.length > 0) {
                        treatmentGoalsContext = `\n- **Current Treatment Goals:**\n${activeGoals.map(goal => {
                            const objectives = goal.objectives && goal.objectives.length > 0 
                                ? goal.objectives.map(obj => `  - ${obj.text} ${obj.completed ? '(Completed)' : '(In Progress)'}`).join('\n')
                                : '  - No specific objectives defined';
                            return `  ‚Ä¢ ${goal.title}\n${objectives}`;
                        }).join('\n')}\n`;
                    }
                }

                const userPrompt = `- **Session Information (This Session):**\n${sessionInfoEl.value}${treatmentGoalsContext}`;

                const payload = {
                    model: selectedModel,
                    messages: [
                        { "role": "system", "content": systemPrompt },
                        { "role": "user", "content": userPrompt }
                    ],
                    response_format: { "type": "json_object" }
                };

                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${openaiApiKey}`
                        },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`OpenAI API error: ${response.status} - ${errorData.error.message}`);
                    }

                    const result = await response.json();
                    if (!result || !result.choices || !result.choices[0].message.content) {
                        throw new Error("The OpenAI API returned an invalid or empty response.");
                    }

                    let content = result.choices[0].message.content;
                    let soapData = JSON.parse(content);

                    processAndStoreSoapData(soapData, appointment);

                    markDirty();
                    renderSoap();

                } catch (error) {
                    console.error('OpenAI SOAP Note Generation Error:', error);
                    alert(`Failed to generate SOAP note with OpenAI. Please check your API Key, Model Name, and the console for details.\nError: ${error.message}`);
                } finally {
                    generateNoteBtn.disabled = false;
                    generateNoteBtn.textContent = 'Generate Note';
                }
            };

            const generateSoapNoteWithOpenWebUI = async () => {
                if (!selectedModel) {
                    alert('Please connect to your server and select a model first.');
                    return;
                }

                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (!client || !appointment || !sessionInfoEl.value.trim()) {
                    alert('Please select a client and appointment, and enter some session information.');
                    return;
                }

                generateNoteBtn.disabled = true;
                generateNoteBtn.textContent = 'Generating...';

                // Gather treatment goals context for Golden Thread
                let treatmentGoalsContext = '';
                if (client.goals && client.goals.length > 0) {
                    const activeGoals = client.goals.filter(g => g.status === 'active');
                    if (activeGoals.length > 0) {
                        treatmentGoalsContext = `\n- **Current Treatment Goals:**\n${activeGoals.map(goal => {
                            const objectives = goal.objectives && goal.objectives.length > 0 
                                ? goal.objectives.map(obj => `  - ${obj.text} ${obj.completed ? '(Completed)' : '(In Progress)'}`).join('\n')
                                : '  - No specific objectives defined';
                            return `  ‚Ä¢ ${goal.title}\n${objectives}`;
                        }).join('\n')}\n`;
                    }
                }

                const userPrompt = `
- **Client Name:** ${client.name}
- **Session Information (This Session):**
${sessionInfoEl.value}${treatmentGoalsContext}`;

                const payload = {
                    model: selectedModel,
                    messages: [
                        { "role": "system", "content": systemPrompt },
                        { "role": "user", "content": userPrompt }
                    ],
                    response_format: { "type": "json_object" },
                    stream: false
                };
                
                try {
                    const headers = new Headers({ 'Content-Type': 'application/json' });
                     if (apiKey) {
                         headers.append('Authorization', `Bearer ${apiKey}`);
                    }
                    const response = await fetch(`${serverAddress}/api/v1/chat/completions`, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(payload),
                        mode: 'cors'
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        const error = new Error(`API error: ${response.status} - ${errorText}`);
                        error.response = response;
                        throw error;
                    }

                    const result = await response.json();
                    if (!result) {
                        throw new Error("The API returned an empty response. Please check the Open WebUI server logs for errors.");
                    }
                    let content = result.choices[0].message.content;
                    let soapData = {};

                    // Aggressive JSON extraction and cleanup
                    try {
                        // Find the first '{' and the last '}' to extract the JSON part.
                        const firstBrace = content.indexOf('{');
                        const lastBrace = content.lastIndexOf('}');
                        if (firstBrace === -1 || lastBrace === -1 || lastBrace < firstBrace) {
                            throw new Error('AI response did not contain a valid JSON object.');
                        }
                        let jsonString = content.substring(firstBrace, lastBrace + 1);
                        
                        // Attempt to parse it. If it fails, it's likely due to malformed content.
                        try {
                            soapData = JSON.parse(jsonString);
                        } catch (e) {
                            console.warn("Initial JSON.parse failed. Attempting to clean and re-parse.", e.message);
                            // This is a more robust fallback for models that fail to escape content correctly.
                            // It performs multiple passes to clean up common issues.
                            
                            // 1. Remove newlines within JSON strings, which is a common error.
                            let cleanedString = jsonString.replace(/:\s*"(.*?)"/gs, (match, group1) => {
                                const singleLineGroup = group1.replace(/\n/g, '\\n').replace(/\r/g, '');
                                return `: "${singleLineGroup}"`;
                            });

                            // 2. Fix unescaped quotes inside values. This is more complex.
                            // We look for a quote that is not preceded by a backslash.
                            cleanedString = cleanedString.replace(/:\s*"(.*?)"/g, (match, group1) => {
                                const fixedGroup = group1.replace(/(?<!\\)"/g, '\\"');
                                return `: "${fixedGroup}"`;
                            });

                            soapData = JSON.parse(cleanedString); // Retry parsing with the cleaned string
                        }

                    } catch (parseError) {
                        console.error("Failed to parse the following JSON string from the AI:", content);
                        throw new Error(`The AI model returned malformed JSON that could not be automatically fixed. Check the browser console for the raw output. Details: ${parseError.message}`);
                    }
                    
                    processAndStoreSoapData(soapData, appointment);
                    
                    markDirty();
                    renderSoap();

                } catch (error) {
                    console.error('SOAP Note Generation Error:', error);
                    let alertMessage = `Failed to generate SOAP note. Please check your connection and the console for details.\nError: ${error.message}`;
                    
                    if (error.response?.status === 401) {
                         alertMessage = `Authentication failed (401 Unauthorized) while trying to generate the note. Please re-check your API Key.`;
                    } else if (error instanceof TypeError && error.message.toLowerCase().includes('failed to fetch')) {
                        alertMessage = `Network Error: Failed to fetch. Check CORS policy on your server.`;
                    }
                    alert(alertMessage);
                } finally {
                    generateNoteBtn.disabled = false;
                    generateNoteBtn.textContent = 'Generate Note';
                }
            };
            
            const connectToServer = async () => {
                apiProvider = apiProviderSelect.value;
                if (apiProvider === 'openwebui') {
                    await connectToOpenWebUI();
                } else if (apiProvider === 'gemini') {
                    await connectToGemini();
                } else if (apiProvider === 'openai') {
                    await connectToOpenAI();
                }
            };
            
            const connectToOpenAI = async () => {
                const key = openaiApiKeyInput.value.trim();
                if (!key) {
                    alert('Please provide an OpenAI API Key.');
                    return;
                }

                apiStatus.textContent = 'Connecting...';
                apiStatus.style.color = 'orange';
                openaiModelInput.innerHTML = '<option>Loading models...</option>';
                openaiModelInput.disabled = true;

                try {
                    const response = await fetch('https://api.openai.com/v1/models', {
                        headers: {
                            'Authorization': `Bearer ${key}`
                        }
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`Failed to fetch models: ${response.status} - ${errorData.error.message}`);
                    }
                    const data = await response.json();

                    const models = data.data
                        .filter(m => m.id.includes('gpt') && m.id.includes('instruct') === false) // Filter for chat models
                        .sort((a, b) => a.id.localeCompare(b.id)) // Sort them
                        .map(m => m.id);

                    if (models.length === 0) {
                        throw new Error("No compatible GPT models found.");
                    }

                    openaiModelInput.innerHTML = '';
                    models.forEach(modelId => {
                        const option = document.createElement('option');
                        option.value = modelId;
                        option.textContent = modelId;
                        openaiModelInput.appendChild(option);
                    });

                    openaiApiKey = key;
                    
                    const savedModel = localStorage.getItem('openaiModel');
                    if (savedModel && models.includes(savedModel)) {
                        openaiModelInput.value = savedModel;
                    } else if (models.includes('gpt-4o')) { // Prefer gpt-4o
                        openaiModelInput.value = 'gpt-4o';
                    } else if (models.includes('gpt-3.5-turbo')) {
                        openaiModelInput.value = 'gpt-3.5-turbo';
                    } else {
                        openaiModelInput.value = models[0]; // Fallback
                    }
                    
                    selectedModel = openaiModelInput.value;
                    openaiModelInput.disabled = false;

                    localStorage.setItem('apiProvider', 'openai');
                    localStorage.setItem('openaiApiKey', openaiApiKey);
                    localStorage.setItem('openaiModel', selectedModel);

                    apiStatus.textContent = 'Connected';
                    apiStatus.style.color = 'green';

                } catch (error) {
                    console.error('OpenAI connection error:', error);
                    apiStatus.textContent = 'Failed';
                    apiStatus.style.color = 'red';
                    openaiModelInput.innerHTML = '<option>Connection Failed</option>';
                    openaiApiKey = null;
                    selectedModel = null;
                    alert(`Failed to connect to OpenAI. Check your API key and network connection.\nError: ${error.message}`);
                } finally {
                    fullRender();
                }
            };

            const connectToGemini = async () => {
                const key = geminiApiKeyInput.value.trim();
                if (!key) {
                    alert('Please provide a Gemini API Key.');
                    return;
                }

                apiStatus.textContent = 'Connecting...';
                apiStatus.style.color = 'orange';
                geminiModelInput.innerHTML = '<option>Loading models...</option>';
                geminiModelInput.disabled = true;

                try {
                    const url = `https://generativelanguage.googleapis.com/v1beta/models?key=${key}`;
                    const response = await fetch(url);
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Failed to fetch models: ${response.status} - ${errorText}`);
                    }
                    const data = await response.json();

                    const models = data.models.filter(m => 
                        m.supportedGenerationMethods.includes("generateContent") &&
                        m.name.includes("gemini")
                    ).map(m => m.name.replace('models/', ''));

                    if (models.length === 0) {
                        throw new Error("No compatible Gemini models found.");
                    }

                    geminiModelInput.innerHTML = '';
                    models.forEach(modelId => {
                        const option = document.createElement('option');
                        option.value = modelId;
                        option.textContent = modelId;
                        geminiModelInput.appendChild(option);
                    });

                    geminiApiKey = key;
                    
                    const savedModel = localStorage.getItem('geminiModel');
                    if (savedModel && models.includes(savedModel)) {
                        geminiModelInput.value = savedModel;
                    } else if (models.includes('gemini-1.5-flash-latest')) {
                        geminiModelInput.value = 'gemini-1.5-flash-latest';
                    } else {
                        geminiModelInput.value = models[0];
                    }
                    
                    selectedModel = geminiModelInput.value;
                    geminiModelInput.disabled = false;

                    localStorage.setItem('apiProvider', 'gemini');
                    localStorage.setItem('geminiApiKey', geminiApiKey);
                    localStorage.setItem('geminiModel', selectedModel);

                    apiStatus.textContent = 'Connected';
                    apiStatus.style.color = 'green';

                } catch (error) {
                    console.error('Gemini connection error:', error);
                    apiStatus.textContent = 'Failed';
                    apiStatus.style.color = 'red';
                    geminiModelInput.innerHTML = '<option>Connection Failed</option>';
                    geminiApiKey = null;
                    selectedModel = null;
                    alert(`Failed to connect to Gemini. Check your API key and network connection.\nError: ${error.message}`);
                } finally {
                    fullRender();
                }
            };

            const connectToOpenWebUI = async () => {
                const address = serverAddressInput.value.trim();
                if (!address) {
                    alert('Please enter an Open WebUI address.');
                    return;
                }
                serverAddress = address.endsWith('/') ? address.slice(0, -1) : address;
                apiKey = apiKeyInput.value.trim();

                // Save settings to local storage immediately
                localStorage.setItem('apiProvider', 'openwebui');
                localStorage.setItem('serverAddress', serverAddress);
                if (apiKey) {
                    localStorage.setItem('apiKey', apiKey);
                } else {
                    localStorage.removeItem('apiKey');
                }

                apiStatus.textContent = 'Connecting...';
                apiStatus.style.color = 'orange';
                modelSelect.innerHTML = '<option>Loading models...</option>';
                modelSelect.disabled = true;

                try {
                    const headers = new Headers();
                    if (apiKey) {
                        headers.append('Authorization', `Bearer ${apiKey}`);
                    }
                    const response = await fetch(`${serverAddress}/api/v1/models`, { headers, mode: 'cors' });
                    if (!response.ok) {
                        const error = new Error(`Failed to connect to Open WebUI. Status: ${response.status}`);
                        error.response = response;
                        throw error;
                    }
                    const data = await response.json();
                    
                    apiStatus.textContent = 'Connected';
                    apiStatus.style.color = 'green';
                    
                    // localStorage.setItem('serverAddress', serverAddress);
                    // if (apiKey) localStorage.setItem('apiKey', apiKey);
                    // else localStorage.removeItem('apiKey');
                    
                    modelSelect.innerHTML = '';
                    const models = data.data;

                    if (models && models.length > 0) {
                        models.forEach(model => {
                            const option = document.createElement('option');
                            option.value = model.id;
                                                         option.textContent = model.id;
                            modelSelect.appendChild(option);
                        });

                        let autoSelectedModelId = null;
                        const llamaModel = models.find(m => m.id === 'llama3.2:3b');
                        const deepseekModel = models.find(m => m.id === 'deepseek-r1:1.5b');

                        if (llamaModel) {
                            autoSelectedModelId = llamaModel.id;
                        } else if (deepseekModel) {
                            autoSelectedModelId = deepseekModel.id;
                        } else {
                            const fallbackModel = models.find(m => 
                                m.id !== 'arena-model' && 
                                !m.id.toLowerCase().includes('coder') && 
                                !m.id.toLowerCase().includes('coding')
                            );
                            if (fallbackModel) {
                                autoSelectedModelId = fallbackModel.id;
                            }
                        }

                        if (autoSelectedModelId) {
                            modelSelect.value = autoSelectedModelId;
                        } else if (models.length > 0) {
                            modelSelect.value = models[0].id;
                        }

                        selectedModel = modelSelect.value;
                        modelSelect.disabled = false;
                        
                    } else {

                        modelSelect.innerHTML = '<option>No models found</option>';
                        selectedModel = null;
                        modelSelect.disabled = true;
                    }

                } catch (error) {
                    console.error('API connection error:', error);
                    apiStatus.textContent = 'Failed';
                    apiStatus.style.color = 'red';
                    serverAddress = null;
                    modelSelect.innerHTML = '<option>Connection failed</option>';
                    
                                        
                    let alertMessage = `Connection to "${address}" failed.`;
                    
                    if (error.response?.status === 401) {
                         alertMessage += `\n\nError: Authentication failed (401 Unauthorized). Please check if your API Key is correct and has the necessary permissions. Some servers require an API key even if it's optional in the UI.`;
                    } else if (error instanceof TypeError && error.message.toLowerCase().includes('failed to fetch')) {
                        alertMessage = `Network Error: Failed to fetch.

This is the most common error and is almost always caused by one of two things:

1.  **CORS Policy:** Your browser is blocking the request for security reasons. The Open WebUI server must be configured to allow requests from this webpage.
    *SOLUTION:* In your Open WebUI settings, find the "Allowed Origins" configuration and add the URL of this page. You can often just add "*" to allow all origins, but this is less secure.

2.  **Server Not Reachable:** The address "${address}" is incorrect, or the Open WebUI server is not running. Please double-check the address and ensure the server is active.

This error cannot be fixed within this application's code; it requires a configuration change on the server you are trying to connect to.`;
                    } else {
                         alertMessage += `\n\nError: ${error.message}`;
                    }
                    alert(alertMessage);

                } finally {
                    fullRender();
                }
            };


            // --- Data Persistence (Save/Load/AutoSave) ---
            const updateSaveStatus = (message, isGood = true, duration = 0) => {
                autoSaveIndicator.style.opacity = '1';
                saveStatus.textContent = message;
                saveStatus.style.color = isGood ? 'white' : '#f1c40f'; // Gold for warning
                if (duration > 0) {
                    setTimeout(() => {
                        if (saveStatus.textContent === message) {
                            autoSaveIndicator.style.opacity = '0';
                        }
                    }, duration);
                }
            }

            const markDirty = () => {
                if (!isDirty) {
                    isDirty = true;
                    updateSaveStatus('Unsaved changes...', false);
                }
                debouncedAutoSave();
            };

            const saveDataToLocalStorage = () => {
                try {
                    const state = { data, deletedItems, selectedClientId, selectedAppointmentId };
                    const dataStr = JSON.stringify(state);
                    localStorage.setItem('clientData', dataStr);
                    isDirty = false;
                } catch (e) {
                    console.error("Failed to save to localStorage", e);
                    updateSaveStatus('Save failed!', false, 3000);
                    // Handle potential quota exceeded error
                    if (e.name === 'QuotaExceededError') {
                        alert('Failed to save data: Storage quota exceeded. Please export your data to a file and consider clearing some old records.');
                    }
                }
            };

            const loadDataFromLocalStorage = () => {
                const dataStr = localStorage.getItem('clientData');
                if (dataStr) {
                    try {
                        const state = JSON.parse(dataStr);
                        data = state.data || getInitialData();
                        if (!data.archivedClients) data.archivedClients = [];
                        deletedItems = state.deletedItems || { clients: [], appointments: [] };
                        selectedClientId = state.selectedClientId || null;
                        selectedAppointmentId = state.selectedAppointmentId || null;

                        // Load API settings
                        const savedProvider = localStorage.getItem('apiProvider');
                        if (savedProvider) {
                            apiProvider = savedProvider;
                            apiProviderSelect.value = apiProvider;
                            toggleProviderSettings();
                        }
                        serverAddressInput.value = localStorage.getItem('serverAddress') || '';
                        apiKeyInput.value = localStorage.getItem('apiKey') || '';
                        geminiApiKeyInput.value = localStorage.getItem('geminiApiKey') || '';
                        openaiApiKeyInput.value = localStorage.getItem('openaiApiKey') || '';
                        // We don't load the gemini model name here, it's set after connection

                    } catch (e) {
                        console.error("Failed to load from localStorage", e);
                        alert("Error loading data from storage. Data might be corrupt. Starting fresh.");
                        data = getInitialData();
                        deletedItems = { clients: [], appointments: [] };
                    }
                }
            };

            const exportFile = () => {
                try {
                    const stateToSave = { data, deletedItems, selectedClientId, selectedAppointmentId };
                    const stateJSON = JSON.stringify(stateToSave, null, 2);
                    const blob = new Blob([stateJSON], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `client-data-${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    updateSaveStatus('Exported.', true, 2000);
                } catch (err) {
                    console.error('Failed to export file:', err);
                    alert('Export failed!');
                    updateSaveStatus('Export failed!', false, 3000);
                }
            };

            let saveTimeout;
            const debouncedAutoSave = () => {
                clearTimeout(saveTimeout);
                saveTimeout = setTimeout(() => {
                    saveDataToLocalStorage();
                    updateSaveStatus('Auto-saved', true, 2000);
                }, 1500);
            };

            const loadFile = () => {
                 if (isDirty && !confirm('You have unsaved changes that will be lost. Are you sure you want to import a new file?')) {
                     return;
                 }
                fileInput.click();
            };

            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const contents = e.target.result;
                        const state = JSON.parse(contents);

                        if (!state.data || !state.deletedItems) {
                            throw new Error("Invalid file structure. Required properties are missing.");
                        }

                        data = state.data;
                        deletedItems = state.deletedItems;
                        selectedClientId = state.selectedClientId || null;
                        selectedAppointmentId = state.selectedAppointmentId || null;

                        if (!data.archivedClients) {
                            data.archivedClients = [];
                        }

                        isDirty = false;
                        saveDataToLocalStorage();

                        alert(`Imported ${file.name} successfully.`);
                        fullRender();
                    } catch (err) {
                        console.error('Failed to load file:', err);
                        alert(`Import failed! Invalid file.\n\nError: ${err.message}`);
                    } finally {
                        // Reset file input so the same file can be loaded again
                        fileInput.value = '';
                    }
                };
                reader.readAsText(file);
            });

            const eraseAllData = () => {
                const confirmationText = "DELETE ALL DATA";
                const userInput = prompt(`This action will permanently erase all client data from this browser. This cannot be undone.\n\nTo confirm, please type "${confirmationText}" in the box below.`);
                if (userInput === confirmationText) {
                    data = getInitialData();
                    deletedItems = { clients: [], appointments: [] };
                    selectedClientId = null;
                    selectedAppointmentId = null;
                    isDirty = false;
                    localStorage.removeItem('clientData');
                    localStorage.removeItem('serverAddress');
                    localStorage.removeItem('apiKey');
                    localStorage.removeItem('geminiApiKey');
                    localStorage.removeItem('openaiApiKey');
                    localStorage.removeItem('geminiModel');
                    localStorage.removeItem('openaiModel');
                    localStorage.removeItem('apiProvider');
                    localStorage.removeItem('columnSizes');
                    localStorage.removeItem('rowSizes');
                    localStorage.removeItem('theme');
                    alert('All data has been permanently erased. The page will now reload.');
                    window.location.reload();
                } else if (userInput !== null) {
                    alert('The text you entered did not match. No data has been erased.');
                }
            };

            // --- Event Listeners ---
            addClientBtn.addEventListener('click', addClient);
            sortClientsBtn.addEventListener('click', () => {
                data.clients.sort((a, b) => a.name.localeCompare(b.name));
                markDirty();
                renderClients();
            });
            addAppointmentBtn.addEventListener('click', addAppointment);
            addGoalBtn.addEventListener('click', addGoal);

            // Goals event delegation
            goalsListEl.addEventListener('click', (e) => {
                const goalItem = e.target.closest('.goal-item');
                if (!goalItem) return;
                
                const goalId = goalItem.dataset.goalId;
                
                if (e.target.classList.contains('add-objective-btn')) {
                    addObjective(goalId);
                } else if (e.target.classList.contains('objective-checkbox')) {
                    const objectiveItem = e.target.closest('.objective-item');
                    const objectiveId = objectiveItem.dataset.objectiveId;
                    toggleObjective(goalId, objectiveId);
                } else if (e.target.closest('.objective-item') && e.target.classList.contains('delete-btn')) {
                    const objectiveItem = e.target.closest('.objective-item');
                    const objectiveId = objectiveItem.dataset.objectiveId;
                    deleteObjective(goalId, objectiveId);
                } else if (e.target.classList.contains('edit-btn')) {
                    editGoal(goalId);
                } else if (e.target.classList.contains('archive-btn')) {
                    changeGoalStatus(goalId);
                } else if (e.target.classList.contains('delete-btn')) {
                    deleteGoal(goalId);
                }
            });

            // Show/hide objective delete buttons on hover
            goalsListEl.addEventListener('mouseover', (e) => {
                const objectiveItem = e.target.closest('.objective-item');
                if (objectiveItem) {
                    const deleteBtn = objectiveItem.querySelector('.delete-btn');
                    if (deleteBtn) deleteBtn.style.opacity = '1';
                }
            });

            goalsListEl.addEventListener('mouseout', (e) => {
                const objectiveItem = e.target.closest('.objective-item');
                if (objectiveItem) {
                    const deleteBtn = objectiveItem.querySelector('.delete-btn');
                    if (deleteBtn) deleteBtn.style.opacity = '0';
                }
            });
            exportBtn.addEventListener('click', exportFile);
            importBtn.addEventListener('click', loadFile);
            eraseAllBtn.addEventListener('click', eraseAllData);
            generateNoteBtn.addEventListener('click', generateSoapNote);
            connectApiBtn.addEventListener('click', connectToServer);
            manualSaveBtn.addEventListener('click', () => {
                saveDataToLocalStorage();
                updateSaveStatus('Data saved!', true, 2000);
            });
            settingsBtn.addEventListener('click', () => settingsModal.classList.remove('hidden'));
            closeSettingsBtn.addEventListener('click', () => settingsModal.classList.add('hidden'));
            settingsModal.addEventListener('click', (e) => {
                if(e.target.id === 'settingsModal') {
                    settingsModal.classList.add('hidden');
                }
            });
            modelSelect.addEventListener('change', (e) => {
                selectedModel = e.target.value;
                localStorage.setItem('openWebUIModel', selectedModel);
                fullRender();
            });

            geminiModelInput.addEventListener('change', (e) => {
                selectedModel = e.target.value;
                localStorage.setItem('geminiModel', selectedModel);
                fullRender();
            });

            openaiModelInput.addEventListener('change', (e) => {
                selectedModel = e.target.value;
                localStorage.setItem('openaiModel', selectedModel);
                fullRender();
            });

            const toggleProviderSettings = () => {
                const provider = apiProviderSelect.value;
                apiProvider = provider;
                openwebuiSettings.classList.add('hidden');
                geminiSettings.classList.add('hidden');
                openaiSettings.classList.add('hidden');
                modelSelectWrapper.classList.add('hidden'); // This is for OpenWebUI

                if (provider === 'openwebui') {
                    openwebuiSettings.classList.remove('hidden');
                    modelSelectWrapper.classList.remove('hidden'); // Show the OpenWebUI model select
                } else if (provider === 'gemini') {
                    geminiSettings.classList.remove('hidden');
                } else if (provider === 'openai') {
                    openaiSettings.classList.remove('hidden');
                }
            };
            apiProviderSelect.addEventListener('change', toggleProviderSettings);

            startTimerBtn.addEventListener('click', () => {
                const appointment = findAppointment(findClient(selectedClientId), selectedAppointmentId);
                if (appointment) {
                    appointment.startTime = new Date().toISOString();
                    appointment.endTime = null; // Clear end time if starting again
                    markDirty();
                    renderSessionTimer(appointment);
                }
            });

            stopTimerBtn.addEventListener('click', () => {
                const appointment = findAppointment(findClient(selectedClientId), selectedAppointmentId);
                if (appointment && appointment.startTime) { // Can only stop if started
                    appointment.endTime = new Date().toISOString();
                    clearInterval(sessionTimerInterval);
                    markDirty();
                    renderSessionTimer(appointment);
                }
            });

            // --- Theme Management ---
            const updateThemeButton = () => {
                const savedTheme = localStorage.getItem('theme') || 'automatic';
                if (savedTheme === 'dark') {
                    themeToggleBtn.textContent = 'üåô';
                    themeToggleBtn.title = 'Switch to Automatic Theme';
                } else if (savedTheme === 'automatic') {
                    themeToggleBtn.textContent = 'üîÑ';
                    themeToggleBtn.title = 'Switch to Light Theme';
                } else {
                    themeToggleBtn.textContent = '‚òÄÔ∏è';
                    themeToggleBtn.title = 'Switch to Dark Theme';
                }
            };

            const cycleTheme = () => {
                const savedTheme = localStorage.getItem('theme') || 'automatic';
                let newTheme;
                if (savedTheme === 'light') {
                    newTheme = 'dark';
                } else if (savedTheme === 'dark') {
                    newTheme = 'automatic';
                } else {
                    newTheme = 'light';
                }
                applyTheme(newTheme);
            };

            const applyTheme = (theme) => {
                if (theme === 'automatic') {
                    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                    document.body.dataset.theme = prefersDark ? 'dark' : 'light';
                } else {
                    document.body.dataset.theme = theme;
                }
                localStorage.setItem('theme', theme);
                updateThemeButton();
            };

            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
                const savedTheme = localStorage.getItem('theme') || 'automatic';
                if (savedTheme === 'automatic') {
                    applyTheme('automatic');
                }
            });

            themeToggleBtn.addEventListener('click', cycleTheme);

            // --- Collapsible Sections ---
            const handleCollapsibleClick = (e) => {
                const header = e.target.closest('.collapsible-header');
                if (!header) return;

                const targetId = header.dataset.target;
                const content = document.getElementById(targetId);
                const icon = header.querySelector('.collapse-icon');
                const wrapper = header.parentElement;

                if (content && icon) {
                    const isCollapsed = content.classList.contains('collapsed');
                    
                    if (isCollapsed) {
                        // Expand
                        content.classList.remove('collapsed');
                        icon.classList.remove('collapsed');
                        wrapper.style.flexBasis = '33.33%';
                    } else {
                        // Collapse
                        content.classList.add('collapsed');
                        icon.classList.add('collapsed');
                        wrapper.style.flexBasis = '50px'; // Height of header only
                    }
                    
                    // Save collapsed state
                    const sectionName = targetId.replace('Content', '');
                    localStorage.setItem(`${sectionName}Collapsed`, !isCollapsed);
                    saveColumnSizes(); // Update saved sizes
                }
            };

            // Add event listeners for collapsible headers
            document.addEventListener('click', handleCollapsibleClick);

            // Load collapsed states
            const loadCollapsedStates = () => {
                const goalsCollapsed = localStorage.getItem('goalsCollapsed') === 'true';
                const notesCollapsed = localStorage.getItem('notesCollapsed') === 'true';

                if (goalsCollapsed) {
                    const goalsContent = document.getElementById('goalsContent');
                    const goalsIcon = document.querySelector('[data-target="goalsContent"] .collapse-icon');
                    const goalsWrapper = document.getElementById('goalsWrapper');
                    
                    goalsContent?.classList.add('collapsed');
                    goalsIcon?.classList.add('collapsed');
                    if (goalsWrapper) goalsWrapper.style.flexBasis = '50px';
                }

                if (notesCollapsed) {
                    const notesContent = document.getElementById('notesContent');
                    const notesIcon = document.querySelector('[data-target="notesContent"] .collapse-icon');
                    const notesWrapper = document.getElementById('notesWrapper');
                    
                    notesContent?.classList.add('collapsed');
                    notesIcon?.classList.add('collapsed');
                    if (notesWrapper) notesWrapper.style.flexBasis = '50px';
                }
            };

            // --- Resizable Panels ---
            function saveColumnSizes() {
                const panels = ['panelClients', 'panelAppointments', 'panelSession', 'panelSoap'];
                const sizes = panels.map(id => document.getElementById(id).style.flexBasis);
                localStorage.setItem('columnSizes', JSON.stringify(sizes));
                const sessionInfoHeight = document.getElementById('sessionInfoWrapper').style.flexBasis;
                const notesHeight = document.getElementById('notesWrapper').style.flexBasis;
                localStorage.setItem('rowSizes', JSON.stringify({ sessionInfoHeight, notesHeight }));
            }

            function loadColumnSizes() {
                const sizes = JSON.parse(localStorage.getItem('columnSizes'));
                if (sizes && sizes.length === 4) {
                    ['panelClients', 'panelAppointments', 'panelSession', 'panelSoap'].forEach((id, index) => {
                        const panel = document.getElementById(id);
                        if (panel) panel.style.flexBasis = sizes[index];
                    });
                }
                const rowSizes = JSON.parse(localStorage.getItem('rowSizes'));
                if (rowSizes) {
                    const sessionWrapper = document.getElementById('sessionInfoWrapper');
                    const notesWrapper = document.getElementById('notesWrapper');
                    if (sessionWrapper) sessionWrapper.style.flexBasis = rowSizes.sessionInfoHeight;
                    if (notesWrapper) notesWrapper.style.flexBasis = rowSizes.notesHeight;
                }
            }

            function makeResizable(resizer, prev, next, direction = 'x') {
                let x = 0;
                let y = 0;
                let prevSize = 0;
                let nextSize = 0;
                let containerSize = 0;

                resizer.addEventListener('mousedown', function (e) {
                    e.preventDefault();
                    if (direction === 'x') {
                        x = e.clientX;
                        prevSize = prev.getBoundingClientRect().width;
                        nextSize = next.getBoundingClientRect().width;
                        containerSize = prev.parentElement.getBoundingClientRect().width;
                    } else {
                        y = e.clientY;
                        prevSize = prev.getBoundingClientRect().height;
                        nextSize = next.getBoundingClientRect().height;
                        containerSize = prev.parentElement.getBoundingClientRect().height;
                    }
                    
                    document.body.style.cursor = direction === 'x' ? 'col-resize' : 'row-resize';
                    document.body.style.userSelect = 'none';

                    document.addEventListener('mousemove', mousemove);
                    document.addEventListener('mouseup', mouseup);
                });

                function mousemove(e) {
                    if (direction === 'x') {
                        const dx = e.clientX - x;
                        const newPrevSize = prevSize + dx;
                        const newNextSize = nextSize - dx;
                        
                        if(newPrevSize > 150 && newNextSize > 150) {
                            prev.style.flexBasis = `${(newPrevSize / containerSize) * 100}%`;
                            next.style.flexBasis = `${(newNextSize / containerSize) * 100}%`;
                        }
                    } else {
                        const dy = e.clientY - y;
                        const newPrevSize = prevSize + dy;
                        const newNextSize = nextSize - dy;

                        if(newPrevSize > 100 && newNextSize > 100) {
                            prev.style.flexBasis = `${(newPrevSize / containerSize) * 100}%`;
                            next.style.flexBasis = `${(newNextSize / containerSize) * 100}%`;
                        }
                    }
                }

                function mouseup() {
                    document.removeEventListener('mousemove', mousemove);
                    document.removeEventListener('mouseup', mouseup);
                    document.body.style.cursor = 'default';
                    document.body.style.userSelect = 'auto';
                    saveColumnSizes();
                }
            }
            
            // --- Initial Load & Render ---
            const loadServerSettings = () => {
                const savedProvider = localStorage.getItem('apiProvider');
                if (savedProvider) {
                    apiProvider = savedProvider;
                    apiProviderSelect.value = apiProvider;
                }
                
                const savedAddress = localStorage.getItem('serverAddress');
                const savedApiKey = localStorage.getItem('apiKey');
                const savedGeminiKey = localStorage.getItem('geminiApiKey');
                const savedOpenAIKey = localStorage.getItem('openaiApiKey');
                
                toggleProviderSettings(); // Set initial UI state

                if (apiProvider === 'openwebui' && savedAddress) {
                    serverAddressInput.value = savedAddress;
                    if(savedApiKey) apiKeyInput.value = savedApiKey;
                    connectToOpenWebUI();
                } else if (apiProvider === 'gemini' && savedGeminiKey) {
                    geminiApiKeyInput.value = savedGeminiKey;
                    connectToGemini();
                } else if (apiProvider === 'openai' && savedOpenAIKey) {
                    openaiApiKeyInput.value = savedOpenAIKey;
                    connectToOpenAI();
                }
            };
            
            const loadTheme = () => {
                const savedTheme = localStorage.getItem('theme') || 'automatic';
                applyTheme(savedTheme);
            };

            appointmentDateInput.value = new Date().toISOString().split('T')[0];
            loadDataFromLocalStorage(); // This now loads API settings too
            loadServerSettings();
            loadColumnSizes();
            loadCollapsedStates();
            loadTheme();
            fullRender();
            
            makeResizable(document.getElementById('resizer1'), document.getElementById('panelClients'), document.getElementById('panelAppointments'));
            makeResizable(document.getElementById('resizer2'), document.getElementById('panelAppointments'), document.getElementById('panelSession'));
            makeResizable(document.getElementById('resizer3'), document.getElementById('panelSession'), document.getElementById('panelSoap'));
            makeResizable(document.getElementById('resizer-session-goals'), document.getElementById('sessionInfoWrapper'), document.getElementById('goalsWrapper'), 'y');
            makeResizable(document.getElementById('resizer-goals-notes'), document.getElementById('goalsWrapper'), document.getElementById('notesWrapper'), 'y');

        });
    </script>
</body>
</html>

