<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mental Health Client Data Organizer</title>
    <style>
        :root {
            --bg-main: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --bg-container: white;
            --text-color-primary: #2c3e50;
            --text-color-secondary: #7f8c8d;
            --text-color-inverted: white;
            --panel-bg: #fafafa;
            --panel-border: #ecf0f1;
            --panel-footer-bg: #fdfdfd;
            --panel-header-bg: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            --item-bg: white;
            --item-active-bg: #e3f2fd;
            --item-border-color: #3498db;
            --item-active-border-color: #2196f3;
            --textarea-bg: white;
            --textarea-border: #ddd;
            --textarea-focus-border: #3498db;
            --textarea-focus-shadow: rgba(52, 152, 219, 0.2);
            --modal-bg: white;
            --modal-text: #333;
            --modal-header-border: #ccc;
            --input-bg: white;
            --input-text: #333;
            --input-border: #ccc;
            --suggestion-bg: #fff5f5;
            --suggestion-border: #e53e3e;
            --suggestion-text: #c53030;
            --resizer-bg: #ecf0f1;
            --deleted-item-text: #000;
        }

        [data-theme="dark"] {
            --bg-main: linear-gradient(135deg, #2c3e50 0%, #1a2533 100%);
            --bg-container: #2d3748;
            --text-color-primary: #e2e8f0;
            --text-color-secondary: #a0aec0;
            --text-color-inverted: #e2e8f0; /* Changed for better contrast on dark headers */
            --panel-bg: #283141;
            --panel-border: #4a5568;
            --panel-footer-bg: #232b38;
            --panel-header-bg: linear-gradient(135deg, #1a2533 0%, #2c3e50 100%);
            --item-bg: #4a5568;
            --item-active-bg: #718096;
            --item-border-color: #63b3ed;
            --item-active-border-color: #90cdf4;
            --appointment-item-active-bg: #5a4a63; /* Dark mode specific */
            --appointment-item-active-border: #c084fc; /* Dark mode specific */
            --textarea-bg: #2d3748;
            --textarea-border: #4a5568;
            --textarea-focus-border: #63b3ed;
            --textarea-focus-shadow: rgba(99, 179, 237, 0.3);
            --modal-bg: #2d3748;
            --modal-text: #e2e8f0;
            --modal-header-border: #4a5568;
            --input-bg: #4a5568;
            --input-text: #e2e8f0;
            --input-border: #718096;
            --suggestion-bg: #4c3030;
            --suggestion-border: #e53e3e;
            --suggestion-text: #fed7d7;
            --resizer-bg: #4a5568;
            --deleted-item-text: #e2e8f0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-main);
            min-height: 100vh;
            padding: 10px;
            overflow: hidden;
            color: var(--text-color-primary);
        }

        .container {
            width: 100%;
            margin: 0 auto;
            background: var(--bg-container);
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
            height: calc(100vh - 20px);
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: var(--text-color-inverted);
            padding: 12px 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }
        
        .header h1 {
            font-size: 1.5rem;
            margin-right: auto;
        }

        .btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        .btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }

        .btn.settings-btn {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
        }

        .btn.save-btn {
             background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        }

        .btn.theme-btn {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            padding: 0;
        }

        .main-content {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }

        .panel {
            border-right: 2px solid var(--panel-border);
            background: var(--panel-bg);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex-grow: 1; /* Allow panels to grow/shrink */
            flex-shrink: 1;
        }

        .panel:last-child {
            border-right: none;
        }
        
        .clients-panel { flex-basis: 20%; min-width: 180px; }
        .appointments-panel { flex-basis: 20%; min-width: 180px;}
        .session-panel { flex-basis: 30%; display: flex; flex-direction: column; min-width: 250px; }
        .soap-panel { flex-basis: 30%; min-width: 250px;}


        .panel-header {
            background: var(--panel-header-bg);
            color: var(--text-color-inverted);
            padding: 12px 15px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            height: 50px;
            min-height: 50px;
        }

        .add-btn {
            background: #27ae60;
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .add-btn:hover {
            background: #229954;
            transform: scale(1.1);
        }
        
        .add-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }

        .panel-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        .panel-footer {
            padding: 10px;
            border-top: 1px solid var(--panel-border);
            background: var(--panel-footer-bg);
            flex-shrink: 0;
        }
        
        input[type="date"] {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--input-border);
            border-radius: 4px;
            font-size: 14px;
            font-family: inherit;
            background-color: var(--input-bg);
            color: var(--input-text);
        }

        /* Client Panel */
        .client-item {
            background: var(--item-bg);
            margin-bottom: 8px;
            padding: 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 4px solid var(--item-border-color);
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .client-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .client-item.active {
            background: var(--item-active-bg);
            border-left-color: var(--item-active-border-color);
            font-weight: bold;
        }
        
        .client-item.dragging {
            opacity: 0.5;
        }
        
        .action-buttons {
            position: absolute;
            top: 5px; right: 5px;
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }
        .client-item:hover .action-buttons, .appointment-item:hover .action-buttons {
            opacity: 1;
        }
        .action-btn {
            border: none; color: white;
            width: 20px; height: 20px;
            border-radius: 50%;
            cursor: pointer; font-size: 12px;
            display: flex; align-items: center; justify-content: center;
        }
        .archive-btn { background: #f39c12; }
        .delete-btn { background: #e74c3c; }
        .edit-btn { background: #3498db; }

        /* Appointments Panel */
        .appointment-item {
            background: var(--item-bg); margin-bottom: 8px; padding: 10px;
            border-radius: 6px; cursor: pointer; transition: all 0.2s ease;
            border-left: 4px solid #9b59b6; position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .appointment-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
        }
        .appointment-item.active {
            background: var(--appointment-item-active-bg, #f3e5f5);
            border-left-color: var(--appointment-item-active-border, #9c27b0);
        }
        .appointment-date { font-weight: 600; color: var(--text-color-primary); }

        /* Session and SOAP Panels */
        textarea {
            width: 100%; border: 1px solid var(--textarea-border); border-radius: 6px;
            padding: 12px; font-family: inherit; font-size: 14px;
            resize: both; /* Allow vertical and horizontal resizing */
            transition: all 0.2s;
            min-height: 50px; /* Ensure a minimum height */
            overflow: auto; /* Show scrollbars when content overflows */
            background-color: var(--textarea-bg);
            color: var(--text-color-primary);
        }
        textarea:focus {
            outline: none; border-color: var(--textarea-focus-border);
            box-shadow: 0 0 0 2px var(--textarea-focus-shadow);
        }
        
        .session-section {
            display: flex; flex-direction: column;
            flex-grow: 1; min-height: 0;
        }
        .session-section .panel-header {
             background: linear-gradient(135deg, #16a085 0%, #138d75 100%);
        }
        .session-section .panel-content {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
        }
        .session-section textarea {
            flex-grow: 1;
        }
        .persistent-notes-section .panel-header {
             background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }

        .soap-section { margin-bottom: 15px; }
        .soap-header {
            background: linear-gradient(135deg, #5D6D7E 0%, #34495E 100%);
            color: var(--text-color-inverted); padding: 8px 12px;
            border-radius: 6px 6px 0 0; font-weight: 600;
            display: flex; justify-content: space-between; align-items: center;
        }
        .copy-btn {
            background: rgba(255, 255, 255, 0.2); border: none; color: var(--text-color-inverted);
            padding: 4px 8px; border-radius: 4px; cursor: pointer;
            font-size: 12px; transition: all 0.2s;
        }
        .copy-btn:hover { background: rgba(255, 255, 255, 0.3); }
        .soap-textarea {
            border-radius: 0 0 6px 6px; border-top: none;
            flex-grow: 1;
            /* overflow-y: hidden; is removed to allow manual resize */
        }

        .suggestion-box {
            background-color: var(--suggestion-bg);
            border: 1px solid var(--suggestion-border);
            border-radius: 6px;
            padding: 10px;
            margin-top: 8px;
            font-size: 14px;
        }
        .suggestion-text {
            color: var(--suggestion-text);
            margin-bottom: 8px;
        }
        .suggestion-actions button {
            background: none;
            border: 1px solid;
            border-radius: 4px;
            padding: 2px 8px;
            font-size: 12px;
            cursor: pointer;
            margin-right: 5px;
        }
        .suggestion-accept { color: #27ae60; border-color: #27ae60; }
        .suggestion-accept-replace { color: #27ae60; border-color: #27ae60; }
        .suggestion-decline { color: #e74c3c; border-color: #e74c3c; }

        .no-selection {
            color: var(--text-color-secondary); text-align: center;
            margin-top: 50px; font-style: italic;
        }
        .autosave-indicator { color: var(--text-color-inverted); font-size: 12px; margin-left: auto; }
        
        .deleted-list { max-height: 100px; overflow-y: auto; }
        .deleted-item { display: flex; justify-content: space-between; align-items: center; font-size: 0.8rem; padding: 2px 0; color: var(--deleted-item-text); }
        .restore-btn {
             background: #3498db; color: white; border: none;
             padding: 2px 6px; border-radius: 4px; cursor: pointer;
        }
        .clear-deleted-btn {
            background: #e74c3c; color: white; border: none;
            padding: 2px 6px; border-radius: 4px; cursor: pointer;
            width: 100%; margin-top: 5px;
        }

        .resizer {
            background: var(--resizer-bg);
            cursor: col-resize;
            width: 6px;
            flex-shrink: 0;
            z-index: 10;
        }
        .resizer-y {
            background: var(--resizer-bg);
            cursor: row-resize;
            height: 6px;
            flex-shrink: 0;
            z-index: 10;
        }
        
        .hidden {
            display: none !important;
        }
        
        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: var(--modal-bg);
            padding: 24px;
            border-radius: 12px;
            width: 100%;
            max-width: 512px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            position: relative; /* For the close button */
            color: var(--modal-text);
        }


    </style>
</head>
<body data-theme="light">
    <div class="container">
        <div class="header">
            <h1>Client Data Organizer <span style="font-size: 0.8rem; font-weight: normal; vertical-align: middle;">v.0.0.26</span></h1>
            <div id="autoSaveIndicator" class="autosave-indicator" style="opacity: 0;">
                <span id="saveStatus"></span>
            </div>
            <button id="manualSaveBtn" class="btn save-btn">Save Now</button>
            <button id="settingsBtn" class="btn settings-btn">Settings</button>
            <button id="themeToggleBtn" class="btn theme-btn" title="Toggle Theme">🌙</button>
        </div>

        <div class="main-content" id="mainGrid">
            <!-- Clients Panel -->
            <div class="panel clients-panel" id="panelClients">
                <div class="panel-header">
                    <span>Clients</span>
                    <div style="display: flex; align-items: center;">
                        <button id="sortClientsBtn" title="Sort A-Z" class="btn" style="padding: 2px 6px; font-size: 12px; margin-right: 8px;">A-Z</button>
                        <button id="addClientBtn" class="add-btn">+</button>
                    </div>
                </div>
                <div class="panel-content" id="clientList">
                    <div class="no-selection">Click + to add a client</div>
                </div>
                <div class="panel-footer">
                     <h3 style="color: var(--text-color-secondary); font-weight: 600; margin-bottom: 0.5rem; font-size: 0.875rem;">Recently Deleted</h3>
                     <div id="deletedClientsList" class="deleted-list"></div>
                     <button id="clearDeletedClientsBtn" class="clear-deleted-btn hidden">Clear All</button>
                </div>
                 <div class="panel-footer">
                     <h3 style="color: var(--text-color-secondary); font-weight: 600; margin-bottom: 0.5rem; font-size: 0.875rem;">Archived</h3>
                     <div id="archivedClientsList" class="deleted-list"></div>
                </div>
            </div>

            <div class="resizer" id="resizer1"></div>

            <!-- Appointments Panel -->
            <div class="panel appointments-panel" id="panelAppointments">
                <div class="panel-header">
                    <span>Appointments</span>
                </div>
                <div class="panel-content" id="appointmentList">
                    <div class="no-selection">Select a client first</div>
                </div>
                <div class="panel-footer">
                     <label for="appointmentDateInput" style="font-weight: 600; color: var(--text-color-secondary); font-size: 0.875rem; margin-bottom: 4px; display: block;">Appointment Date</label>
                     <div style="display: flex; align-items: center; gap: 8px;">
                         <input type="date" id="appointmentDateInput" style="flex-grow: 1;">
                         <button class="add-btn" id="addAppointmentBtn" disabled>+</button>
                         <button id="updateAppointmentDateBtn" class="btn hidden" style="padding: 4px 8px; font-size: 0.8rem;">Update</button>
                     </div>
                </div>
                 <div class="panel-footer">
                     <h3 style="color: var(--text-color-secondary); font-weight: 600; margin-bottom: 0.5rem; font-size: 0.875rem;">Recently Deleted</h3>
                     <div id="deletedAppointmentsList" class="deleted-list"></div>
                     <button id="clearDeletedAppointmentsBtn" class="clear-deleted-btn hidden">Clear All</button>
                </div>
            </div>

            <div class="resizer" id="resizer2"></div>

            <!-- Session & Notes Panel -->
            <div class="panel session-panel" id="panelSession">
                 <div id="sessionInfoWrapper" class="session-section" style="flex-basis: 50%;">
                    <div class="panel-header">
                        <span>Session Information</span>
                        <button id="generateNoteBtn" class="btn" style="padding: 4px 8px; font-size: 0.8rem;" disabled>Generate Note</button>
                    </div>
                    <div class="panel-content">
                         <textarea id="sessionInfo" placeholder="Select an appointment to enter session details..." disabled autocorrect="off" autocapitalize="off" spellcheck="true"></textarea>
                    </div>
                    <div class="panel-footer" id="sessionTimerWrapper" style="display: none;">
                        <div style="display: flex; justify-content: space-between; align-items: center; gap: 10px;">
                            <button id="startTimerBtn" class="btn" style="flex-grow: 1;">Start</button>
                            <button id="stopTimerBtn" class="btn" style="flex-grow: 1;">Stop</button>
                            <div id="sessionDuration" style="font-weight: 600; white-space: nowrap;">00:00</div>
                        </div>
                    </div>
                </div>
                <div class="resizer-y" id="resizer-session-notes"></div>
                 <div id="notesWrapper" class="session-section persistent-notes-section" style="flex-basis: 50%;">
                    <div class="panel-header">
                        <span>Persistent Notes</span>
                    </div>
                    <div class="panel-content">
                         <textarea id="persistentNotes" placeholder="Select a client to enter persistent notes..." disabled autocorrect="off" autocapitalize="off" spellcheck="true"></textarea>
                    </div>
                </div>
            </div>

            <div class="resizer" id="resizer3"></div>

            <!-- SOAP Notes Panel -->
            <div class="panel soap-panel" id="panelSoap">
                <div class="panel-header">
                    <span>SOAP Note</span>
                </div>
                <div class="panel-content" id="soapContent">
                    <div class="no-selection">Select an appointment to begin</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div id="settingsModal" class="modal-overlay hidden">
        <div class="modal-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid var(--modal-header-border);">
                <h2 style="font-size: 1.5rem; font-weight: bold;">Settings</h2>
                <button id="closeSettingsBtn" style="font-size: 2rem; background: none; border: none; cursor: pointer; color: inherit;">&times;</button>
            </div>

            <div style="margin-bottom: 1.5rem;">
                <h3 style="font-size: 1.25rem; font-weight: 600; margin-bottom: 0.75rem;">Connection</h3>
                <div style="display: flex; flex-direction: column; gap: 1rem;">
                    <div>
                        <label for="apiProviderSelect" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">API Provider</label>
                        <select id="apiProviderSelect" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);">
                            <option value="openwebui">Open WebUI</option>
                            <option value="gemini">Google Gemini</option>
                        </select>
                    </div>

                    <div id="openwebuiSettings">
                        <div>
                            <label for="serverAddressInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">Open WebUI Address</label>
                            <input type="text" id="serverAddressInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);" placeholder="e.g., http://localhost:3000">
                        </div>
                        <div>
                            <label for="apiKeyInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">API Key (optional)</label>
                            <input type="password" id="apiKeyInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);">
                        </div>
                    </div>

                    <div id="geminiSettings" class="hidden">
                        <div>
                            <label for="geminiApiKeyInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">Gemini API Key</label>
                            <input type="password" id="geminiApiKeyInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);">
                        </div>
                         <div>
                            <label for="geminiModelInput" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">Gemini Model</label>
                            <select id="geminiModelInput" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);" disabled>
                                <option>Enter API Key first</option>
                            </select>
                        </div>
                    </div>

                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <button id="connectApiBtn" class="btn">Connect</button>
                        <span id="apiStatus" style="font-size: 0.875rem; font-weight: 600;"></span>
                    </div>
                    <div id="modelSelectWrapper">
                         <label for="modelSelect" style="margin-bottom: 0.25rem; font-weight: 600; display: block;">AI Model</label>
                         <select id="modelSelect" style="border: 1px solid var(--input-border); border-radius: 6px; padding: 8px; width: 100%; background-color: var(--input-bg); color: var(--input-text);" disabled>
                            <option>Connect to server first</option>
                        </select>
                    </div>
                </div>
            </div>

            <div style="margin-bottom: 1.5rem;">
                <h3 style="font-size: 1.25rem; font-weight: 600; margin-bottom: 0.75rem;">Data Management</h3>
                <div style="display: flex; flex-wrap: wrap; gap: 1rem;">
                     <button id="exportBtn" class="btn">Export Data</button>
                     <button id="importBtn" class="btn" style="background: linear-gradient(135deg, #7f8c8d 0%, #95a5a6 100%);">Import Data</button>
                     <button id="eraseAllBtn" class="btn save-btn">Erase All Data</button>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" class="hidden" accept="application/json">

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const clientListEl = document.getElementById('clientList');
            const addClientBtn = document.getElementById('addClientBtn');
            const sortClientsBtn = document.getElementById('sortClientsBtn');
            const appointmentListEl = document.getElementById('appointmentList');
            const addAppointmentBtn = document.getElementById('addAppointmentBtn');
            const appointmentDateInput = document.getElementById('appointmentDateInput');
            const updateAppointmentDateBtn = document.getElementById('updateAppointmentDateBtn');
            const deletedClientsListEl = document.getElementById('deletedClientsList');
            const clearDeletedClientsBtn = document.getElementById('clearDeletedClientsBtn');
            const archivedClientsListEl = document.getElementById('archivedClientsList');
            const deletedAppointmentsListEl = document.getElementById('deletedAppointmentsList');
            const clearDeletedAppointmentsBtn = document.getElementById('clearDeletedAppointmentsBtn');
            const persistentNotesEl = document.getElementById('persistentNotes');
            const sessionInfoEl = document.getElementById('sessionInfo');
            const soapContentEl = document.getElementById('soapContent');
            const autoSaveIndicator = document.getElementById('autoSaveIndicator');
            const saveStatus = document.getElementById('saveStatus');
            // Session Timer Elements
            const sessionTimerWrapper = document.getElementById('sessionTimerWrapper');
            const startTimerBtn = document.getElementById('startTimerBtn');
            const stopTimerBtn = document.getElementById('stopTimerBtn');
            const sessionDurationEl = document.getElementById('sessionDuration');
            // Settings and Modal Elements
            const settingsBtn = document.getElementById('settingsBtn');
            const settingsModal = document.getElementById('settingsModal');
            const closeSettingsBtn = document.getElementById('closeSettingsBtn');
            const manualSaveBtn = document.getElementById('manualSaveBtn');
            const exportBtn = document.getElementById('exportBtn');
            const importBtn = document.getElementById('importBtn');
            const eraseAllBtn = document.getElementById('eraseAllBtn');
            // AI Integration Elements
            const apiProviderSelect = document.getElementById('apiProviderSelect');
            const openwebuiSettings = document.getElementById('openwebuiSettings');
            const serverAddressInput = document.getElementById('serverAddressInput');
            const apiKeyInput = document.getElementById('apiKeyInput');
            const geminiSettings = document.getElementById('geminiSettings');
            const geminiApiKeyInput = document.getElementById('geminiApiKeyInput');
            const geminiModelInput = document.getElementById('geminiModelInput');
            const connectApiBtn = document.getElementById('connectApiBtn');
            const apiStatus = document.getElementById('apiStatus');
            const modelSelect = document.getElementById('modelSelect');
            const modelSelectWrapper = document.getElementById('modelSelectWrapper');
            const generateNoteBtn = document.getElementById('generateNoteBtn');
            const fileInput = document.getElementById('fileInput');
            const themeToggleBtn = document.getElementById('themeToggleBtn');

            // App State
            let data = { clients: [], archivedClients: [] };
            let deletedItems = { clients: [], appointments: [] };
            let selectedClientId = null;
            let selectedAppointmentId = null;
            let isDirty = false;
            let apiProvider = 'openwebui';
            let serverAddress = null;
            let apiKey = null;
            let geminiApiKey = null;
            let selectedModel = null;
            let sessionTimerInterval = null;
            const getInitialData = () => ({ clients: [], archivedClients: [] });

            // --- Data Management ---
            const findClient = id => data.clients.find(c => c.id === id) || data.archivedClients.find(c => c.id === id);
            const findAppointment = (client, id) => client?.appointments.find(a => a.id === id);
            
            // --- UI Rendering ---
            const renderClients = () => {
                // Note: Drag and drop reordering means we can't sort here anymore.
                // The array order is now the source of truth for display order.
                const clients = data.clients; 
                if (clients.length === 0) {
                    clientListEl.innerHTML = '<div class="no-selection">Click + to add a client</div>';
                    return;
                }
                clientListEl.innerHTML = clients.map(client => `
                    <div class="client-item ${client.id === selectedClientId ? 'active' : ''}" data-client-id="${client.id}" draggable="true">
                        ${client.name}
                        <div class="action-buttons">
                            <button class="action-btn edit-btn" title="Edit Name">✏️</button>
                            <button class="action-btn archive-btn" title="Archive Client">A</button>
                            <button class="action-btn delete-btn" title="Delete Client">×</button>
                        </div>
                    </div>
                `).join('');
            };

            const renderAppointments = () => {
                const client = findClient(selectedClientId);
                addAppointmentBtn.disabled = !client;
                if (!client) {
                    appointmentListEl.innerHTML = '<div class="no-selection">Select a client first</div>';
                    return;
                }
                const appointments = (client.appointments || []).sort((a, b) => new Date(b.date) - new Date(a.date));
                if (appointments.length === 0) {
                    appointmentListEl.innerHTML = '<div class="no-selection">Click + to add appointment</div>';
                    return;
                }
                appointmentListEl.innerHTML = appointments.map(appt => `
                    <div class="appointment-item ${appt.id === selectedAppointmentId ? 'active' : ''}" data-appointment-id="${appt.id}">
                        <div class="appointment-date">${new Date(appt.date).toLocaleDateString()}</div>
                        <div class="action-buttons">
                            <button class="action-btn delete-btn" title="Delete Appointment">×</button>
                        </div>
                    </div>
                `).join('');
            };

            const renderDetails = () => {
                const client = findClient(selectedClientId);
                const appointment = client ? findAppointment(client, selectedAppointmentId) : null;
                
                persistentNotesEl.disabled = !client;
                persistentNotesEl.value = client ? client.persistentNotes || '' : '';
                persistentNotesEl.placeholder = client ? "Enter persistent notes for this client..." : "Select a client to enter persistent notes...";

                sessionInfoEl.disabled = !appointment;
                sessionInfoEl.value = appointment ? appointment.sessionInfo || '' : '';
                sessionInfoEl.placeholder = appointment ? "Enter session details..." : "Select an appointment to begin...";
                
                updateAppointmentDateBtn.classList.toggle('hidden', !appointment);
                addAppointmentBtn.classList.toggle('hidden', !!appointment);

                sessionTimerWrapper.style.display = appointment ? 'block' : 'none';
                if (appointment) {
                    renderSessionTimer(appointment);
                }

                renderSoap();
                
                generateNoteBtn.disabled = !appointment || !selectedModel || !sessionInfoEl.value.trim();
            };
            
            const renderSessionTimer = (appointment) => {
                clearInterval(sessionTimerInterval);

                if (appointment.startTime) {
                    startTimerBtn.textContent = `Start: ${new Date(appointment.startTime).toLocaleTimeString()}`;
                } else {
                    startTimerBtn.textContent = 'Start';
                }

                if (appointment.endTime) {
                    stopTimerBtn.textContent = `End: ${new Date(appointment.endTime).toLocaleTimeString()}`;
                } else {
                    stopTimerBtn.textContent = 'Stop';
                }

                const updateDuration = () => {
                    if (!appointment.startTime) {
                        sessionDurationEl.textContent = '00:00';
                        return;
                    }
                    
                    const start = new Date(appointment.startTime);
                    const end = appointment.endTime ? new Date(appointment.endTime) : new Date();
                    
                    let totalSeconds = Math.floor((end - start) / 1000);
                    if (totalSeconds < 0) totalSeconds = 0;

                    const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
                    const seconds = (totalSeconds % 60).toString().padStart(2, '0');
                    
                    sessionDurationEl.textContent = `${minutes}:${seconds}`;
                };

                updateDuration();

                // If the timer is running (start time exists but no end time), set an interval to update it.
                if (appointment.startTime && !appointment.endTime) {
                    sessionTimerInterval = setInterval(updateDuration, 1000);
                }
            };

            const renderSoap = () => {
                const client = findClient(selectedClientId);
                const appointment = client ? findAppointment(client, selectedAppointmentId) : null;

                if (!appointment) {
                    soapContentEl.innerHTML = '<div class="no-selection">Select an appointment to begin</div>';
                    return;
                }

                const soapData = appointment.soap || { s: '', o: '', a: '', p: '' };
                const interventions = soapData.interventions || extractInterventions(soapData);
                soapContentEl.innerHTML = `
                    <div class="soap-section">
                        <div class="soap-header"><span>Subjective</span><button class="copy-btn" data-target="soapS">Copy</button></div>
                        <textarea id="soapS" class="soap-textarea" placeholder="• " autocorrect="off" autocapitalize="off" spellcheck="true">${soapData.s || ''}</textarea>
                        ${(soapData.s_suggestion || []).map((s, i) => renderSuggestionBox('s', s, i)).join('')}
                    </div>
                    <div class="soap-section">
                        <div class="soap-header"><span>Objective</span><button class="copy-btn" data-target="soapO">Copy</button></div>
                        <textarea id="soapO" class="soap-textarea" placeholder="• " autocorrect="off" autocapitalize="off" spellcheck="true">${soapData.o || ''}</textarea>
                        ${(soapData.o_suggestion || []).map((s, i) => renderSuggestionBox('o', s, i)).join('')}
                    </div>
                    <div class="soap-section">
                        <div class="soap-header"><span>Assessment</span><button class="copy-btn" data-target="soapA">Copy</button></div>
                        <textarea id="soapA" class="soap-textarea" placeholder="• " autocorrect="off" autocapitalize="off" spellcheck="true">${soapData.a || ''}</textarea>
                        ${(soapData.a_suggestion || []).map((s, i) => renderSuggestionBox('a', s, i)).join('')}
                    </div>
                    <div class="soap-section">
                        <div class="soap-header"><span>Plan</span><button class="copy-btn" data-target="soapP">Copy</button></div>
                        <textarea id="soapP" class="soap-textarea" placeholder="• " autocorrect="off" autocapitalize="off" spellcheck="true">${soapData.p || ''}</textarea>
                        ${(soapData.p_suggestion || []).map((s, i) => renderSuggestionBox('p', s, i)).join('')}
                    </div>
                    <div class="soap-section">
                        <div class="soap-header"><span>Interventions</span><button class="copy-btn" data-target="interventions">Copy</button></div>
                        <textarea id="interventions" class="soap-textarea" autocorrect="off" autocapitalize="off" spellcheck="true">${interventions}</textarea>
                    </div>`;
                
                // After rendering, resize all textareas
                soapContentEl.querySelectorAll('.soap-textarea').forEach(el => {
                    if (!el.readOnly) { // Don't auto-resize the read-only interventions box
                        autoResizeTextarea(el);
                    }
                });
            };

            const renderSuggestionBox = (type, suggestion, index) => {
                if (!suggestion) return '';

                let suggestionTitle = 'Suggestion:';
                let suggestionContent = `<strong>${suggestionTitle}</strong> ${suggestion}`;
                let actionsHtml = `
                    <button class="suggestion-accept">Accept</button>
                    <button class="suggestion-decline">Decline</button>
                `;

                // For S and O, we are replacing text, so show a different interface
                if (['s', 'o'].includes(type) && typeof suggestion === 'object' && suggestion.original && suggestion.suggested) {
                    suggestionTitle = 'Clinical Language Suggestion:';
                    suggestionContent = `
                        <div><strong>Original:</strong> ${suggestion.original}</div>
                        <div style="margin-top: 4px;"><strong>Suggested:</strong> ${suggestion.suggested}</div>
                    `;
                    actionsHtml = `
                        <button class="suggestion-decline">Keep Original</button>
                        <button class="suggestion-accept-replace">Use Suggestion</button>
                    `;
                } else if (['s', 'o'].includes(type)) {
                    // Fallback for old string format suggestions for S and O
                    suggestionTitle = 'Clinical Language Suggestion:';
                    suggestionContent = `<strong>${suggestionTitle}</strong> ${suggestion}`;
                     actionsHtml = `
                        <button class="suggestion-decline">Keep Original</button>
                        <button class="suggestion-accept-replace">Use Suggestion</button>
                    `;
                }


                return `
                    <div class="suggestion-box" data-suggestion-type="${type}" data-suggestion-index="${index}">
                        <div class="suggestion-text">${suggestionContent}</div>
                        <div class="suggestion-actions">
                            ${actionsHtml}
                        </div>
                    </div>
                `;
            };

            const renderDeletedLists = () => {
                deletedClientsListEl.innerHTML = '';
                clearDeletedClientsBtn.classList.toggle('hidden', deletedItems.clients.length === 0);
                deletedItems.clients.forEach(client => {
                    const div = document.createElement('div');
                    div.className = 'deleted-item';
                    div.innerHTML = `<span>${client.name}</span><button class="restore-btn" data-id="${client.id}">Restore</button>`;
                    deletedClientsListEl.appendChild(div);
                });

                deletedAppointmentsListEl.innerHTML = '';
                 clearDeletedAppointmentsBtn.classList.toggle('hidden', deletedItems.appointments.length === 0);
                deletedItems.appointments.forEach(appt => {
                    const clientName = findClient(appt.clientId)?.name?.substring(0, 5) + '...' || 'N/A';
                    const div = document.createElement('div');
                    div.className = 'deleted-item';
                    div.innerHTML = `<span>${new Date(appt.date).toLocaleDateString()} (${clientName})</span><button class="restore-btn" data-id="${appt.id}">Restore</button>`;
                    deletedAppointmentsListEl.appendChild(div);
                });
            };

            const renderArchivedClients = () => {
                archivedClientsListEl.innerHTML = '';
                (data.archivedClients || []).forEach(client => {
                     const div = document.createElement('div');
                     div.className = 'deleted-item';
                     div.innerHTML = `<span>${client.name}</span><button class="restore-btn" data-id="${client.id}">Unarchive</button>`;
                     archivedClientsListEl.appendChild(div);
                });
            };

            const fullRender = () => {
                renderClients();
                renderAppointments();
                renderDetails();
                renderDeletedLists();
                renderArchivedClients();
            };

            // --- Event Handlers & Actions ---
            const selectClient = (id) => {
                selectedClientId = id;
                selectedAppointmentId = null;
                clearInterval(sessionTimerInterval); // Stop timer when switching clients
                fullRender();
            };

            const selectAppointment = (id) => {
                selectedAppointmentId = id;
                fullRender();
            };

            const addClient = () => {
                const name = prompt("Enter new client's name:");
                if (!name || !name.trim()) return;
                const newClient = {
                    id: crypto.randomUUID(),
                    name: name.trim(),
                    persistentNotes: '',
                    appointments: []
                };
                data.clients.push(newClient);
                selectClient(newClient.id);
                markDirty();
            };

            const addAppointment = () => {
                const client = findClient(selectedClientId);
                if (!client) return;
                const date = appointmentDateInput.value;
                if (!date) {
                    alert('Please select a date for the appointment.');
                    return;
                }
                const dateObj = new Date(date);
                const utcDate = new Date(dateObj.getUTCFullYear(), dateObj.getUTCMonth(), dateObj.getUTCDate());

                const newAppointment = {
                    id: crypto.randomUUID(),
                    date: utcDate.toISOString(),
                    sessionInfo: '',
                    startTime: null,
                    endTime: null,
                    soap: { s: '', o: '', a: '', p: '' }
                };
                client.appointments.push(newAppointment);
                selectAppointment(newAppointment.id);
                markDirty();
            };
            
            clientListEl.addEventListener('click', (e) => {
                const clientItem = e.target.closest('.client-item');
                if (!clientItem) return;

                const clientId = clientItem.dataset.clientId;

                if (e.target.classList.contains('delete-btn')) {
                     const client = findClient(clientId);
                     if (confirm(`Are you sure you want to delete ${client.name}?`)) {
                        const clientIndex = data.clients.findIndex(c => c.id === clientId);
                        if (clientIndex === -1) return;
                        const [removedClient] = data.clients.splice(clientIndex, 1);
                        if (removedClient.appointments) {
                             deletedItems.appointments.push(...removedClient.appointments.map(a => ({...a, clientId})));
                        }
                        deletedItems.clients.push(removedClient);
                        if (selectedClientId === clientId) {
                            selectedClientId = null;
                            selectedAppointmentId = null;
                        }
                        markDirty();
                        fullRender();
                     }
                } else if (e.target.classList.contains('archive-btn')) {
                    const clientIndex = data.clients.findIndex(c => c.id === clientId);
                    if (clientIndex === -1) return;
                    const [client] = data.clients.splice(clientIndex, 1);
                    if (!data.archivedClients) data.archivedClients = [];
                    data.archivedClients.push(client);
                    if (selectedClientId === clientId) {
                        selectedClientId = null;
                        selectedAppointmentId = null;
                    }
                    markDirty();
                    fullRender();
                } else if (e.target.classList.contains('edit-btn')) {
                    const client = findClient(clientId);
                    if (!client) return;
                    const newName = prompt(`Enter new name for ${client.name}:`, client.name);
                    if (newName && newName.trim() && newName.trim() !== client.name) {
                        client.name = newName.trim();
                        markDirty();
                        fullRender();
                    }
                } else {
                    selectClient(clientId);
                }
            });

            // --- Drag and Drop Client Reordering ---
            let draggedClientId = null;

            clientListEl.addEventListener('dragstart', (e) => {
                const clientItem = e.target.closest('.client-item');
                if (clientItem) {
                    draggedClientId = clientItem.dataset.clientId;
                    // Add a class for visual feedback
                    setTimeout(() => clientItem.classList.add('dragging'), 0);
                }
            });

            clientListEl.addEventListener('dragend', (e) => {
                const clientItem = e.target.closest('.client-item');
                if (clientItem) {
                    clientItem.classList.remove('dragging');
                }
                draggedClientId = null;
            });

            clientListEl.addEventListener('dragover', (e) => {
                e.preventDefault(); // Necessary to allow dropping
                const targetItem = e.target.closest('.client-item');
                if (targetItem && targetItem.dataset.clientId !== draggedClientId) {
                    // This is where you could add a visual indicator if desired
                }
            });

            clientListEl.addEventListener('drop', (e) => {
                e.preventDefault();
                const targetItem = e.target.closest('.client-item');
                if (targetItem && draggedClientId) {
                    const targetId = targetItem.dataset.clientId;
                    
                    const draggedIndex = data.clients.findIndex(c => c.id === draggedClientId);
                    const targetIndex = data.clients.findIndex(c => c.id === targetId);

                    if (draggedIndex > -1 && targetIndex > -1) {
                        // Remove the dragged item
                        const [draggedItem] = data.clients.splice(draggedIndex, 1);
                        // Insert it at the target's position
                        data.clients.splice(targetIndex, 0, draggedItem);
                        
                        markDirty();
                        renderClients(); // Re-render to reflect the new order
                    }
                }
            });

            appointmentListEl.addEventListener('click', (e) => {
                 const appointmentItem = e.target.closest('.appointment-item');
                 if (!appointmentItem) {
                     selectAppointment(null);
                     return;
                 }

                 const appointmentId = appointmentItem.dataset.appointmentId;
                 
                 if (e.target.classList.contains('delete-btn')) {
                    const client = findClient(selectedClientId);
                    if (!client) return;
                    const apptIndex = client.appointments.findIndex(a => a.id === appointmentId);
                    if (apptIndex > -1) {
                        const [appt] = client.appointments.splice(apptIndex, 1);
                        deletedItems.appointments.push({ ...appt, clientId: client.id });
                        if (selectedAppointmentId === appointmentId) {
                            selectedAppointmentId = null;
                        }
                        markDirty();
                        fullRender();
                    }
                 } else {
                     selectAppointment(appointmentId);
                 }
            });
            
            updateAppointmentDateBtn.addEventListener('click', () => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                const newDateStr = appointmentDateInput.value;

                if (client && appointment && newDateStr) {
                    const dateObj = new Date(newDateStr);
                    const utcDate = new Date(dateObj.getUTCFullYear(), dateObj.getUTCMonth(), dateObj.getUTCDate());
                    appointment.date = utcDate.toISOString();
                    markDirty();
                    renderAppointments(); // Just re-render appointments to see the change
                    alert('Appointment date updated.');
                } else {
                    alert('Could not update date. Ensure a client, appointment, and date are selected.');
                }
            });

            deletedClientsListEl.addEventListener('click', e => {
                if (e.target.classList.contains('restore-btn')) {
                    const id = e.target.dataset.id;
                    const clientIndex = deletedItems.clients.findIndex(c => c.id === id);
                    if (clientIndex === -1) return;
                    const [client] = deletedItems.clients.splice(clientIndex, 1);
                    data.clients.push(client);
                    markDirty();
                    fullRender();
                }
            });

            archivedClientsListEl.addEventListener('click', e => {
                if (e.target.classList.contains('restore-btn')) {
                    const id = e.target.dataset.id;
                    if (!data.archivedClients) return;
                    const clientIndex = data.archivedClients.findIndex(c => c.id === id);
                    if (clientIndex === -1) return;
                    const [client] = data.archivedClients.splice(clientIndex, 1);
                    data.clients.push(client);
                    markDirty();
                    fullRender();
                }
            });

            deletedAppointmentsListEl.addEventListener('click', e => {
                 if (e.target.classList.contains('restore-btn')) {
                    const id = e.target.dataset.id;
                    const apptIndex = deletedItems.appointments.findIndex(a => a.id === id);
                    if (apptIndex === -1) return;

                    const [appt] = deletedItems.appointments.splice(apptIndex, 1);
                    const client = findClient(appt.clientId);
                    if (client) {
                        if (!client.appointments) client.appointments = [];
                        client.appointments.push(appt);
                        markDirty();
                        fullRender();
                    } else {
                        deletedItems.appointments.push(appt);
                        alert('Cannot restore. Client not found.');
                    }
                 }
            });
            
            clearDeletedClientsBtn.addEventListener('click', () => {
                if(confirm('Permanently delete all recently deleted clients?')) {
                    deletedItems.clients = [];
                    markDirty();
                    fullRender();
                }
            });
            clearDeletedAppointmentsBtn.addEventListener('click', () => {
                 if(confirm('Permanently delete all recently deleted appointments?')) {
                    deletedItems.appointments = [];
                    markDirty();
                    fullRender();
                }
            });
            
            persistentNotesEl.addEventListener('input', () => {
                 const client = findClient(selectedClientId);
                 if (client) {
                     client.persistentNotes = persistentNotesEl.value;
                     markDirty();
                 }
            });

            const autoResizeTextarea = (el) => {
                // Only resize if the user hasn't manually resized it.
                // We check if the style.height is not set or is 'auto'.
                if (!el.style.height || el.style.height === 'auto') {
                    el.style.height = 'auto';
                    el.style.height = el.scrollHeight + 'px';
                }
            };

            // --- Generic Bullet Point Handlers ---
            const formatBulletPoints = (text) => {
                // Split text into individual bullet points and ensure each is on its own line
                let content = text.trim();
                if (!content) return '';
                
                // Replace any bullet points that are not at the start of a line
                content = content.replace(/([^\n])\s*•\s*/g, '$1\n• ');
                
                // Split into lines and process each one
                let lines = content.split('\n');
                let newLines = lines.map(line => {
                    let trimmedLine = line.trim();
                    if (trimmedLine.length > 0) {
                        if (!trimmedLine.startsWith('•')) {
                            return '• ' + trimmedLine;
                        } else {
                            // Ensure proper spacing after bullet
                            return trimmedLine.replace(/^•\s*/, '• ');
                        }
                    }
                    return line; // Keep empty lines as-is
                });
                
                // Filter out consecutive empty lines but keep single empty lines
                let result = [];
                let lastWasEmpty = false;
                for (let line of newLines) {
                    let isEmpty = line.trim().length === 0;
                    if (!isEmpty || !lastWasEmpty) {
                        result.push(line);
                    }
                    lastWasEmpty = isEmpty;
                }
                
                return result.join('\n');
            };

            const handleBulletedInput = (e, saveDataCallback) => {
                const textarea = e.target;

                // When user types, reset height to allow auto-resizing again
                textarea.style.height = 'auto';
                
                // If textarea is empty or doesn't start with a bullet, add one
                if (textarea.value.length > 0 && !textarea.value.startsWith('•')) {
                    const cursorPos = textarea.selectionStart;
                    textarea.value = '• ' + textarea.value;
                    textarea.selectionStart = textarea.selectionEnd = cursorPos + 2;
                }
                
                // Auto-resize
                autoResizeTextarea(textarea);

                // Save changes using the provided callback
                saveDataCallback(textarea);
            };
            
            const handleBulletedKeyDown = (e) => {
                const textarea = e.target;
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const text = textarea.value;

                if (e.key === 'Enter') {
                    e.preventDefault();
                    
                    const currentLineStart = text.lastIndexOf('\n', start - 1) + 1;
                    const currentLine = text.substring(currentLineStart, start);

                    if (currentLine.trim() === '•') {
                        textarea.value = text.substring(0, currentLineStart) + text.substring(end);
                        textarea.selectionStart = textarea.selectionEnd = currentLineStart;
                    } else {
                        textarea.value = text.substring(0, start) + '\n• ' + text.substring(end);
                        textarea.selectionStart = textarea.selectionEnd = start + 3;
                    }
                    
                    textarea.dispatchEvent(new Event('input', { bubbles: true }));
                    return;
                }

                if (e.key === 'Backspace' && start === end) {
                    const currentLineStart = text.lastIndexOf('\n', start - 1) + 1;
                    const lineText = text.substring(currentLineStart, start);
                    
                    if (lineText.trim() === '•' && start > 0) {
                        e.preventDefault();
                        const prevLineEnd = currentLineStart > 0 ? currentLineStart - 1 : 0;
                        textarea.value = text.substring(0, prevLineEnd) + text.substring(start);
                        textarea.selectionStart = textarea.selectionEnd = prevLineEnd;
                        textarea.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                }
            };

            // --- Specific Save Callbacks ---
            const saveSessionInfo = (textarea) => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (appointment) {
                    appointment.sessionInfo = textarea.value;
                    markDirty();
                }
                generateNoteBtn.disabled = !appointment || !selectedModel || !textarea.value.trim();
            };

            const saveSoapNote = (textarea) => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (appointment) {
                    if (!appointment.soap) appointment.soap = {s:'', o:'', a:'', p:''};
                    
                    if (textarea.id === 'interventions') {
                        appointment.soap.interventions = textarea.value;
                    } else {
                        const key = textarea.id.slice(-1).toLowerCase();
                        appointment.soap[key] = textarea.value;
                    }
                    markDirty();
                }
            };

            // --- Attach Bullet Point Handlers ---
            sessionInfoEl.addEventListener('input', (e) => handleBulletedInput(e, saveSessionInfo));
            sessionInfoEl.addEventListener('keydown', handleBulletedKeyDown);
            sessionInfoEl.addEventListener('focus', (e) => {
                const textarea = e.target;
                if (textarea.value.length === 0) {
                    textarea.value = '• ';
                    textarea.selectionStart = textarea.selectionEnd = 2;
                }
            });

            soapContentEl.addEventListener('input', (e) => {
                if (e.target.matches('.soap-textarea')) {
                    handleBulletedInput(e, saveSoapNote);
                }
            });
            soapContentEl.addEventListener('keydown', (e) => {
                if (e.target.matches('.soap-textarea')) {
                    handleBulletedKeyDown(e);
                }
            });
            soapContentEl.addEventListener('focus', (e) => {
                if (e.target.matches('.soap-textarea')) {
                    const textarea = e.target;
                    if (textarea.value.length === 0) {
                        textarea.value = '• ';
                        textarea.selectionStart = textarea.selectionEnd = 2;
                    }
                }
            });
            soapContentEl.addEventListener('click', (e) => {
                 if (e.target.classList.contains('copy-btn')) {
                     const targetId = e.target.dataset.target;
                     const textarea = document.getElementById(targetId);
                     if (!textarea) return;
                     navigator.clipboard.writeText(textarea.value).then(() => {
                        const originalText = e.target.textContent;
                        e.target.textContent = 'Copied!';
                        setTimeout(() => { e.target.textContent = originalText; }, 2000);
                     }).catch(err => {
                        console.error('Failed to copy text: ', err);
                        alert('Could not copy text to clipboard.');
                     });
                 }
                 if (e.target.classList.contains('suggestion-accept')) {
                    handleSuggestion(e.target, true);
                 }
                 if (e.target.classList.contains('suggestion-accept-replace')) {
                    handleSuggestion(e.target, true, true);
                 }
                 if (e.target.classList.contains('suggestion-decline')) {
                    handleSuggestion(e.target, false);
                 }
            });

            const handleSuggestion = (button, isAccepted, replace = false) => {
                const suggestionBox = button.closest('.suggestion-box');
                const type = suggestionBox.dataset.suggestionType;
                const index = parseInt(suggestionBox.dataset.suggestionIndex, 10);
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);

                if (!appointment || !appointment.soap) return;

                const suggestionKey = `${type}_suggestion`;
                const suggestionData = appointment.soap[suggestionKey]?.[index];

                if (isAccepted && suggestionData) {
                    const textarea = document.getElementById(`soap${type.toUpperCase()}`);
                    
                    if (replace && typeof suggestionData === 'object' && suggestionData.original && suggestionData.suggested) {
                        // New object-based replacement
                        const originalText = formatBulletPoints(suggestionData.original);
                        const suggestedText = formatBulletPoints(suggestionData.suggested);
                        textarea.value = textarea.value.replace(originalText, suggestedText);

                    } else if (replace) {
                        // Legacy string-based replacement (replaces whole field)
                        textarea.value = formatBulletPoints(suggestionData);

                    } else {
                        // Append the suggestion (for A and P)
                        const suggestionText = (typeof suggestionData === 'object' ? suggestionData.suggested : suggestionData) || '';
                        const currentText = textarea.value.trim();
                        const newText = `• ${suggestionText.replace(/^•\s*/, '')}`;
                        
                        if (currentText.length === 0 || currentText === '•') {
                            textarea.value = newText;
                        } else {
                            textarea.value = `${currentText}\n${newText}`;
                        }
                    }
                    // Manually trigger input event to resize and save
                    textarea.dispatchEvent(new Event('input', { bubbles: true }));
                }

                // Remove the specific suggestion from the array and re-render
                if (Array.isArray(appointment.soap[suggestionKey])) {
                    appointment.soap[suggestionKey].splice(index, 1);
                }
                
                markDirty();
                renderSoap();
            };


            const systemPrompt = `You are a helpful assistant for a therapist or clinician. Your primary function is to accurately categorize user-provided session notes into a structured SOAP note format.

**Your Task:**
Analyze the "Session Information" text provided by the user. Categorize every piece of information into one of the four SOAP sections based on the strict definitions below.

- **Subjective (S):** Information reported by the client (e.g., feelings, goals, history). This is for the client's voice and perspective.
- **Objective (O):** Everything that *happens* in the therapy session. This includes all therapeutic interventions, actions taken, connections made, and reflections or psychoeducation provided by the writer. **Any sentence that describes the writer's actions or speech belongs here.**
- **Assessment (A):** The writer's clinical analysis and observations. This includes notes on progress towards goals and direct observations of the client's state (e.g., "client appeared tired," "client's affect was bright"). This section should NOT contain actions or speech from the session.
- **Plan (P):** The course of action for future sessions. This includes topics to be addressed, homework, and any modifications to the treatment plan.

**NEW: Suggestions**
- In addition to the main SOAP content, you will provide clinical language suggestions for all four sections when appropriate stronger clinical terminology is available.
- These suggestions should improve clinical precision and professional language without adding new information.
- The suggestions should be returned in four JSON keys: \`s_suggestion\`, \`o_suggestion\`, \`a_suggestion\`, and \`p_suggestion\`.
- \`s_suggestion\` & \`o_suggestion\`: For Subjective and Objective, if you have suggestions, the value for this key MUST be an array of JSON objects, like: \`[{"original": "[the exact original text to be replaced]", "suggested": "[the new suggested text]"}]\`. The "original" text must be a direct, verbatim quote of one of the bullet points from the corresponding "s" or "o" section you generated.
- \`a_suggestion\` & \`p_suggestion\`: For Assessment and Plan, these should be an array of brief, one-sentence suggestions as strings. Example: ["Client appears to be making progress toward treatment goals related to anxiety."].
- If you have no suggestion for any section, return an empty array \`[]\` for that key.

**CRITICAL INSTRUCTIONS:**
- **THE GOLDEN RULE:** ONLY use information explicitly provided in the "Session Information" text. Do not use any information from the example output below, which is for formatting reference only.
- **INFORMATION FIDELITY:**
    - **NO NEW INFORMATION:** You must not add, invent, or infer any details, events, or feelings not explicitly stated in the "Session Information." Your task is to categorize, not create.
    - **NO ASSUMPTIONS:** Do not make clinical assumptions. If the text says "Ct cried," report "Ct cried." Do not interpret this as "Ct was sad" unless the text also states that.
    - **PRESERVE QUOTES:** Only use quotation marks in your output if the "Session Information" contains a direct quote. Do not put paraphrased statements in quotes.
- **TENSE:** All output must be in the past tense. For example, use "Ct reported" instead of "Ct reports," and "Writer stated" instead of "Writer states."
- **REFERRALS & PRONOUNS:**
    - Always refer to the client as **"Ct"**.
    - Always refer to the therapist/clinician (the user) as **"Writer."** Use the third person (e.g., "Writer observed..."). Do not use "I" or "me."
    - Never use articles before the referrals. It is always "Ct" or "Writer," never "the Ct" or "the Writer."
- **ESCAPE QUOTES:** You MUST escape any double quotes inside the JSON string values. For example, if the client says "I feel sad," the JSON output should be '{"s":"• Ct reported feeling \\"sad.\\""}'.
- **DO NOT INVENT:** Your response must ONLY contain information found in the "Session Information" text. Do not add any details, assumptions, or statements that are not explicitly provided.
- **DO NOT INTERPRET BEYOND CATEGORIZATION:** Your job is to sort the provided information, not to add clinical interpretation or make assumptions about progress, affect, or presentation unless it is explicitly stated in the source text. For example, do not write "client appeared tired" unless the source text says "client appeared tired."

**Output Format:**
Your entire response MUST be a single, raw, and syntactically correct JSON object. Do not wrap it in markdown code fences. Do not add any explanatory text, comments, or any words outside of the JSON object itself. The JSON object must have exactly eight keys: "s", "o", "a", "p", "s_suggestion", "o_suggestion", "a_suggestion", and "p_suggestion".

**Example of PERFECT Output (FOR FORMATTING ONLY):**
{"s":"• Ct said they felt bad.","o":"• Writer talked about coping.","a":"• Ct displays affect congruent with mood.","p":"• Continue to explore themes of loss.","s_suggestion":[{"original":"• Ct said they felt bad.","suggested":"• Ct reported experiencing significant distress."}],"o_suggestion":[{"original":"• Writer talked about coping.","suggested":"• Writer provided psychoeducation on coping strategies."}],"a_suggestion":["Client appears to be making progress toward treatment goals related to anxiety."],"p_suggestion":["Continue to utilize CBT techniques to challenge cognitive distortions in the next session."]};
            `;

            const generateSoapNote = async () => {
                if (!selectedModel) {
                    alert('Please connect to a provider and select a model in Settings.');
                    return;
                }
                if (apiProvider === 'openwebui') {
                    await generateSoapNoteWithOpenWebUI();
                } else if (apiProvider === 'gemini') {
                    await generateSoapNoteWithGemini();
                } else {
                    alert('Invalid API provider selected.');
                }
            };

            const generateSoapNoteWithGemini = async () => {
                if (!selectedModel || !geminiApiKey) {
                    alert('Please connect to Gemini with an API key and model first.');
                    return;
                }

                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (!client || !appointment || !sessionInfoEl.value.trim()) {
                    alert('Please select a client and appointment, and enter some session information.');
                    return;
                }

                generateNoteBtn.disabled = true;
                generateNoteBtn.textContent = 'Generating...';

                const userPrompt = `
- **Session Information (This Session):**
${sessionInfoEl.value}
`;
                const fullPrompt = `${systemPrompt}\n\n**User Input:**\n${userPrompt}`;

                const payload = {
                    contents: [{
                        parts: [{ text: fullPrompt }]
                    }],
                    generationConfig: {
                        response_mime_type: "application/json",
                    }
                };

                try {
                    const url = `https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent?key=${geminiApiKey}`;
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        const error = new Error(`Gemini API error: ${response.status} - ${errorText}`);
                        error.response = response;
                        throw error;
                    }

                    const result = await response.json();
                    if (!result || !result.candidates || !result.candidates[0].content.parts[0].text) {
                         throw new Error("The Gemini API returned an invalid or empty response.");
                    }

                    let content = result.candidates[0].content.parts[0].text;
                    let soapData = JSON.parse(content);

                    for (const key in soapData) {
                        if (typeof soapData[key] === 'string' && !key.endsWith('_suggestion')) {
                            soapData[key] = formatBulletPoints(soapData[key]);
                        }
                    }

                    if (typeof soapData.s !== 'string' || typeof soapData.o !== 'string' || typeof soapData.a !== 'string' || typeof soapData.p !== 'string') {
                        throw new Error(`AI response was not in the expected JSON format (missing s, o, a, or p keys).`);
                    }

                    if (!appointment.soap) appointment.soap = {};
                    appointment.soap.s = soapData.s;
                    appointment.soap.o = soapData.o;
                    appointment.soap.a = soapData.a;
                    appointment.soap.p = soapData.p;
                    appointment.soap.s_suggestion = soapData.s_suggestion || [];
                    appointment.soap.o_suggestion = soapData.o_suggestion || [];
                    appointment.soap.a_suggestion = soapData.a_suggestion || [];
                    appointment.soap.p_suggestion = soapData.p_suggestion || [];
                    markDirty();
                    renderSoap();

                } catch (error) {
                    console.error('Gemini SOAP Note Generation Error:', error);
                    alert(`Failed to generate SOAP note with Gemini. Please check your API Key, Model Name, and the console for details.\nError: ${error.message}`);
                } finally {
                    generateNoteBtn.disabled = false;
                    generateNoteBtn.textContent = 'Generate Note';
                }
            };

            const generateSoapNoteWithOpenWebUI = async () => {
                if (!selectedModel) {
                    alert('Please connect to your server and select a model first.');
                    return;
                }

                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (!client || !appointment || !sessionInfoEl.value.trim()) {
                    alert('Please select a client and appointment, and enter some session information.');
                    return;
                }

                generateNoteBtn.disabled = true;
                generateNoteBtn.textContent = 'Generating...';

                const userPrompt = `
- **Client Name:** ${client.name}
- **Session Information (This Session):**
${sessionInfoEl.value}
`;

                const payload = {
                    model: selectedModel,
                    messages: [
                        { "role": "system", "content": systemPrompt },
                        { "role": "user", "content": userPrompt }
                    ],
                    response_format: { "type": "json_object" },
                    stream: false
                };
                
                try {
                    const headers = new Headers({ 'Content-Type': 'application/json' });
                     if (apiKey) {
                         headers.append('Authorization', `Bearer ${apiKey}`);
                    }
                    const response = await fetch(`${serverAddress}/api/v1/chat/completions`, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(payload),
                        mode: 'cors'
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        const error = new Error(`API error: ${response.status} - ${errorText}`);
                        error.response = response;
                        throw error;
                    }

                    const result = await response.json();
                    if (!result) {
                        throw new Error("The API returned an empty response. Please check the Open WebUI server logs for errors.");
                    }
                    let content = result.choices[0].message.content;
                    let soapData = {};

                    // Aggressive JSON extraction and cleanup
                    try {
                        // Find the first '{' and the last '}' to extract the JSON part.
                        const firstBrace = content.indexOf('{');
                        const lastBrace = content.lastIndexOf('}');
                        if (firstBrace === -1 || lastBrace === -1 || lastBrace < firstBrace) {
                            throw new Error('AI response did not contain a valid JSON object.');
                        }
                        let jsonString = content.substring(firstBrace, lastBrace + 1);
                        
                        // Attempt to parse it. If it fails, it's likely due to malformed content.
                        try {
                            soapData = JSON.parse(jsonString);
                        } catch (e) {
                            console.warn("Initial JSON.parse failed. Attempting to clean and re-parse.", e.message);
                            // This is a more robust fallback for models that fail to escape content correctly.
                            // It performs multiple passes to clean up common issues.
                            
                            // 1. Remove newlines within JSON strings, which is a common error.
                            let cleanedString = jsonString.replace(/:\s*"(.*?)"/gs, (match, group1) => {
                                const singleLineGroup = group1.replace(/\n/g, '\\n').replace(/\r/g, '');
                                return `: "${singleLineGroup}"`;
                            });

                            // 2. Fix unescaped quotes inside values. This is more complex.
                            // We look for a quote that is not preceded by a backslash.
                            cleanedString = cleanedString.replace(/:\s*"(.*?)"/g, (match, group1) => {
                                const fixedGroup = group1.replace(/(?<!\\)"/g, '\\"');
                                return `: "${fixedGroup}"`;
                            });

                            soapData = JSON.parse(cleanedString); // Retry parsing with the cleaned string
                        }

                    } catch (parseError) {
                        console.error("Failed to parse the following JSON string from the AI:", content);
                        throw new Error(`The AI model returned malformed JSON that could not be automatically fixed. Check the browser console for the raw output. Details: ${parseError.message}`);
                    }
                    
                    for (const key in soapData) {
                        if (typeof soapData[key] === 'string' && ['s', 'o', 'a', 'p'].includes(key)) {
                            // Format bullet points for every key
                            soapData[key] = formatBulletPoints(soapData[key]);
                        } else if (Array.isArray(soapData[key])) {
                            // This handles cases where the AI might return an array of strings
                            soapData[key] = soapData[key].map(item => {
                                const cleanedItem = item.toString().trim().replace(/^•\s*/, '');
                                return `• ${cleanedItem}`;
                            }).join('\n');
                            soapData[key] = formatBulletPoints(soapData[key]);
                        } else if (key.endsWith('_suggestion') && soapData[key] && typeof soapData[key] === 'object') {
                            // Don't format suggestion objects
                        } else if (key.endsWith('_suggestion') && typeof soapData[key] === 'string') {
                            // This is for a_suggestion and p_suggestion, no formatting needed
                        }
                    }

                    if (typeof soapData.s !== 'string' || typeof soapData.o !== 'string' || typeof soapData.a !== 'string' || typeof soapData.p !== 'string') {
                        console.error("Received valid JSON from AI, but it was missing required SOAP keys or they were not strings after processing. Received object:", soapData);
                        throw new Error(`AI response was not in the expected JSON format (missing s, o, a, or p keys). The AI returned: ${JSON.stringify(soapData)}`);
                    }
                    
                    if (!appointment.soap) appointment.soap = {};
                    appointment.soap.s = soapData.s;
                    appointment.soap.o = soapData.o;
                    appointment.soap.a = soapData.a;
                    appointment.soap.p = soapData.p;
                    appointment.soap.s_suggestion = soapData.s_suggestion || [];
                    appointment.soap.o_suggestion = soapData.o_suggestion || [];
                    appointment.soap.a_suggestion = soapData.a_suggestion || [];
                    appointment.soap.p_suggestion = soapData.p_suggestion || [];
                    markDirty();
                    renderSoap();

                } catch (error) {
                    console.error('SOAP Note Generation Error:', error);
                    let alertMessage = `Failed to generate SOAP note. Please check your connection and the console for details.\nError: ${error.message}`;
                    
                    if (error.response?.status === 401) {
                         alertMessage = `Authentication failed (401 Unauthorized) while trying to generate the note. Please re-check your API Key.`;
                    } else if (error instanceof TypeError && error.message.toLowerCase().includes('failed to fetch')) {
                        alertMessage = `Network Error: Failed to fetch. Check CORS policy on your server.`;
                    }
                    alert(alertMessage);
                } finally {
                    generateNoteBtn.disabled = false;
                    generateNoteBtn.textContent = 'Generate Note';
                }
            };
            
            const connectToServer = async () => {
                apiProvider = apiProviderSelect.value;
                if (apiProvider === 'openwebui') {
                    await connectToOpenWebUI();
                } else if (apiProvider === 'gemini') {
                    await connectToGemini();
                }
            };

            const extractInterventions = (soapData) => {
                const text = [soapData.s, soapData.o, soapData.a, soapData.p].join(' ');
                const interventions = new Set();

                const keywords = [
                    // CBT

                    'cognitive restructuring', 'behavioral activation', 'exposure therapy', 'exposure and response prevention', 'erp',

                    'skills training', 'cognitive processing therapy', 'cpt', 'relapse prevention', 'activity scheduling',
                    'cognitive bias modification', 'homework assignments', 'cognitive behavioral stress management', 'schema therapy',
                    'rational emotive behavior therapy', 'rebt', 'stress inoculation training', 'cognitive remediation therapy',
                    'compensatory strategy training', 'behavioral experiments', 'graded exposure hierarchies', 'socratic questioning',
                    'thought records', 'response cost', 'time-out procedures', 'differential reinforcement', 'prompting and fading',
                    'contingency contracts', 'behavioral rehearsal', 'modeling', 'cognitive challenging', 'cognitive reframing',
                    'identifying/challenging cognitive distortions',

                    // ACT / Mindfulness
                    'acceptance and commitment therapy', 'act', 'values clarification', 'cognitive defusion', 'committed action',
                    'mindfulness-based interventions', 'mindfulness training', 'act defusion exercises', 'act metaphors',
                    'mindfulness meditation', 'self-as-context exercises', 'attention training', 'mct',

                    // DBT
                    'dialectical behavior therapy', 'dbt', 'distress tolerance', 'emotion regulation', 'interpersonal effectiveness',
                    'dbt chain analysis', 'dbt diary cards', 'dbt phone coaching',

                    // Psychodynamic / Psychoanalytic
                    'interpretation', 'exploration of transference', 'exploration of countertransference', 'free association',
                    'dream work', 'working through', 'object relations interventions', 'supportive-expressive therapy',
                    'transference', 'countertransference', 'resistance', 'defense mechanism', 'unconscious', 'explored childhood',
                    'examined patterns', 'linking past and present', 'making the unconscious conscious', 'insight-oriented',
                    'clarification and confrontation', 'alliance rupture repair', 'defense analysis', 'active imagination',
                    'archetypal work', 'short-term psychodynamic therapy', 'stpp', 'mentalization-based therapy', 'mbt',
                    'transference-focused psychotherapy', 'tfp', 'exploration of attachment patterns', 'exploration of themes and patterns',
                    'explore defense mechanisms', 'insight & emotional integration',

                    // Humanistic / Existential / Gestalt
                    'client-centered techniques', 'gestalt methods', 'empty chair technique', 'role reversal', 'here-and-now awareness',
                    'existential therapy techniques', 'emotion-focused therapy', 'eft', 'unconditional positive regard', 'empathy',
                    'empathic', 'congruence', 'active listening', 'gestalt', 'empty chair', 'existential', 'search for meaning',
                    'empathic reflection', 'two-chair conflict resolution', 'focusing', 'gendlin', 'logotherapy techniques',
                    'paradoxical intention', 'dereflection', 'authenticity and congruence', 'evocative responding',
                    'facilitation of emotional engagement', 'heightening', 'emotional processing',

                    // Narrative Therapy
                    'narrative therapy interventions', 'deconstruction', 'externalization', 're-authoring', 're-framing',
                    're-membering', 'scaffolding questions', 'values exploration', 'externalizing the problem', 'unique outcomes',
                    'story', 'alternative story', 'dominant story', 'landscape of action', 'landscape of identity',
                    'family re-authoring', 'identifying unique outcomes',

                    // Trauma-Informed
                    'eye movement desensitization and reprocessing', 'emdr', 'trauma-focused cbt', 'prolonged exposure', 'pe',
                    'stabilization techniques', 'sensorimotor psychotherapy', 'narrative exposure therapy', 'net',
                    'imagery rescripting', 'internal family systems', 'ifs', 'ego state therapy', 'grounding techniques',
                    'flash technique', 'lifespan integration', 'tapping', 'emotional freedom techniques', 'trauma release exercises', 'tre',

                    // Family / Couples Therapy
                    'structural family therapy', 'strategic family therapy', 'multisystemic therapy', 'mst',
                    'functional family therapy', 'fft', 'parent management training', 'pmt', 'couples therapy interventions',
                    'genograms', 'differentiation of self', 'enactments', 'paradoxical injunctions', 'attachment-based family therapy', 'abft',
                    'gottman method interventions', 'love maps', 'rituals of connection', 'imago relationship therapy',
                    'parent-child interaction therapy', 'pcit', 'choreographing enactments', 'restructuring interactions',

                    // Somatic / Body-Based
                    'somatic experiencing', 'yoga therapy', 'movement therapy', 'massage therapy', 'acupuncture',
                    'progressive muscle relaxation', 'breathing retraining', 'biofeedback', 'neurofeedback',
                    'dance/movement therapy', 'breathwork', 'bioenergetic grounding', 'alexander technique', 'feldenkrais method',

                    // General / Skills
                    'psychoeducation', 'coping skills', 'grounding techniques', 'role-playing', 'explored feelings',
                    'processed emotions', 'provided support', 'building rapport', 'goal setting', 'treatment plan',
                    'explored options', 'problem-solving', 'reframing', 'scaling questions', 'circular questioning',
                    'communication skills', 'de-escalation', 'relaxation/deep breathing', 'review of treatment plan/progress',
                    'safety planning', 'decisional balance', 'evoking commitment language', 'identifying discrepancy',

                    // Group Therapy
                    'psychoeducational groups', 'process groups', 'skills groups', 'support groups', 'yalom’s therapeutic factors',
                    'process commentary', 'supportive confrontation in group', 'group cohesion building',

                    // Substance Use
                    'motivational interviewing', 'mi', 'contingency management', 'community reinforcement approach', 'cra',
                    '12-step facilitation', 'cue exposure', 'urge surfing', 'harm reduction counseling',

                    // Medical / Psychiatric
                    'medication management', 'antidepressant medication', 'antipsychotic medication', 'mood stabilizers',
                    'anxiolytic medication', 'stimulant medication', 'electroconvulsive therapy', 'ect',
                    'transcranial magnetic stimulation', 'tms', 'vagus nerve stimulation', 'vns', 'deep brain stimulation', 'dbs',
                    'ketamine treatment', 'esketamine treatment', 'medication-assisted treatment', 'mat',
                    'long-acting injectable medication', 'lais', 'polypharmacy management', 'light therapy', 'sleep deprivation therapy',
                    'chronotherapy', 'nutraceuticals', 'psychedelic-assisted therapy',

                    // Crisis / Safety
                    'crisis intervention models', 'safety planning', 'de-escalation techniques', 'emergency hospitalization',
                    'lethal means counseling', 'collaborative assessment and management of suicidality', 'cams',
                    'asist suicide intervention model', 'hotline support', 'psychological first aid', 'pfa',

                    // Other
                    'systematic desensitization', 'operant conditioning strategies', 'token economies', 'aversion therapy',
                    'habit reversal training', 'shaping', 'chaining', 'interpersonal therapy', 'ipt', 'art therapy',
                    'music therapy', 'drama therapy', 'psychodrama', 'play therapy', 'bibliotherapy', 'sleep hygiene interventions',
                    'nutrition guidance', 'exercise prescriptions', 'smoking cessation counseling', 'vocational rehabilitation',
                    'supported employment', 'assertive community treatment', 'case management', 'supported housing',
                    'peer support programs', 'community outreach', 'measurement-based care', 'functional analysis',
                    'risk assessment protocols', 'neuropsychological rehabilitation', 'internet-delivered cbt', 'teletherapy',
                    'mobile mental health apps', 'computerized cognitive training', 'virtual reality exposure therapy',
                    'automated chatbots for psychoeducation', 'culturally adapted psychotherapy', 'traditional healing integration',
                    'interpreter-supported therapy', 'forensic risk management', 'competency restoration', 'diversion programs',
                    'prevention programs', 'school-based mental health programs', 'workplace interventions', 'sand tray therapy',
                    'mandala drawing', 'lyric analysis', 'improvisational music therapy', 'playback theatre', 'storytelling interventions',
                    'herbal interventions', 'animal-assisted therapy', 'equine-assisted therapy', 'nature-based therapy', 'ecotherapy',
                    'solution-focused therapy', 'single session therapy techniques', 'miracle question', 'exception finding',
                    'exception-finding'
                ];

                keywords.forEach(keyword => {
                    const regex = new RegExp(`\\b${keyword}(s|ing|ed)?\\b`, 'gi');
                    if (regex.test(text)) {
                        // Capitalize first letter for display
                        const formattedIntervention = keyword.charAt(0).toUpperCase() + keyword.slice(1);
                        interventions.add(formattedIntervention);
                    }
                });

                if (interventions.size === 0) {
                    return 'No specific interventions identified.';
                }

                return Array.from(interventions).map(i => `• ${i}`).join('\n');
            };
            
            const connectToGemini = async () => {
                const key = geminiApiKeyInput.value.trim();
                if (!key) {
                    alert('Please provide a Gemini API Key.');
                    return;
                }

                apiStatus.textContent = 'Connecting...';
                apiStatus.style.color = 'orange';
                geminiModelInput.innerHTML = '<option>Loading models...</option>';
                geminiModelInput.disabled = true;

                try {
                    const url = `https://generativelanguage.googleapis.com/v1beta/models?key=${key}`;
                    const response = await fetch(url);
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Failed to fetch models: ${response.status} - ${errorText}`);
                    }
                    const data = await response.json();

                    const models = data.models.filter(m => 
                        m.supportedGenerationMethods.includes("generateContent") &&
                        m.name.includes("gemini")
                    ).map(m => m.name.replace('models/', ''));

                    if (models.length === 0) {
                        throw new Error("No compatible Gemini models found.");
                    }

                    geminiModelInput.innerHTML = '';
                    models.forEach(modelId => {
                        const option = document.createElement('option');
                        option.value = modelId;
                        option.textContent = modelId;
                        geminiModelInput.appendChild(option);
                    });

                    geminiApiKey = key;
                    
                    const savedModel = localStorage.getItem('geminiModel');
                    if (savedModel && models.includes(savedModel)) {
                        geminiModelInput.value = savedModel;
                    } else if (models.includes('gemini-1.5-flash-latest')) {
                        geminiModelInput.value = 'gemini-1.5-flash-latest';
                    } else {
                        geminiModelInput.value = models[0];
                    }
                    
                    selectedModel = geminiModelInput.value;
                    geminiModelInput.disabled = false;

                    localStorage.setItem('apiProvider', 'gemini');
                    localStorage.setItem('geminiApiKey', geminiApiKey);
                    localStorage.setItem('geminiModel', selectedModel);

                    apiStatus.textContent = 'Connected';
                    apiStatus.style.color = 'green';

                } catch (error) {
                    console.error('Gemini connection error:', error);
                    apiStatus.textContent = 'Failed';
                    apiStatus.style.color = 'red';
                    geminiModelInput.innerHTML = '<option>Connection Failed</option>';
                    geminiApiKey = null;
                    selectedModel = null;
                    alert(`Failed to connect to Gemini. Check your API key and network connection.\nError: ${error.message}`);
                } finally {
                    fullRender();
                }
            };

            const connectToOpenWebUI = async () => {
                const address = serverAddressInput.value.trim();
                if (!address) {
                    alert('Please enter an Open WebUI address.');
                    return;
                }
                serverAddress = address.endsWith('/') ? address.slice(0, -1) : address;
                apiKey = apiKeyInput.value.trim();

                // Save settings to local storage immediately
                localStorage.setItem('apiProvider', 'openwebui');
                localStorage.setItem('serverAddress', serverAddress);
                if (apiKey) {
                    localStorage.setItem('apiKey', apiKey);
                } else {
                    localStorage.removeItem('apiKey');
                }

                apiStatus.textContent = 'Connecting...';
                apiStatus.style.color = 'orange';
                modelSelect.innerHTML = '<option>Loading models...</option>';
                modelSelect.disabled = true;

                try {
                    const headers = new Headers();
                    if (apiKey) {
                        headers.append('Authorization', `Bearer ${apiKey}`);
                    }
                    const response = await fetch(`${serverAddress}/api/v1/models`, { headers, mode: 'cors' });
                    if (!response.ok) {
                        const error = new Error(`Failed to connect to Open WebUI. Status: ${response.status}`);
                        error.response = response;
                        throw error;
                    }
                    const data = await response.json();
                    
                    apiStatus.textContent = 'Connected';
                    apiStatus.style.color = 'green';
                    
                    // localStorage.setItem('serverAddress', serverAddress);
                    // if (apiKey) localStorage.setItem('apiKey', apiKey);
                    // else localStorage.removeItem('apiKey');
                    
                    modelSelect.innerHTML = '';
                    const models = data.data;

                    if (models && models.length > 0) {
                        models.forEach(model => {
                            const option = document.createElement('option');
                            option.value = model.id;
                                                       option.textContent = model.id;
                            modelSelect.appendChild(option);
                        });

                        let autoSelectedModelId = null;
                        const llamaModel = models.find(m => m.id === 'llama3.2:3b');
                        const deepseekModel = models.find(m => m.id === 'deepseek-r1:1.5b');

                        if (llamaModel) {
                            autoSelectedModelId = llamaModel.id;
                        } else if (deepseekModel) {
                            autoSelectedModelId = deepseekModel.id;
                        } else {
                            const fallbackModel = models.find(m => 
                                m.id !== 'arena-model' && 
                                !m.id.toLowerCase().includes('coder') && 
                                !m.id.toLowerCase().includes('coding')
                            );
                            if (fallbackModel) {
                                autoSelectedModelId = fallbackModel.id;
                            }
                        }

                        if (autoSelectedModelId) {
                            modelSelect.value = autoSelectedModelId;
                        } else if (models.length > 0) {
                            modelSelect.value = models[0].id;
                        }

                        selectedModel = modelSelect.value;
                        modelSelect.disabled = false;
                        
                    } else {

                        modelSelect.innerHTML = '<option>No models found</option>';
                        selectedModel = null;
                        modelSelect.disabled = true;
                    }

                } catch (error) {
                    console.error('API connection error:', error);
                    apiStatus.textContent = 'Failed';
                    apiStatus.style.color = 'red';
                    serverAddress = null;
                    modelSelect.innerHTML = '<option>Connection failed</option>';
                    
                                       
                    let alertMessage = `Connection to "${address}" failed.`;
                    
                    if (error.response?.status === 401) {
                         alertMessage += `\n\nError: Authentication failed (401 Unauthorized). Please check if your API Key is correct and has the necessary permissions. Some servers require an API key even if it's optional in the UI.`;
                    } else if (error instanceof TypeError && error.message.toLowerCase().includes('failed to fetch')) {
                        alertMessage = `Network Error: Failed to fetch.

This is the most common error and is almost always caused by one of two things:

1.  **CORS Policy:** Your browser is blocking the request for security reasons. The Open WebUI server must be configured to allow requests from this webpage.
    *SOLUTION:* In your Open WebUI settings, find the "Allowed Origins" configuration and add the URL of this page. You can often just add "*" to allow all origins, but this is less secure.

2.  **Server Not Reachable:** The address "${address}" is incorrect, or the Open WebUI server is not running. Please double-check the address and ensure the server is active.

This error cannot be fixed within this application's code; it requires a configuration change on the server you are trying to connect to.`;
                    } else {
                         alertMessage += `\n\nError: ${error.message}`;
                    }
                    alert(alertMessage);

                } finally {
                    fullRender();
                }
            };


            // --- Data Persistence (Save/Load/AutoSave) ---
            const updateSaveStatus = (message, isGood = true, duration = 0) => {
                autoSaveIndicator.style.opacity = '1';
                saveStatus.textContent = message;
                saveStatus.style.color = isGood ? 'white' : '#f1c40f'; // Gold for warning
                if (duration > 0) {
                    setTimeout(() => {
                        if (saveStatus.textContent === message) {
                            autoSaveIndicator.style.opacity = '0';
                        }
                    }, duration);
                }
            }

            const markDirty = () => {
                if (!isDirty) {
                    isDirty = true;
                    updateSaveStatus('Unsaved changes...', false);
                }
                debouncedAutoSave();
            };

            const saveDataToLocalStorage = () => {
                try {
                    const state = { data, deletedItems, selectedClientId, selectedAppointmentId };
                    const dataStr = JSON.stringify(state);
                    localStorage.setItem('clientData', dataStr);
                    isDirty = false;
                } catch (e) {
                    console.error("Failed to save to localStorage", e);
                    updateSaveStatus('Save failed!', false, 3000);
                    // Handle potential quota exceeded error
                    if (e.name === 'QuotaExceededError') {
                        alert('Failed to save data: Storage quota exceeded. Please export your data to a file and consider clearing some old records.');
                    }
                }
            };

            const loadDataFromLocalStorage = () => {
                const dataStr = localStorage.getItem('clientData');
                if (dataStr) {
                    try {
                        const state = JSON.parse(dataStr);
                        data = state.data || getInitialData();
                        if (!data.archivedClients) data.archivedClients = [];
                        deletedItems = state.deletedItems || { clients: [], appointments: [] };
                        selectedClientId = state.selectedClientId || null;
                        selectedAppointmentId = state.selectedAppointmentId || null;

                        // Load API settings
                        const savedProvider = localStorage.getItem('apiProvider');
                        if (savedProvider) {
                            apiProvider = savedProvider;
                            apiProviderSelect.value = apiProvider;
                            toggleProviderSettings();
                        }
                        serverAddressInput.value = localStorage.getItem('serverAddress') || '';
                        apiKeyInput.value = localStorage.getItem('apiKey') || '';
                        geminiApiKeyInput.value = localStorage.getItem('geminiApiKey') || '';
                        // We don't load the gemini model name here, it's set after connection

                    } catch (e) {
                        console.error("Failed to load from localStorage", e);
                        alert("Error loading data from storage. Data might be corrupt. Starting fresh.");
                        data = getInitialData();
                        deletedItems = { clients: [], appointments: [] };
                    }
                }
            };

            const exportFile = () => {
                try {
                    const stateToSave = { data, deletedItems, selectedClientId, selectedAppointmentId };
                    const stateJSON = JSON.stringify(stateToSave, null, 2);
                    const blob = new Blob([stateJSON], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `client-data-${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    updateSaveStatus('Exported.', true, 2000);
                } catch (err) {
                    console.error('Failed to export file:', err);
                    alert('Export failed!');
                    updateSaveStatus('Export failed!', false, 3000);
                }
            };

            let saveTimeout;
            const debouncedAutoSave = () => {
                clearTimeout(saveTimeout);
                saveTimeout = setTimeout(() => {
                    saveDataToLocalStorage();
                    updateSaveStatus('Auto-saved', true, 2000);
                }, 1500);
            };

            const loadFile = () => {
                 if (isDirty && !confirm('You have unsaved changes that will be lost. Are you sure you want to import a new file?')) {
                     return;
                 }
                fileInput.click();
            };

            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const contents = e.target.result;
                        const state = JSON.parse(contents);

                        if (!state.data || !state.deletedItems) {
                            throw new Error("Invalid file structure. Required properties are missing.");
                        }

                        data = state.data;
                        deletedItems = state.deletedItems;
                        selectedClientId = state.selectedClientId || null;
                        selectedAppointmentId = state.selectedAppointmentId || null;

                        if (!data.archivedClients) {
                            data.archivedClients = [];
                        }

                        isDirty = false;
                        saveDataToLocalStorage();

                        alert(`Imported ${file.name} successfully.`);
                        fullRender();
                    } catch (err) {
                        console.error('Failed to load file:', err);
                        alert(`Import failed! Invalid file.\n\nError: ${err.message}`);
                    } finally {
                        // Reset file input so the same file can be loaded again
                        fileInput.value = '';
                    }
                };
                reader.readAsText(file);
            });

            const eraseAllData = () => {
                const confirmationText = "DELETE ALL DATA";
                const userInput = prompt(`This action will permanently erase all client data from this browser. This cannot be undone.\n\nTo confirm, please type "${confirmationText}" in the box below.`);
                if (userInput === confirmationText) {
                    data = getInitialData();
                    deletedItems = { clients: [], appointments: [] };
                    selectedClientId = null;
                    selectedAppointmentId = null;
                    isDirty = false;
                    localStorage.removeItem('clientData');
                    localStorage.removeItem('serverAddress');
                    localStorage.removeItem('apiKey');
                    localStorage.removeItem('geminiApiKey');
                    localStorage.removeItem('geminiModel');
                    localStorage.removeItem('apiProvider');
                    localStorage.removeItem('columnSizes');
                    localStorage.removeItem('rowSizes');
                    localStorage.removeItem('theme');
                    alert('All data has been permanently erased. The page will now reload.');
                    window.location.reload();
                } else if (userInput !== null) {
                    alert('The text you entered did not match. No data has been erased.');
                }
            };

            // --- Event Listeners ---
            addClientBtn.addEventListener('click', addClient);
            sortClientsBtn.addEventListener('click', () => {
                data.clients.sort((a, b) => a.name.localeCompare(b.name));
                markDirty();
                renderClients();
            });
            addAppointmentBtn.addEventListener('click', addAppointment);
            exportBtn.addEventListener('click', exportFile);
            importBtn.addEventListener('click', loadFile);
            eraseAllBtn.addEventListener('click', eraseAllData);
            generateNoteBtn.addEventListener('click', generateSoapNote);
            connectApiBtn.addEventListener('click', connectToServer);
            manualSaveBtn.addEventListener('click', () => {
                saveDataToLocalStorage();
                updateSaveStatus('Data saved!', true, 2000);
            });
            settingsBtn.addEventListener('click', () => settingsModal.classList.remove('hidden'));
            closeSettingsBtn.addEventListener('click', () => settingsModal.classList.add('hidden'));
            settingsModal.addEventListener('click', (e) => {
                if(e.target.id === 'settingsModal') {
                    settingsModal.classList.add('hidden');
                }
            });
            modelSelect.addEventListener('change', (e) => {
                selectedModel = e.target.value;
                localStorage.setItem('openWebUIModel', selectedModel);
                fullRender();
            });

            geminiModelInput.addEventListener('change', (e) => {
                selectedModel = e.target.value;
                localStorage.setItem('geminiModel', selectedModel);
                fullRender();
            });

            const toggleProviderSettings = () => {
                const provider = apiProviderSelect.value;
                apiProvider = provider;
                if (provider === 'openwebui') {
                    openwebuiSettings.classList.remove('hidden');
                    modelSelectWrapper.classList.remove('hidden');
                    geminiSettings.classList.add('hidden');
                } else { // gemini
                    openwebuiSettings.classList.add('hidden');
                    modelSelectWrapper.classList.add('hidden');
                    geminiSettings.classList.remove('hidden');
                }
            };
            apiProviderSelect.addEventListener('change', toggleProviderSettings);

            startTimerBtn.addEventListener('click', () => {
                const appointment = findAppointment(findClient(selectedClientId), selectedAppointmentId);
                if (appointment) {
                    appointment.startTime = new Date().toISOString();
                    appointment.endTime = null; // Clear end time if starting again
                    markDirty();
                    renderSessionTimer(appointment);
                }
            });

            stopTimerBtn.addEventListener('click', () => {
                const appointment = findAppointment(findClient(selectedClientId), selectedAppointmentId);
                if (appointment && appointment.startTime) { // Can only stop if started
                    appointment.endTime = new Date().toISOString();
                    clearInterval(sessionTimerInterval);
                    markDirty();
                    renderSessionTimer(appointment);
                }
            });

            // --- Theme Management ---
            const updateThemeButton = () => {
                const savedTheme = localStorage.getItem('theme') || 'automatic';
                if (savedTheme === 'dark') {
                    themeToggleBtn.textContent = '☀️';
                    themeToggleBtn.title = 'Switch to Automatic Theme';
                } else if (savedTheme === 'automatic') {
                    themeToggleBtn.textContent = '🔄';
                    themeToggleBtn.title = 'Switch to Light Theme';
                } else {
                    themeToggleBtn.textContent = '🌙';
                    themeToggleBtn.title = 'Switch to Dark Theme';
                }
            };

            const cycleTheme = () => {
                const savedTheme = localStorage.getItem('theme') || 'automatic';
                let newTheme;
                if (savedTheme === 'light') {
                    newTheme = 'dark';
                } else if (savedTheme === 'dark') {
                    newTheme = 'automatic';
                } else {
                    newTheme = 'light';
                }
                applyTheme(newTheme);
            };

            const applyTheme = (theme) => {
                if (theme === 'automatic') {
                    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                    document.body.dataset.theme = prefersDark ? 'dark' : 'light';
                } else {
                    document.body.dataset.theme = theme;
                }
                localStorage.setItem('theme', theme);
                updateThemeButton();
            };

            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
                const savedTheme = localStorage.getItem('theme') || 'automatic';
                if (savedTheme === 'automatic') {
                    applyTheme('automatic');
                }
            });

            themeToggleBtn.addEventListener('click', cycleTheme);


            // --- Resizable Panels ---
            function saveColumnSizes() {
                const panels = ['panelClients', 'panelAppointments', 'panelSession', 'panelSoap'];
                const sizes = panels.map(id => document.getElementById(id).style.flexBasis);
                localStorage.setItem('columnSizes', JSON.stringify(sizes));
                const sessionInfoHeight = document.getElementById('sessionInfoWrapper').style.flexBasis;
                const notesHeight = document.getElementById('notesWrapper').style.flexBasis;
                localStorage.setItem('rowSizes', JSON.stringify({ sessionInfoHeight, notesHeight }));
            }

            function loadColumnSizes() {
                const sizes = JSON.parse(localStorage.getItem('columnSizes'));
                if (sizes && sizes.length === 4) {
                    ['panelClients', 'panelAppointments', 'panelSession', 'panelSoap'].forEach((id, index) => {
                        const panel = document.getElementById(id);
                        if (panel) panel.style.flexBasis = sizes[index];
                    });
                }
                const rowSizes = JSON.parse(localStorage.getItem('rowSizes'));
                if (rowSizes) {
                    const sessionWrapper = document.getElementById('sessionInfoWrapper');
                    const notesWrapper = document.getElementById('notesWrapper');
                    if (sessionWrapper) sessionWrapper.style.flexBasis = rowSizes.sessionInfoHeight;
                    if (notesWrapper) notesWrapper.style.flexBasis = rowSizes.notesHeight;
                }
            }

            function makeResizable(resizer, prev, next, direction = 'x') {
                let x = 0;
                let y = 0;
                let prevSize = 0;
                let nextSize = 0;
                let containerSize = 0;

                resizer.addEventListener('mousedown', function (e) {
                    e.preventDefault();
                    if (direction === 'x') {
                        x = e.clientX;
                        prevSize = prev.getBoundingClientRect().width;
                        nextSize = next.getBoundingClientRect().width;
                        containerSize = prev.parentElement.getBoundingClientRect().width;
                    } else {
                        y = e.clientY;
                        prevSize = prev.getBoundingClientRect().height;
                        nextSize = next.getBoundingClientRect().height;
                        containerSize = prev.parentElement.getBoundingClientRect().height;
                    }
                    
                    document.body.style.cursor = direction === 'x' ? 'col-resize' : 'row-resize';
                    document.body.style.userSelect = 'none';

                    document.addEventListener('mousemove', mousemove);
                    document.addEventListener('mouseup', mouseup);
                });

                function mousemove(e) {
                    if (direction === 'x') {
                        const dx = e.clientX - x;
                        const newPrevSize = prevSize + dx;
                        const newNextSize = nextSize - dx;
                        
                        if(newPrevSize > 150 && newNextSize > 150) {
                            prev.style.flexBasis = `${(newPrevSize / containerSize) * 100}%`;
                            next.style.flexBasis = `${(newNextSize / containerSize) * 100}%`;
                        }
                    } else {
                        const dy = e.clientY - y;
                        const newPrevSize = prevSize + dy;
                        const newNextSize = nextSize - dy;

                        if(newPrevSize > 100 && newNextSize > 100) {
                            prev.style.flexBasis = `${(newPrevSize / containerSize) * 100}%`;
                            next.style.flexBasis = `${(newNextSize / containerSize) * 100}%`;
                        }
                    }
                }

                function mouseup() {
                    document.removeEventListener('mousemove', mousemove);
                    document.removeEventListener('mouseup', mouseup);
                    document.body.style.cursor = 'default';
                    document.body.style.userSelect = 'auto';
                    saveColumnSizes();
                }
            }
            
            // --- Initial Load & Render ---
            const loadServerSettings = () => {
                const savedProvider = localStorage.getItem('apiProvider');
                if (savedProvider) {
                    apiProvider = savedProvider;
                    apiProviderSelect.value = apiProvider;
                }
                
                const savedAddress = localStorage.getItem('serverAddress');
                const savedApiKey = localStorage.getItem('apiKey');
                const savedGeminiKey = localStorage.getItem('geminiApiKey');
                
                toggleProviderSettings(); // Set initial UI state

                if (apiProvider === 'openwebui' && savedAddress) {
                    serverAddressInput.value = savedAddress;
                    if(savedApiKey) apiKeyInput.value = savedApiKey;
                    connectToOpenWebUI();
                } else if (apiProvider === 'gemini' && savedGeminiKey) {
                    geminiApiKeyInput.value = savedGeminiKey;
                    connectToGemini();
                }
            };
            
            const loadTheme = () => {
                const savedTheme = localStorage.getItem('theme') || 'automatic';
                applyTheme(savedTheme);
            };

            appointmentDateInput.value = new Date().toISOString().split('T')[0];
            loadDataFromLocalStorage(); // This now loads API settings too
            loadServerSettings();
            loadColumnSizes();
            loadTheme();
            fullRender();
            
            makeResizable(document.getElementById('resizer1'), document.getElementById('panelClients'), document.getElementById('panelAppointments'));
            makeResizable(document.getElementById('resizer2'), document.getElementById('panelAppointments'), document.getElementById('panelSession'));
            makeResizable(document.getElementById('resizer3'), document.getElementById('panelSession'), document.getElementById('panelSoap'));
            makeResizable(document.getElementById('resizer-session-notes'), document.getElementById('sessionInfoWrapper'), document.getElementById('notesWrapper'), 'y');

        });
    </script>
</body>
</html>
