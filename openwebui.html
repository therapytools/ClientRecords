<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mental Health Client Data Organizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
            overflow: hidden;
        }

        .container {
            width: 100%;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
            height: calc(100vh - 20px);
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 12px 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }
        
        .header h1 {
            font-size: 1.5rem;
            margin-right: auto;
        }

        .btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        .btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }

        .btn.settings-btn {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
        }

        .btn.save-btn {
             background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        }

        .main-content {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }

        .panel {
            border-right: 2px solid #ecf0f1;
            background: #fafafa;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex-grow: 1; /* Allow panels to grow/shrink */
            flex-shrink: 1;
        }

        .panel:last-child {
            border-right: none;
        }
        
        .clients-panel { flex-basis: 20%; min-width: 180px; }
        .appointments-panel { flex-basis: 20%; min-width: 180px;}
        .session-panel { flex-basis: 30%; display: flex; flex-direction: column; min-width: 250px; }
        .soap-panel { flex-basis: 30%; min-width: 250px;}


        .panel-header {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            color: white;
            padding: 12px 15px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .add-btn {
            background: #27ae60;
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .add-btn:hover {
            background: #229954;
            transform: scale(1.1);
        }
        
        .add-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }

        .panel-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        .panel-footer {
            padding: 10px;
            border-top: 1px solid #ecf0f1;
            background: #fdfdfd;
            flex-shrink: 0;
        }
        
        input[type="date"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            font-family: inherit;
            background-color: white;
            color: #333;
        }

        /* Client Panel */
        .client-item {
            background: white;
            margin-bottom: 8px;
            padding: 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 4px solid #3498db;
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .client-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .client-item.active {
            background: #e3f2fd;
            border-left-color: #2196f3;
            font-weight: bold;
        }
        
        .client-item.dragging {
            opacity: 0.5;
        }
        
        .action-buttons {
            position: absolute;
            top: 5px; right: 5px;
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }
        .client-item:hover .action-buttons, .appointment-item:hover .action-buttons {
            opacity: 1;
        }
        .action-btn {
            border: none; color: white;
            width: 20px; height: 20px;
            border-radius: 50%;
            cursor: pointer; font-size: 12px;
            display: flex; align-items: center; justify-content: center;
        }
        .archive-btn { background: #f39c12; }
        .delete-btn { background: #e74c3c; }

        /* Appointments Panel */
        .appointment-item {
            background: white; margin-bottom: 8px; padding: 10px;
            border-radius: 6px; cursor: pointer; transition: all 0.2s ease;
            border-left: 4px solid #9b59b6; position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .appointment-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
        }
        .appointment-item.active {
            background: #f3e5f5;
            border-left-color: #9c27b0;
        }
        .appointment-date { font-weight: 600; color: #2c3e50; }

        /* Session and SOAP Panels */
        textarea {
            width: 100%; border: 1px solid #ddd; border-radius: 6px;
            padding: 12px; font-family: inherit; font-size: 14px;
            resize: none; transition: all 0.2s;
        }
        textarea:focus {
            outline: none; border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }
        
        .session-section {
            display: flex; flex-direction: column;
            flex-grow: 1; min-height: 0;
        }
        .session-section .panel-header {
             background: linear-gradient(135deg, #16a085 0%, #138d75 100%);
        }
        .session-section .panel-content {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
        }
        .session-section textarea {
            flex-grow: 1;
        }
        .persistent-notes-section .panel-header {
             background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }

        .soap-section { margin-bottom: 15px; }
        .soap-header {
            background: linear-gradient(135deg, #5D6D7E 0%, #34495E 100%);
            color: white; padding: 8px 12px;
            border-radius: 6px 6px 0 0; font-weight: 600;
            display: flex; justify-content: space-between; align-items: center;
        }
        .copy-btn {
            background: rgba(255, 255, 255, 0.2); border: none; color: white;
            padding: 4px 8px; border-radius: 4px; cursor: pointer;
            font-size: 12px; transition: all 0.2s;
        }
        .copy-btn:hover { background: rgba(255, 255, 255, 0.3); }
        .soap-textarea {
            border-radius: 0 0 6px 6px; border-top: none;
            flex-grow: 1;
            overflow-y: hidden; /* Hide vertical scrollbar */
        }

        .no-selection {
            color: #7f8c8d; text-align: center;
            margin-top: 50px; font-style: italic;
        }
        .autosave-indicator { color: white; font-size: 12px; margin-left: auto; }
        
        .deleted-list { max-height: 100px; overflow-y: auto; }
        .deleted-item { display: flex; justify-content: space-between; align-items: center; font-size: 0.8rem; padding: 2px 0; }
        .restore-btn {
             background: #3498db; color: white; border: none;
             padding: 2px 6px; border-radius: 4px; cursor: pointer;
        }
        .clear-deleted-btn {
            background: #e74c3c; color: white; border: none;
            padding: 2px 6px; border-radius: 4px; cursor: pointer;
            width: 100%; margin-top: 5px;
        }

        .resizer {
            background: #ecf0f1;
            cursor: col-resize;
            width: 6px;
            flex-shrink: 0;
            z-index: 10;
        }
        .resizer-y {
            background: #ecf0f1;
            cursor: row-resize;
            height: 6px;
            flex-shrink: 0;
            z-index: 10;
        }
        
        .hidden {
            display: none !important;
        }
        
        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            padding: 24px;
            border-radius: 12px;
            width: 100%;
            max-width: 512px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            position: relative; /* For the close button */
        }


    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Client Data Organizer <span style="font-size: 0.8rem; font-weight: normal; vertical-align: middle;">v.0.0.15</span></h1>
            <div id="autoSaveIndicator" class="autosave-indicator" style="opacity: 0;">
                <span id="saveStatus"></span>
            </div>
            <button id="manualSaveBtn" class="btn save-btn">Save Now</button>
            <button id="settingsBtn" class="btn settings-btn">Settings</button>
        </div>

        <div class="main-content" id="mainGrid">
            <!-- Clients Panel -->
            <div class="panel clients-panel" id="panelClients">
                <div class="panel-header">
                    <span>Clients</span>
                    <div style="display: flex; align-items: center;">
                        <button id="sortClientsBtn" title="Sort A-Z" class="btn" style="padding: 2px 6px; font-size: 12px; margin-right: 8px;">A-Z</button>
                        <button id="addClientBtn" class="add-btn">+</button>
                    </div>
                </div>
                <div class="panel-content" id="clientList">
                    <div class="no-selection">Click + to add a client</div>
                </div>
                <div class="panel-footer">
                     <h3 class="font-semibold text-gray-600 mb-2 text-sm">Recently Deleted</h3>
                     <div id="deletedClientsList" class="deleted-list"></div>
                     <button id="clearDeletedClientsBtn" class="clear-deleted-btn hidden">Clear All</button>
                </div>
                 <div class="panel-footer">
                     <h3 class="font-semibold text-gray-600 mb-2 text-sm">Archived</h3>
                     <div id="archivedClientsList" class="deleted-list"></div>
                </div>
            </div>

            <div class="resizer" id="resizer1"></div>

            <!-- Appointments Panel -->
            <div class="panel appointments-panel" id="panelAppointments">
                <div class="panel-header">
                    <span>Appointments</span>
                </div>
                <div class="panel-content" id="appointmentList">
                    <div class="no-selection">Select a client first</div>
                </div>
                <div class="panel-footer">
                     <label for="appointmentDateInput" style="font-weight: 600; color: #4A5568; font-size: 0.875rem; margin-bottom: 4px; display: block;">Appointment Date</label>
                     <div style="display: flex; align-items: center; gap: 8px;">
                         <input type="date" id="appointmentDateInput" style="flex-grow: 1;">
                         <button class="add-btn" id="addAppointmentBtn" disabled>+</button>
                     </div>
                </div>
                 <div class="panel-footer">
                     <h3 class="font-semibold text-gray-600 mb-2 text-sm">Recently Deleted</h3>
                     <div id="deletedAppointmentsList" class="deleted-list"></div>
                     <button id="clearDeletedAppointmentsBtn" class="clear-deleted-btn hidden">Clear All</button>
                </div>
            </div>

            <div class="resizer" id="resizer2"></div>

            <!-- Session & Notes Panel -->
            <div class="panel session-panel" id="panelSession">
                 <div id="sessionInfoWrapper" class="session-section" style="flex-basis: 50%;">
                    <div class="panel-header">
                        <span>Session Information</span>
                        <button id="generateNoteBtn" class="btn" style="padding: 4px 8px; font-size: 0.8rem;" disabled>Generate Note</button>
                    </div>
                    <div class="panel-content">
                         <textarea id="sessionInfo" placeholder="Select an appointment to enter session details..." disabled></textarea>
                    </div>
                    <div class="panel-footer" id="sessionTimerWrapper" style="display: none;">
                        <div style="display: flex; justify-content: space-between; align-items: center; gap: 10px;">
                            <button id="startTimerBtn" class="btn" style="flex-grow: 1;">Start</button>
                            <button id="stopTimerBtn" class="btn" style="flex-grow: 1;">Stop</button>
                            <div id="sessionDuration" style="font-weight: 600; white-space: nowrap;">00:00</div>
                        </div>
                    </div>
                </div>
                <div class="resizer-y" id="resizer-session-notes"></div>
                 <div id="notesWrapper" class="session-section persistent-notes-section" style="flex-basis: 50%;">
                    <div class="panel-header">
                        <span>Persistent Notes</span>
                    </div>
                    <div class="panel-content">
                         <textarea id="persistentNotes" placeholder="Select a client to enter persistent notes..." disabled></textarea>
                    </div>
                </div>
            </div>

            <div class="resizer" id="resizer3"></div>

            <!-- SOAP Notes Panel -->
            <div class="panel soap-panel" id="panelSoap">
                <div class="panel-header">
                    <span>SOAP Note</span>
                </div>
                <div class="panel-content" id="soapContent">
                    <div class="no-selection">Select an appointment to begin</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div id="settingsModal" class="modal-overlay hidden">
        <div class="modal-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid #ccc;">
                <h2 style="font-size: 1.5rem; font-weight: bold; color: #333;">Settings</h2>
                <button id="closeSettingsBtn" style="color: #555; font-size: 2rem; background: none; border: none; cursor: pointer;">&times;</button>
            </div>

            <div style="margin-bottom: 1.5rem;">
                <h3 style="font-size: 1.25rem; font-weight: 600; color: #444; margin-bottom: 0.75rem;">Connection</h3>
                <div style="display: flex; flex-direction: column; gap: 1rem;">
                    <div>
                        <label for="serverAddressInput" style="margin-bottom: 0.25rem; font-weight: 600; color: #555; display: block;">Open WebUI Address</label>
                        <input type="text" id="serverAddressInput" style="border: 1px solid #ccc; border-radius: 6px; padding: 8px; width: 100%;" placeholder="e.g., http://localhost:3000">
                    </div>
                    <div>
                        <label for="apiKeyInput" style="margin-bottom: 0.25rem; font-weight: 600; color: #555; display: block;">API Key (optional)</label>
                        <input type="password" id="apiKeyInput" style="border: 1px solid #ccc; border-radius: 6px; padding: 8px; width: 100%;">
                    </div>
                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <button id="connectApiBtn" class="btn">Connect</button>
                        <span id="apiStatus" style="font-size: 0.875rem; font-weight: 600;"></span>
                    </div>
                    <div>
                         <label for="modelSelect" style="margin-bottom: 0.25rem; font-weight: 600; color: #555; display: block;">AI Model</label>
                         <select id="modelSelect" style="border: 1px solid #ccc; border-radius: 6px; padding: 8px; width: 100%;" disabled>
                            <option>Connect to server first</option>
                        </select>
                    </div>
                </div>
            </div>

            <div>
                <h3 style="font-size: 1.25rem; font-weight: 600; color: #444; margin-bottom: 0.75rem;">Data Management</h3>
                <div style="display: flex; flex-wrap: wrap; gap: 1rem;">
                     <button id="exportBtn" class="btn">Export Data</button>
                     <button id="importBtn" class="btn" style="background: linear-gradient(135deg, #7f8c8d 0%, #95a5a6 100%);">Import Data</button>
                     <button id="eraseAllBtn" class="btn save-btn">Erase All Data</button>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" class="hidden" accept="application/json">

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const clientListEl = document.getElementById('clientList');
            const addClientBtn = document.getElementById('addClientBtn');
            const sortClientsBtn = document.getElementById('sortClientsBtn');
            const appointmentListEl = document.getElementById('appointmentList');
            const addAppointmentBtn = document.getElementById('addAppointmentBtn');
            const appointmentDateInput = document.getElementById('appointmentDateInput');
            const deletedClientsListEl = document.getElementById('deletedClientsList');
            const clearDeletedClientsBtn = document.getElementById('clearDeletedClientsBtn');
            const archivedClientsListEl = document.getElementById('archivedClientsList');
            const deletedAppointmentsListEl = document.getElementById('deletedAppointmentsList');
            const clearDeletedAppointmentsBtn = document.getElementById('clearDeletedAppointmentsBtn');
            const persistentNotesEl = document.getElementById('persistentNotes');
            const sessionInfoEl = document.getElementById('sessionInfo');
            const soapContentEl = document.getElementById('soapContent');
            const autoSaveIndicator = document.getElementById('autoSaveIndicator');
            const saveStatus = document.getElementById('saveStatus');
            // Session Timer Elements
            const sessionTimerWrapper = document.getElementById('sessionTimerWrapper');
            const startTimerBtn = document.getElementById('startTimerBtn');
            const stopTimerBtn = document.getElementById('stopTimerBtn');
            const sessionDurationEl = document.getElementById('sessionDuration');
            // Settings and Modal Elements
            const settingsBtn = document.getElementById('settingsBtn');
            const settingsModal = document.getElementById('settingsModal');
            const closeSettingsBtn = document.getElementById('closeSettingsBtn');
            const manualSaveBtn = document.getElementById('manualSaveBtn');
            const exportBtn = document.getElementById('exportBtn');
            const importBtn = document.getElementById('importBtn');
            const eraseAllBtn = document.getElementById('eraseAllBtn');
            // AI Integration Elements
            const serverAddressInput = document.getElementById('serverAddressInput');
            const apiKeyInput = document.getElementById('apiKeyInput');
            const connectApiBtn = document.getElementById('connectApiBtn');
            const apiStatus = document.getElementById('apiStatus');
            const modelSelect = document.getElementById('modelSelect');
            const generateNoteBtn = document.getElementById('generateNoteBtn');
            const fileInput = document.getElementById('fileInput');

            // App State
            let data = { clients: [], archivedClients: [] };
            let deletedItems = { clients: [], appointments: [] };
            let selectedClientId = null;
            let selectedAppointmentId = null;
            let isDirty = false;
            let serverAddress = null;
            let apiKey = null;
            let selectedModel = null;
            let sessionTimerInterval = null;
            const getInitialData = () => ({ clients: [], archivedClients: [] });

            // --- Data Management ---
            const findClient = id => data.clients.find(c => c.id === id) || data.archivedClients.find(c => c.id === id);
            const findAppointment = (client, id) => client?.appointments.find(a => a.id === id);
            
            // --- UI Rendering ---
            const renderClients = () => {
                // Note: Drag and drop reordering means we can't sort here anymore.
                // The array order is now the source of truth for display order.
                const clients = data.clients; 
                if (clients.length === 0) {
                    clientListEl.innerHTML = '<div class="no-selection">Click + to add a client</div>';
                    return;
                }
                clientListEl.innerHTML = clients.map(client => `
                    <div class="client-item ${client.id === selectedClientId ? 'active' : ''}" data-client-id="${client.id}" draggable="true">
                        ${client.name}
                        <div class="action-buttons">
                            <button class="action-btn archive-btn" title="Archive Client">A</button>
                            <button class="action-btn delete-btn" title="Delete Client">×</button>
                        </div>
                    </div>
                `).join('');
            };

            const renderAppointments = () => {
                const client = findClient(selectedClientId);
                addAppointmentBtn.disabled = !client;
                if (!client) {
                    appointmentListEl.innerHTML = '<div class="no-selection">Select a client first</div>';
                    return;
                }
                const appointments = (client.appointments || []).sort((a, b) => new Date(b.date) - new Date(a.date));
                if (appointments.length === 0) {
                    appointmentListEl.innerHTML = '<div class="no-selection">Click + to add appointment</div>';
                    return;
                }
                appointmentListEl.innerHTML = appointments.map(appt => `
                    <div class="appointment-item ${appt.id === selectedAppointmentId ? 'active' : ''}" data-appointment-id="${appt.id}">
                        <div class="appointment-date">${new Date(appt.date).toLocaleDateString()}</div>
                        <div class="action-buttons">
                            <button class="action-btn delete-btn" title="Delete Appointment">×</button>
                        </div>
                    </div>
                `).join('');
            };

            const renderDetails = () => {
                const client = findClient(selectedClientId);
                const appointment = client ? findAppointment(client, selectedAppointmentId) : null;
                
                persistentNotesEl.disabled = !client;
                persistentNotesEl.value = client ? client.persistentNotes || '' : '';
                persistentNotesEl.placeholder = client ? "Enter persistent notes for this client..." : "Select a client to enter persistent notes...";

                sessionInfoEl.disabled = !appointment;
                sessionInfoEl.value = appointment ? appointment.sessionInfo || '' : '';
                sessionInfoEl.placeholder = appointment ? "Enter session details..." : "Select an appointment to begin...";
                
                sessionTimerWrapper.style.display = appointment ? 'block' : 'none';
                if (appointment) {
                    renderSessionTimer(appointment);
                }

                renderSoap();
                
                generateNoteBtn.disabled = !appointment || !selectedModel || !sessionInfoEl.value.trim();
            };
            
            const renderSessionTimer = (appointment) => {
                clearInterval(sessionTimerInterval);

                if (appointment.startTime) {
                    startTimerBtn.textContent = `Start: ${new Date(appointment.startTime).toLocaleTimeString()}`;
                } else {
                    startTimerBtn.textContent = 'Start';
                }

                if (appointment.endTime) {
                    stopTimerBtn.textContent = `End: ${new Date(appointment.endTime).toLocaleTimeString()}`;
                } else {
                    stopTimerBtn.textContent = 'Stop';
                }

                const updateDuration = () => {
                    if (!appointment.startTime) {
                        sessionDurationEl.textContent = '00:00';
                        return;
                    }
                    
                    const start = new Date(appointment.startTime);
                    const end = appointment.endTime ? new Date(appointment.endTime) : new Date();
                    
                    let totalSeconds = Math.floor((end - start) / 1000);
                    if (totalSeconds < 0) totalSeconds = 0;

                    const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
                    const seconds = (totalSeconds % 60).toString().padStart(2, '0');
                    
                    sessionDurationEl.textContent = `${minutes}:${seconds}`;
                };

                updateDuration();

                // If the timer is running (start time exists but no end time), set an interval to update it.
                if (appointment.startTime && !appointment.endTime) {
                    sessionTimerInterval = setInterval(updateDuration, 1000);
                }
            };

            const renderSoap = () => {
                const client = findClient(selectedClientId);
                const appointment = client ? findAppointment(client, selectedAppointmentId) : null;

                if (!appointment) {
                    soapContentEl.innerHTML = '<div class="no-selection">Select an appointment to begin</div>';
                    return;
                }

                const soapData = appointment.soap || { s: '', o: '', a: '', p: '' };
                soapContentEl.innerHTML = `
                    <div class="soap-section">
                        <div class="soap-header"><span>Subjective</span><button class="copy-btn" data-target="soapS">Copy</button></div>
                        <textarea id="soapS" class="soap-textarea" placeholder="• ">${soapData.s || ''}</textarea>
                    </div>
                    <div class="soap-section">
                        <div class="soap-header"><span>Objective</span><button class="copy-btn" data-target="soapO">Copy</button></div>
                        <textarea id="soapO" class="soap-textarea" placeholder="• ">${soapData.o || ''}</textarea>
                    </div>
                    <div class="soap-section">
                        <div class="soap-header"><span>Assessment</span><button class="copy-btn" data-target="soapA">Copy</button></div>
                        <textarea id="soapA" class="soap-textarea" placeholder="• ">${soapData.a || ''}</textarea>
                    </div>
                    <div class="soap-section">
                        <div class="soap-header"><span>Plan</span><button class="copy-btn" data-target="soapP">Copy</button></div>
                        <textarea id="soapP" class="soap-textarea" placeholder="• ">${soapData.p || ''}</textarea>
                    </div>`;
                
                // After rendering, resize all textareas
                soapContentEl.querySelectorAll('.soap-textarea').forEach(autoResizeTextarea);
            };

            const renderDeletedLists = () => {
                deletedClientsListEl.innerHTML = '';
                clearDeletedClientsBtn.classList.toggle('hidden', deletedItems.clients.length === 0);
                deletedItems.clients.forEach(client => {
                    const div = document.createElement('div');
                    div.className = 'deleted-item';
                    div.innerHTML = `<span>${client.name}</span><button class="restore-btn" data-id="${client.id}">Restore</button>`;
                    deletedClientsListEl.appendChild(div);
                });

                deletedAppointmentsListEl.innerHTML = '';
                 clearDeletedAppointmentsBtn.classList.toggle('hidden', deletedItems.appointments.length === 0);
                deletedItems.appointments.forEach(appt => {
                    const clientName = findClient(appt.clientId)?.name?.substring(0, 5) + '...' || 'N/A';
                    const div = document.createElement('div');
                    div.className = 'deleted-item';
                    div.innerHTML = `<span>${new Date(appt.date).toLocaleDateString()} (${clientName})</span><button class="restore-btn" data-id="${appt.id}">Restore</button>`;
                    deletedAppointmentsListEl.appendChild(div);
                });
            };

            const renderArchivedClients = () => {
                archivedClientsListEl.innerHTML = '';
                (data.archivedClients || []).forEach(client => {
                     const div = document.createElement('div');
                     div.className = 'deleted-item';
                     div.innerHTML = `<span>${client.name}</span><button class="restore-btn" data-id="${client.id}">Unarchive</button>`;
                     archivedClientsListEl.appendChild(div);
                });
            };

            const fullRender = () => {
                renderClients();
                renderAppointments();
                renderDetails();
                renderDeletedLists();
                renderArchivedClients();
            };

            // --- Event Handlers & Actions ---
            const selectClient = (id) => {
                selectedClientId = id;
                selectedAppointmentId = null;
                clearInterval(sessionTimerInterval); // Stop timer when switching clients
                fullRender();
            };

            const selectAppointment = (id) => {
                selectedAppointmentId = id;
                fullRender();
            };

            const addClient = () => {
                const name = prompt("Enter new client's name:");
                if (!name || !name.trim()) return;
                const newClient = {
                    id: crypto.randomUUID(),
                    name: name.trim(),
                    persistentNotes: '',
                    appointments: []
                };
                data.clients.push(newClient);
                selectClient(newClient.id);
                markDirty();
            };

            const addAppointment = () => {
                const client = findClient(selectedClientId);
                if (!client) return;
                const date = appointmentDateInput.value;
                if (!date) {
                    alert('Please select a date for the appointment.');
                    return;
                }
                const dateObj = new Date(date);
                const utcDate = new Date(dateObj.getUTCFullYear(), dateObj.getUTCMonth(), dateObj.getUTCDate());

                const newAppointment = {
                    id: crypto.randomUUID(),
                    date: utcDate.toISOString(),
                    sessionInfo: '',
                    startTime: null,
                    endTime: null,
                    soap: { s: '', o: '', a: '', p: '' }
                };
                client.appointments.push(newAppointment);
                selectAppointment(newAppointment.id);
                markDirty();
            };
            
            clientListEl.addEventListener('click', (e) => {
                const clientItem = e.target.closest('.client-item');
                if (!clientItem) return;

                const clientId = clientItem.dataset.clientId;

                if (e.target.classList.contains('delete-btn')) {
                     const client = findClient(clientId);
                     if (confirm(`Are you sure you want to delete ${client.name}?`)) {
                        const clientIndex = data.clients.findIndex(c => c.id === clientId);
                        if (clientIndex === -1) return;
                        const [removedClient] = data.clients.splice(clientIndex, 1);
                        if (removedClient.appointments) {
                             deletedItems.appointments.push(...removedClient.appointments.map(a => ({...a, clientId})));
                        }
                        deletedItems.clients.push(removedClient);
                        if (selectedClientId === clientId) {
                            selectedClientId = null;
                            selectedAppointmentId = null;
                        }
                        markDirty();
                        fullRender();
                     }
                } else if (e.target.classList.contains('archive-btn')) {
                    const clientIndex = data.clients.findIndex(c => c.id === clientId);
                    if (clientIndex === -1) return;
                    const [client] = data.clients.splice(clientIndex, 1);
                    if (!data.archivedClients) data.archivedClients = [];
                    data.archivedClients.push(client);
                    if (selectedClientId === clientId) {
                        selectedClientId = null;
                        selectedAppointmentId = null;
                    }
                    markDirty();
                    fullRender();
                } else {
                    selectClient(clientId);
                }
            });

            // --- Drag and Drop Client Reordering ---
            let draggedClientId = null;

            clientListEl.addEventListener('dragstart', (e) => {
                const clientItem = e.target.closest('.client-item');
                if (clientItem) {
                    draggedClientId = clientItem.dataset.clientId;
                    // Add a class for visual feedback
                    setTimeout(() => clientItem.classList.add('dragging'), 0);
                }
            });

            clientListEl.addEventListener('dragend', (e) => {
                const clientItem = e.target.closest('.client-item');
                if (clientItem) {
                    clientItem.classList.remove('dragging');
                }
                draggedClientId = null;
            });

            clientListEl.addEventListener('dragover', (e) => {
                e.preventDefault(); // Necessary to allow dropping
                const targetItem = e.target.closest('.client-item');
                if (targetItem && targetItem.dataset.clientId !== draggedClientId) {
                    // This is where you could add a visual indicator if desired
                }
            });

            clientListEl.addEventListener('drop', (e) => {
                e.preventDefault();
                const targetItem = e.target.closest('.client-item');
                if (targetItem && draggedClientId) {
                    const targetId = targetItem.dataset.clientId;
                    
                    const draggedIndex = data.clients.findIndex(c => c.id === draggedClientId);
                    const targetIndex = data.clients.findIndex(c => c.id === targetId);

                    if (draggedIndex > -1 && targetIndex > -1) {
                        // Remove the dragged item
                        const [draggedItem] = data.clients.splice(draggedIndex, 1);
                        // Insert it at the target's position
                        data.clients.splice(targetIndex, 0, draggedItem);
                        
                        markDirty();
                        renderClients(); // Re-render to reflect the new order
                    }
                }
            });

            appointmentListEl.addEventListener('click', (e) => {
                 const appointmentItem = e.target.closest('.appointment-item');
                 if (!appointmentItem) return;

                 const appointmentId = appointmentItem.dataset.appointmentId;
                 
                 if (e.target.classList.contains('delete-btn')) {
                    const client = findClient(selectedClientId);
                    if (!client) return;
                    const apptIndex = client.appointments.findIndex(a => a.id === appointmentId);
                    if (apptIndex > -1) {
                        const [appt] = client.appointments.splice(apptIndex, 1);
                        deletedItems.appointments.push({ ...appt, clientId: client.id });
                        if (selectedAppointmentId === appointmentId) {
                            selectedAppointmentId = null;
                        }
                        markDirty();
                        fullRender();
                    }
                 } else {
                     selectAppointment(appointmentId);
                 }
            });
            
            deletedClientsListEl.addEventListener('click', e => {
                if (e.target.classList.contains('restore-btn')) {
                    const id = e.target.dataset.id;
                    const clientIndex = deletedItems.clients.findIndex(c => c.id === id);
                    if (clientIndex === -1) return;
                    const [client] = deletedItems.clients.splice(clientIndex, 1);
                    data.clients.push(client);
                    markDirty();
                    fullRender();
                }
            });

            archivedClientsListEl.addEventListener('click', e => {
                if (e.target.classList.contains('restore-btn')) {
                    const id = e.target.dataset.id;
                    if (!data.archivedClients) return;
                    const clientIndex = data.archivedClients.findIndex(c => c.id === id);
                    if (clientIndex === -1) return;
                    const [client] = data.archivedClients.splice(clientIndex, 1);
                    data.clients.push(client);
                    markDirty();
                    fullRender();
                }
            });

            deletedAppointmentsListEl.addEventListener('click', e => {
                 if (e.target.classList.contains('restore-btn')) {
                    const id = e.target.dataset.id;
                    const apptIndex = deletedItems.appointments.findIndex(a => a.id === id);
                    if (apptIndex === -1) return;

                    const [appt] = deletedItems.appointments.splice(apptIndex, 1);
                    const client = findClient(appt.clientId);
                    if (client) {
                        if (!client.appointments) client.appointments = [];
                        client.appointments.push(appt);
                        markDirty();
                        fullRender();
                    } else {
                        deletedItems.appointments.push(appt);
                        alert('Cannot restore. Client not found.');
                    }
                 }
            });
            
            clearDeletedClientsBtn.addEventListener('click', () => {
                if(confirm('Permanently delete all recently deleted clients?')) {
                    deletedItems.clients = [];
                    markDirty();
                    fullRender();
                }
            });
            clearDeletedAppointmentsBtn.addEventListener('click', () => {
                 if(confirm('Permanently delete all recently deleted appointments?')) {
                    deletedItems.appointments = [];
                    markDirty();
                    fullRender();
                }
            });
            
            persistentNotesEl.addEventListener('input', () => {
                 const client = findClient(selectedClientId);
                 if (client) {
                    client.persistentNotes = persistentNotesEl.value;
                    markDirty();
                 }
            });

            const autoResizeTextarea = (el) => {
                el.style.height = 'auto';
                el.style.height = el.scrollHeight + 'px';
            };

            // --- Generic Bullet Point Handlers ---
            const formatBulletPoints = (text) => {
                // Replace any '•' that isn't at the start of a line with a newline and then '•'
                let formattedText = text.replace(/([^\n])\s*•/g, '$1\n•');

                // Ensure every non-empty line starts with a bullet, and clean up lines
                let lines = formattedText.split('\n');
                let newLines = lines.map(line => {
                    let trimmedLine = line.trim();
                    if (trimmedLine.length > 0) {
                        if (trimmedLine.startsWith('•')) {
                            // Return the line with a single bullet and trimmed content
                            return '• ' + trimmedLine.substring(1).trim();
                        } else {
                            // Add a bullet to a line that doesn't have one
                            return '• ' + trimmedLine;
                        }
                    }
                    return ''; // Return empty string for empty lines
                }).filter(line => line.length > 0); // Remove all empty lines

                // Ensure the very first line starts with a bullet if there's any content
                if (newLines.length > 0 && !newLines[0].startsWith('•')) {
                    newLines[0] = '• ' + newLines[0];
                }

                return newLines.join('\n');
            };

            const handleBulletedInput = (e, saveDataCallback) => {
                const textarea = e.target;
                const originalValue = textarea.value;
                const originalCursor = textarea.selectionStart;

                const newValue = formatBulletPoints(originalValue);

                if (newValue !== originalValue) {
                    textarea.value = newValue;
                    // This is a simple cursor repositioning, might not be perfect but is better than nothing.
                    const diff = newValue.length - originalValue.length;
                    textarea.selectionStart = textarea.selectionEnd = originalCursor + diff;
                }
                
                // Auto-resize
                autoResizeTextarea(textarea);

                // Save changes using the provided callback
                saveDataCallback(textarea);
            };
            
            const handleBulletedKeyDown = (e) => {
                if (e.key !== 'Enter') return;

                e.preventDefault();
                const textarea = e.target;
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const text = textarea.value;
                
                const currentLineStart = text.lastIndexOf('\n', start - 1) + 1;
                const currentLine = text.substring(currentLineStart, start);

                if (currentLine.trim() === '•') {
                    textarea.value = text.substring(0, currentLineStart) + text.substring(end);
                    textarea.selectionStart = textarea.selectionEnd = currentLineStart;
                } else {
                    textarea.value = text.substring(0, start) + '\n• ' + text.substring(end);
                    textarea.selectionStart = textarea.selectionEnd = start + 3;
                }
                
                textarea.dispatchEvent(new Event('input', { bubbles: true }));
            };

            // --- Specific Save Callbacks ---
            const saveSessionInfo = (textarea) => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (appointment) {
                    appointment.sessionInfo = textarea.value;
                    markDirty();
                }
                generateNoteBtn.disabled = !appointment || !selectedModel || !textarea.value.trim();
            };

            const saveSoapNote = (textarea) => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (appointment) {
                    const key = textarea.id.slice(-1).toLowerCase();
                    if (!appointment.soap) appointment.soap = {s:'', o:'', a:'', p:''};
                    appointment.soap[key] = textarea.value;
                    markDirty();
                }
            };

            // --- Attach Bullet Point Handlers ---
            sessionInfoEl.addEventListener('input', (e) => handleBulletedInput(e, saveSessionInfo));
            sessionInfoEl.addEventListener('keydown', handleBulletedKeyDown);

            soapContentEl.addEventListener('input', (e) => {
                if (e.target.matches('.soap-textarea')) {
                    handleBulletedInput(e, saveSoapNote);
                }
            });
            soapContentEl.addEventListener('keydown', (e) => {
                if (e.target.matches('.soap-textarea')) {
                    handleBulletedKeyDown(e);
                }
            });

            soapContentEl.addEventListener('click', (e) => {
                 if (e.target.classList.contains('copy-btn')) {
                     const targetId = e.target.dataset.target;
                     const textarea = document.getElementById(targetId);
                     if (!textarea) return;
                     navigator.clipboard.writeText(textarea.value).then(() => {
                        const messageBox = document.getElementById('messageBox');
                        messageBox.textContent = 'Copied to clipboard!';
                        messageBox.classList.remove('opacity-0');
                        setTimeout(() => messageBox.classList.add('opacity-0'), 2000);
                     });
                 }
            });


            const systemPrompt = `You are a helpful assistant for a therapist or clinician. Your primary function is to accurately categorize user-provided session notes into a structured SOAP note format.

**Your Task:**
Analyze the "Session Information" text provided by the user. Categorize every piece of information into one of the four SOAP sections based on the strict definitions below.

- **Subjective (S):** Information reported by the client (e.g., feelings, goals, history). This is for the client's voice and perspective. **EXCEPTION:** If a client's report is directly tied to a therapeutic intervention or a reflection by the writer, that entire interaction belongs in the Objective section.
- **Objective (O):** Everything that *happens* in the therapy session. This includes all therapeutic interventions, actions taken, connections made, and reflections or psychoeducation provided by the writer.
- **Assessment (A):** The writer's clinical analysis and observations. This includes notes on progress towards goals and direct observations of the client's state (e.g., "client appeared tired," "client's affect was bright").
- **Plan (P):** The course of action for future sessions. This includes topics to be addressed, homework, and any modifications to the treatment plan.

**CRITICAL INSTRUCTIONS:**
- **THE GOLDEN RULE:** ONLY use information explicitly provided in the "Session Information" text. Do not use any information from the example output below, which is for formatting reference only.
- **INFORMATION FIDELITY:**
    - **NO NEW INFORMATION:** You must not add, invent, or infer any details, events, or feelings not explicitly stated in the "Session Information." Your task is to categorize, not create.
    - **NO ASSUMPTIONS:** Do not make clinical assumptions. If the text says "Ct cried," report "Ct cried." Do not interpret this as "Ct was sad" unless the text also states that.
    - **PRESERVE QUOTES:** Only use quotation marks in your output if the "Session Information" contains a direct quote. Do not put paraphrased statements in quotes.
- **TENSE:** All output must be in the past tense. For example, use "Ct reported" instead of "Ct reports," and "Writer stated" instead of "Writer states."
- **REFERRALS & PRONOUNS:**
    - Always refer to the client as **"Ct"**. Do NOT use the client's actual name, which is provided for context only.
    - Always refer to the therapist/clinician (the user) as **"Writer."** Use the third person (e.g., "Writer observed..."). Do not use "I" or "me."
    - Never use articles before the referrals. It is always "Ct" or "Writer," never "the Ct" or "the Writer."
- **ESCAPE QUOTES:** You MUST escape any double quotes inside the JSON string values. For example, if the client says "I feel sad," the JSON output should be '{"s":"• Ct reported feeling \\"sad.\\""}'.
- **DO NOT INVENT:** Your response must ONLY contain information found in the "Session Information" text. Do not add any details, assumptions, or statements that are not explicitly provided.
- **DO NOT INTERPRET BEYOND CATEGORIZATION:** Your job is to sort the provided information, not to add clinical interpretation or make assumptions about progress, affect, or presentation unless it is explicitly stated in the source text. For example, do not write "client appeared tired" unless the source text says "client appeared tired."

**Output Format:**
Your entire response MUST be a single, raw, and syntactically correct JSON object. Do not wrap it in markdown code fences. Do not add any explanatory text, comments, or any words outside of the JSON object itself. The JSON object must have exactly four keys: "s", "o", "a", and "p". Each key's value must be a string formatted with bullet points (•) for each distinct point.

**Example of PERFECT Output (FOR FORMATTING ONLY):**
{"s":"• [Subjective point from session info]\\n• [Another subjective point, with a quote like \\"this.\\"]","o":"• [Objective point from session info]","a":"• [Assessment point from session info]","p":"• [Plan point from session info]"}
`;

            const generateSoapNote = async () => {
                if (!selectedModel) {
                    alert('Please connect to your server and select a model first.');
                    return;
                }

                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (!client || !appointment || !sessionInfoEl.value.trim()) {
                    alert('Please select a client and appointment, and enter some session information.');
                    return;
                }

                generateNoteBtn.disabled = true;
                generateNoteBtn.textContent = 'Generating...';

                const userPrompt = `
- **Client Name:** ${client.name}
- **Session Information (This Session):**
${sessionInfoEl.value}
`;

                const payload = {
                    model: selectedModel,
                    messages: [
                        { "role": "system", "content": systemPrompt },
                        { "role": "user", "content": userPrompt }
                    ],
                    response_format: { "type": "json_object" },
                    stream: false
                };
                
                try {
                    const headers = new Headers({ 'Content-Type': 'application/json' });
                     if (apiKey) {
                        headers.append('Authorization', `Bearer ${apiKey}`);
                    }
                    const response = await fetch(`${serverAddress}/api/v1/chat/completions`, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        const error = new Error(`API error: ${response.status} - ${errorText}`);
                        error.response = response;
                        throw error;
                    }

                    const result = await response.json();
                    let content = result.choices[0].message.content;
                    let soapData = {};

                    // Aggressive JSON extraction and cleanup
                    try {
                        // Find the first '{' and the last '}' to extract the JSON part.
                        const firstBrace = content.indexOf('{');
                        const lastBrace = content.lastIndexOf('}');
                        if (firstBrace === -1 || lastBrace === -1 || lastBrace < firstBrace) {
                            throw new Error('AI response did not contain a valid JSON object.');
                        }
                        let jsonString = content.substring(firstBrace, lastBrace + 1);
                        
                        // Attempt to parse it. If it fails, it's likely due to malformed content.
                        try {
                            soapData = JSON.parse(jsonString);
                        } catch (e) {
                            console.warn("Initial JSON.parse failed. Attempting to clean and re-parse.", e.message);
                            // This is a more robust fallback for models that fail to escape content correctly.
                            // It performs multiple passes to clean up common issues.
                            
                            // 1. Remove newlines within JSON strings, which is a common error.
                            let cleanedString = jsonString.replace(/:\s*"(.*?)"/gs, (match, group1) => {
                                const singleLineGroup = group1.replace(/\n/g, '\\n').replace(/\r/g, '');
                                return `: "${singleLineGroup}"`;
                            });

                            // 2. Fix unescaped quotes inside values. This is more complex.
                            // We look for a quote that is not preceded by a backslash.
                            cleanedString = cleanedString.replace(/:\s*"(.*?)"/g, (match, group1) => {
                                const fixedGroup = group1.replace(/(?<!\\)"/g, '\\"');
                                return `: "${fixedGroup}"`;
                            });

                            soapData = JSON.parse(cleanedString); // Retry parsing with the cleaned string
                        }

                    } catch (parseError) {
                        console.error("Failed to parse the following JSON string from the AI:", content);
                        throw new Error(`The AI model returned malformed JSON that could not be automatically fixed. Check the browser console for the raw output. Details: ${parseError.message}`);
                    }
                    
                    for (const key in soapData) {
                        if (typeof soapData[key] === 'string') {
                            // Format bullet points for every key
                            soapData[key] = formatBulletPoints(soapData[key]);
                        } else if (Array.isArray(soapData[key])) {
                            // This handles cases where the AI might return an array of strings
                            soapData[key] = soapData[key].map(item => {
                                const cleanedItem = item.toString().trim().replace(/^•\s*/, '');
                                return `• ${cleanedItem}`;
                            }).join('\n');
                            soapData[key] = formatBulletPoints(soapData[key]);
                        }
                    }

                    if (typeof soapData.s !== 'string' || typeof soapData.o !== 'string' || typeof soapData.a !== 'string' || typeof soapData.p !== 'string') {
                        console.error("Received valid JSON from AI, but it was missing required SOAP keys or they were not strings after processing. Received object:", soapData);
                        throw new Error(`AI response was not in the expected JSON format (missing s, o, a, or p keys). The AI returned: ${JSON.stringify(soapData)}`);
                    }
                    
                    if (!appointment.soap) appointment.soap = {};
                    appointment.soap.s = soapData.s;
                    appointment.soap.o = soapData.o;
                    appointment.soap.a = soapData.a;
                    appointment.soap.p = soapData.p;
                    markDirty();
                    renderSoap();

                } catch (error) {
                    console.error('SOAP Note Generation Error:', error);
                    let alertMessage = `Failed to generate SOAP note. Please check your connection and the console for details.\nError: ${error.message}`;
                     
                    if (error.response?.status === 401) {
                         alertMessage = `Authentication failed (401 Unauthorized) while trying to generate the note. Please re-check your API Key.`;
                    } else if (error instanceof TypeError && error.message.toLowerCase().includes('failed to fetch')) {
                        alertMessage = `Network Error: Failed to fetch. Check CORS policy on your server.`;
                    }
                    alert(alertMessage);
                } finally {
                    generateNoteBtn.disabled = false;
                    generateNoteBtn.textContent = 'Generate Note';
                }
            };
            
            const connectToServer = async () => {
                const address = serverAddressInput.value.trim();
                if (!address) {
                    alert('Please enter an Open WebUI address.');
                    return;
                }
                serverAddress = address.endsWith('/') ? address.slice(0, -1) : address;
                apiKey = apiKeyInput.value.trim();

                // Save settings to local storage immediately
                localStorage.setItem('serverAddress', serverAddress);
                if (apiKey) {
                    localStorage.setItem('apiKey', apiKey);
                } else {
                    localStorage.removeItem('apiKey');
                }

                apiStatus.textContent = 'Connecting...';
                apiStatus.style.color = 'orange';
                modelSelect.innerHTML = '<option>Loading models...</option>';
                modelSelect.disabled = true;

                try {
                    const headers = new Headers();
                    if (apiKey) {
                        headers.append('Authorization', `Bearer ${apiKey}`);
                    }
                    const response = await fetch(`${serverAddress}/api/v1/models`, { headers });
                    if (!response.ok) {
                        const error = new Error(`Failed to connect to Open WebUI. Status: ${response.status}`);
                        error.response = response;
                        throw error;
                    }
                    const data = await response.json();
                    
                    apiStatus.textContent = 'Connected';
                    apiStatus.style.color = 'green';
                    
                    // localStorage.setItem('serverAddress', serverAddress);
                    // if (apiKey) localStorage.setItem('apiKey', apiKey);
                    // else localStorage.removeItem('apiKey');
                    
                    modelSelect.innerHTML = '';
                    const models = data.data;

                    if (models && models.length > 0) {
                        models.forEach(model => {
                            const option = document.createElement('option');
                            option.value = model.id;
                            option.textContent = model.id;
                            modelSelect.appendChild(option);
                        });

                        let autoSelectedModelId = null;
                        const llamaModel = models.find(m => m.id === 'llama3.2:3b');
                        const deepseekModel = models.find(m => m.id === 'deepseek-r1:1.5b');

                        if (llamaModel) {
                            autoSelectedModelId = llamaModel.id;
                        } else if (deepseekModel) {
                            autoSelectedModelId = deepseekModel.id;
                        } else {
                            const fallbackModel = models.find(m => 
                                m.id !== 'arena-model' && 
                                !m.id.toLowerCase().includes('coder') && 
                                !m.id.toLowerCase().includes('coding')
                            );
                            if (fallbackModel) {
                                autoSelectedModelId = fallbackModel.id;
                            }
                        }

                        if (autoSelectedModelId) {
                            modelSelect.value = autoSelectedModelId;
                        } else if (models.length > 0) {
                            modelSelect.value = models[0].id;
                        }

                        selectedModel = modelSelect.value;
                        modelSelect.disabled = false;
                        
                    } else {
                        modelSelect.innerHTML = '<option>No models found</option>';
                        selectedModel = null;
                        modelSelect.disabled = true;
                    }

                } catch (error) {
                    console.error('API connection error:', error);
                    apiStatus.textContent = 'Failed';
                    apiStatus.style.color = 'red';
                    serverAddress = null;
                    modelSelect.innerHTML = '<option>Connection failed</option>';
                    
                    let alertMessage = `Connection to "${address}" failed.`;
                    
                    if (error.response?.status === 401) {
                         alertMessage += `\n\nError: Authentication failed (401 Unauthorized). Please check if your API Key is correct and has the necessary permissions. Some servers require an API key even if it's optional in the UI.`;
                    } else if (error instanceof TypeError && error.message.toLowerCase().includes('failed to fetch')) {
                        alertMessage = `Network Error: Failed to fetch.

This is the most common error and is almost always caused by one of two things:

1.  **CORS Policy:** Your browser is blocking the request for security reasons. The Open WebUI server must be configured to allow requests from this webpage.
    *SOLUTION:* In your Open WebUI settings, find the "Allowed Origins" configuration and add the URL of this page. You can often just add "*" to allow all origins, but this is less secure.

2.  **Server Not Reachable:** The address "${address}" is incorrect, or the Open WebUI server is not running. Please double-check the address and ensure the server is active.

This error cannot be fixed within this application's code; it requires a configuration change on the server you are trying to connect to.`;
                    } else {
                        alertMessage += `\n\nError: ${error.message}`;
                    }
                    alert(alertMessage);

                } finally {
                    fullRender();
                }
            };


            // --- Data Persistence (Save/Load/AutoSave) ---
            const updateSaveStatus = (message, isGood = true, duration = 0) => {
                autoSaveIndicator.style.opacity = '1';
                saveStatus.textContent = message;
                saveStatus.style.color = isGood ? 'white' : '#f1c40f'; // Gold for warning
                if (duration > 0) {
                    setTimeout(() => {
                         if (saveStatus.textContent === message) {
                            autoSaveIndicator.style.opacity = '0';
                         }
                    }, duration);
                }
            }

            const markDirty = () => {
                if (!isDirty) {
                    isDirty = true;
                    updateSaveStatus('Unsaved changes...', false);
                }
                debouncedAutoSave();
            };

            const saveDataToCookie = () => {
                try {
                    const state = { data, deletedItems, selectedClientId, selectedAppointmentId };
                    const dataStr = JSON.stringify(state);
                    // Check if the cookie size exceeds the limit (e.g., 4KB)
                    if (encodeURIComponent(dataStr).length > 4000) {
                        updateSaveStatus('Data too large for cookie!', false, 5000);
                        console.warn("Data size is large, cookie saving might fail. Consider exporting to a file.");
                    }
                    document.cookie = `clientData=${encodeURIComponent(dataStr)};path=/;max-age=31536000;samesite=strict`;
                    isDirty = false;
                } catch (e) {
                    console.error("Failed to save to cookie", e);
                    updateSaveStatus('Cookie save failed!', false, 3000);
                }
            };

            const loadDataFromCookie = () => {
                const cookie = document.cookie.split('; ').find(row => row.startsWith('clientData='));
                if (cookie) {
                    try {
                        const state = JSON.parse(decodeURIComponent(cookie.split('=')[1]));
                        data = state.data || getInitialData();
                        if (!data.archivedClients) data.archivedClients = [];
                        deletedItems = state.deletedItems || { clients: [], appointments: [] };
                        selectedClientId = state.selectedClientId || null;
                        selectedAppointmentId = state.selectedAppointmentId || null;
                    } catch (e) {
                        console.error("Failed to load from cookie", e);
                        data = getInitialData();
                        deletedItems = { clients: [], appointments: [] };
                    }
                }
            };

            const exportFile = () => {
                try {
                    const stateToSave = { data, deletedItems, selectedClientId, selectedAppointmentId };
                    const stateJSON = JSON.stringify(stateToSave, null, 2);
                    const blob = new Blob([stateJSON], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `client-data-${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    updateSaveStatus('Exported.', true, 2000);
                } catch (err) {
                    console.error('Failed to export file:', err);
                    alert('Export failed!');
                    updateSaveStatus('Export failed!', false, 3000);
                }
            };

            let saveTimeout;
            const debouncedAutoSave = () => {
                clearTimeout(saveTimeout);
                saveTimeout = setTimeout(() => {
                    saveDataToCookie();
                    updateSaveStatus('Auto-saved', true, 2000);
                }, 1500);
            };

            const loadFile = () => {
                 if (isDirty && !confirm('You have unsaved changes that will be lost. Are you sure you want to import a new file?')) {
                    return;
                }
                fileInput.click();
            };

            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const contents = e.target.result;
                        const state = JSON.parse(contents);

                        if (!state.data || !state.deletedItems) {
                            throw new Error("Invalid file structure. Required properties are missing.");
                        }

                        data = state.data;
                        deletedItems = state.deletedItems;
                        selectedClientId = state.selectedClientId || null;
                        selectedAppointmentId = state.selectedAppointmentId || null;

                        if (!data.archivedClients) {
                            data.archivedClients = [];
                        }

                        isDirty = false;
                        saveDataToCookie();

                        alert(`Imported ${file.name} successfully.`);
                        fullRender();
                    } catch (err) {
                        console.error('Failed to load file:', err);
                        alert(`Import failed! Invalid file.\n\nError: ${err.message}`);
                    } finally {
                        // Reset file input so the same file can be loaded again
                        fileInput.value = '';
                    }
                };
                reader.readAsText(file);
            });

            const eraseAllData = () => {
                const confirmationText = "DELETE ALL DATA";
                const userInput = prompt(`This action will permanently erase all client data from this browser. This cannot be undone.\n\nTo confirm, please type "${confirmationText}" in the box below.`);
                if (userInput === confirmationText) {
                    data = getInitialData();
                    deletedItems = { clients: [], appointments: [] };
                    selectedClientId = null;
                    selectedAppointmentId = null;
                    isDirty = false;
                    document.cookie = 'clientData=;path=/;max-age=0';
                    localStorage.removeItem('serverAddress');
                    localStorage.removeItem('apiKey');
                    localStorage.removeItem('columnSizes');
                    localStorage.removeItem('rowSizes');
                    alert('All data has been permanently erased. The page will now reload.');
                    window.location.reload();
                } else if (userInput !== null) {
                    alert('The text you entered did not match. No data has been erased.');
                }
            };

            // --- Event Listeners ---
            addClientBtn.addEventListener('click', addClient);
            sortClientsBtn.addEventListener('click', () => {
                data.clients.sort((a, b) => a.name.localeCompare(b.name));
                markDirty();
                renderClients();
            });
            addAppointmentBtn.addEventListener('click', addAppointment);
            exportBtn.addEventListener('click', exportFile);
            importBtn.addEventListener('click', loadFile);
            eraseAllBtn.addEventListener('click', eraseAllData);
            generateNoteBtn.addEventListener('click', generateSoapNote);
            connectApiBtn.addEventListener('click', connectToServer);
            manualSaveBtn.addEventListener('click', () => {
                saveDataToCookie();
                updateSaveStatus('Data saved!', true, 2000);
            });
            settingsBtn.addEventListener('click', () => settingsModal.classList.remove('hidden'));
            closeSettingsBtn.addEventListener('click', () => settingsModal.classList.add('hidden'));
            settingsModal.addEventListener('click', (e) => {
                if(e.target.id === 'settingsModal') {
                    settingsModal.classList.add('hidden');
                }
            });
            modelSelect.addEventListener('change', (e) => {
                selectedModel = e.target.value;
                fullRender();
            });

            startTimerBtn.addEventListener('click', () => {
                const appointment = findAppointment(findClient(selectedClientId), selectedAppointmentId);
                if (appointment) {
                    appointment.startTime = new Date().toISOString();
                    appointment.endTime = null; // Clear end time if starting again
                    markDirty();
                    renderSessionTimer(appointment);
                }
            });

            stopTimerBtn.addEventListener('click', () => {
                const appointment = findAppointment(findClient(selectedClientId), selectedAppointmentId);
                if (appointment && appointment.startTime) { // Can only stop if started
                    appointment.endTime = new Date().toISOString();
                    clearInterval(sessionTimerInterval);
                    markDirty();
                    renderSessionTimer(appointment);
                }
            });

            // --- Resizable Panels ---
            function saveColumnSizes() {
                const panels = ['panelClients', 'panelAppointments', 'panelSession', 'panelSoap'];
                const sizes = panels.map(id => document.getElementById(id).style.flexBasis);
                localStorage.setItem('columnSizes', JSON.stringify(sizes));
                const sessionInfoHeight = document.getElementById('sessionInfoWrapper').style.flexBasis;
                const notesHeight = document.getElementById('notesWrapper').style.flexBasis;
                localStorage.setItem('rowSizes', JSON.stringify({ sessionInfoHeight, notesHeight }));
            }

            function loadColumnSizes() {
                const sizes = JSON.parse(localStorage.getItem('columnSizes'));
                if (sizes && sizes.length === 4) {
                    ['panelClients', 'panelAppointments', 'panelSession', 'panelSoap'].forEach((id, index) => {
                        const panel = document.getElementById(id);
                        if (panel) panel.style.flexBasis = sizes[index];
                    });
                }
                const rowSizes = JSON.parse(localStorage.getItem('rowSizes'));
                if (rowSizes) {
                    const sessionWrapper = document.getElementById('sessionInfoWrapper');
                    const notesWrapper = document.getElementById('notesWrapper');
                    if (sessionWrapper) sessionWrapper.style.flexBasis = rowSizes.sessionInfoHeight;
                    if (notesWrapper) notesWrapper.style.flexBasis = rowSizes.notesHeight;
                }
            }

            function makeResizable(resizer, prev, next, direction = 'x') {
                let x = 0;
                let y = 0;
                let prevSize = 0;
                let nextSize = 0;
                let containerSize = 0;

                resizer.addEventListener('mousedown', function (e) {
                    e.preventDefault();
                    if (direction === 'x') {
                        x = e.clientX;
                        prevSize = prev.getBoundingClientRect().width;
                        nextSize = next.getBoundingClientRect().width;
                        containerSize = prev.parentElement.getBoundingClientRect().width;
                    } else {
                        y = e.clientY;
                        prevSize = prev.getBoundingClientRect().height;
                        nextSize = next.getBoundingClientRect().height;
                        containerSize = prev.parentElement.getBoundingClientRect().height;
                    }
                    
                    document.body.style.cursor = direction === 'x' ? 'col-resize' : 'row-resize';
                    document.body.style.userSelect = 'none';

                    document.addEventListener('mousemove', mousemove);
                    document.addEventListener('mouseup', mouseup);
                });

                function mousemove(e) {
                    if (direction === 'x') {
                        const dx = e.clientX - x;
                        const newPrevSize = prevSize + dx;
                        const newNextSize = nextSize - dx;
                        
                        if(newPrevSize > 150 && newNextSize > 150) {
                            prev.style.flexBasis = `${(newPrevSize / containerSize) * 100}%`;
                            next.style.flexBasis = `${(newNextSize / containerSize) * 100}%`;
                        }
                    } else {
                        const dy = e.clientY - y;
                        const newPrevSize = prevSize + dy;
                        const newNextSize = nextSize - dy;

                        if(newPrevSize > 100 && newNextSize > 100) {
                            prev.style.flexBasis = `${(newPrevSize / containerSize) * 100}%`;
                            next.style.flexBasis = `${(newNextSize / containerSize) * 100}%`;
                        }
                    }
                }

                function mouseup() {
                    document.removeEventListener('mousemove', mousemove);
                    document.removeEventListener('mouseup', mouseup);
                    document.body.style.cursor = 'default';
                    document.body.style.userSelect = 'auto';
                    saveColumnSizes();
                }
            }
            
            // --- Initial Load & Render ---
            const loadServerSettings = () => {
                const savedAddress = localStorage.getItem('serverAddress');
                const savedApiKey = localStorage.getItem('apiKey');
                if (savedAddress) {
                    serverAddressInput.value = savedAddress;
                    if(savedApiKey) apiKeyInput.value = savedApiKey;
                    connectToServer();
                }
            };
            
            appointmentDateInput.value = new Date().toISOString().split('T')[0];
            loadServerSettings();
            loadDataFromCookie();
            loadColumnSizes();
            fullRender();
            
            makeResizable(document.getElementById('resizer1'), document.getElementById('panelClients'), document.getElementById('panelAppointments'));
            makeResizable(document.getElementById('resizer2'), document.getElementById('panelAppointments'), document.getElementById('panelSession'));
            makeResizable(document.getElementById('resizer3'), document.getElementById('panelSession'), document.getElementById('panelSoap'));
            makeResizable(document.getElementById('resizer-session-notes'), document.getElementById('sessionInfoWrapper'), document.getElementById('notesWrapper'), 'y');

        });
    </script>
</body>
</html>

