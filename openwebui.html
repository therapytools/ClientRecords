<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Powered Client Data Organizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        /* Custom scrollbar for a cleaner look */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #c7c7c7;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }
        .panel {
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            display: flex;
            flex-direction: column;
            height: calc(100vh - 8rem);
            min-width: 150px; /* Prevent panels from becoming too small */
        }
        .list-item {
            cursor: pointer;
            transition: background-color 0.2s;
            border-right: 4px solid transparent;
        }
        .list-item.selected {
            background-color: #e0f2fe;
            border-color: #38bdf8;
            font-weight: 600;
        }
        .list-item:hover {
            background-color: #f0f9ff;
        }
        textarea {
            resize: none;
        }
        .btn {
            transition: background-color 0.2s, transform 0.1s;
        }
        .btn:hover {
            transform: translateY(-1px);
        }
         .btn:disabled {
            background-color: #d1d5db;
            cursor: not-allowed;
            transform: none;
        }
        .btn-primary {
            background-color: #38bdf8;
            color: white;
        }
        .btn-primary:hover:not(:disabled) {
            background-color: #0ea5e9;
        }
        .btn-secondary {
            background-color: #e5e7eb;
            color: #374151;
        }
        .btn-secondary:hover {
            background-color: #d1d5db;
        }
        .btn-danger {
             background-color: #fee2e2;
             color: #ef4444;
        }
        .btn-danger:hover {
            background-color: #fecaca;
            color: #dc2626;
        }
        .resizer {
            background: #e5e7eb;
            cursor: col-resize;
            width: 6px;
            z-index: 10;
        }
        .resizer-y {
            background: #e5e7eb;
            cursor: row-resize;
            height: 6px;
            z-index: 10;
        }
    </style>
</head>
<body class="p-4 md:p-6 lg:p-8">
    <div id="app" class="flex flex-col h-full">
        <!-- Header -->
        <header class="flex flex-wrap items-center justify-between mb-6 pb-4 border-b">
            <h1 class="text-3xl font-bold text-gray-800">Client Data Organizer</h1>
            <div class="flex items-center space-x-4 mt-4 sm:mt-0">
                <div id="autoSaveIndicator" class="text-sm text-gray-500 hidden">
                    <span id="saveStatus"></span>
                </div>
                <button id="manualSaveBtn" class="btn btn-secondary font-semibold py-2 px-4 rounded-lg shadow-sm">Save Now</button>
                <button id="settingsBtn" class="btn btn-secondary font-semibold py-2 px-4 rounded-lg shadow-sm">Settings</button>
            </div>
        </header>

        <!-- Main Content Grid -->
        <main class="flex flex-col md:flex-row flex-grow gap-6" id="mainGrid">
            <!-- Panel 1: Clients -->
            <div class="panel flex flex-col" id="panelClients" style="flex-basis: 16.66%;">
                <h2 class="text-xl font-semibold text-gray-700 p-4 border-b">Clients</h2>
                <div id="clientList" class="flex-grow overflow-y-auto"></div>
                <div class="p-4 border-t">
                    <input type="text" id="newClientInput" class="w-full border border-gray-300 rounded-md px-3 py-2 mb-2 focus:outline-none focus:ring-2 focus:ring-sky-400" placeholder="New client name...">
                    <button id="addClientBtn" class="w-full btn btn-primary font-semibold py-2 rounded-lg">Add Client</button>
                </div>
                <div class="p-4 border-t">
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="font-semibold text-gray-600">Recently Deleted</h3>
                        <button id="clearDeletedClientsBtn" class="btn btn-danger text-xs px-2 py-1 rounded-md">Clear</button>
                    </div>
                    <div id="deletedClientsList" class="text-sm text-gray-500 max-h-24 overflow-y-auto"></div>
                </div>
                <div class="p-4 border-t">
                    <h3 class="font-semibold text-gray-600 mb-2">Archived Clients</h3>
                    <div id="archivedClientsList" class="text-sm text-gray-500 max-h-24 overflow-y-auto"></div>
                </div>
            </div>

            <div class="resizer" id="resizer1"></div>

            <!-- Panel 2: Appointments -->
            <div class="panel flex flex-col" id="panelAppointments" style="flex-basis: 16.66%;">
                <h2 class="text-xl font-semibold text-gray-700 p-4 border-b">Appointments</h2>
                <div id="appointmentList" class="flex-grow overflow-y-auto"></div>
                <div class="p-4 border-t">
                    <label for="appointmentDate" class="font-semibold text-gray-600 text-sm mb-1">Appointment Date</label>
                    <input type="date" id="appointmentDate" class="w-full border border-gray-300 rounded-md px-3 py-2 mb-2 focus:outline-none focus:ring-2 focus:ring-sky-400">
                    <button id="addAppointmentBtn" class="w-full btn btn-primary font-semibold py-2 rounded-lg mb-4" disabled>Add Appointment</button>
                    <div class="flex justify-between items-center mb-2 mt-4">
                        <h3 class="font-semibold text-gray-600">Recently Deleted</h3>
                        <button id="clearDeletedAppointmentsBtn" class="btn btn-danger text-xs px-2 py-1 rounded-md">Clear</button>
                    </div>
                    <div id="deletedAppointmentsList" class="text-sm text-gray-500 max-h-24 overflow-y-auto"></div>
                </div>
            </div>

            <div class="resizer" id="resizer2"></div>

            <!-- Panel 3: Session Information & Notes -->
            <div class="panel flex flex-col" id="panelSession" style="flex-basis: 33.33%;">
                <div class="flex flex-col h-full">
                    <div id="sessionInfoWrapper" class="flex flex-col" style="flex-basis: 50%;">
                         <div class="flex justify-between items-center p-4 border-b">
                            <h2 class="text-xl font-semibold text-gray-700">Session Information</h2>
                            <button id="generateNoteBtn" class="btn btn-primary font-semibold py-1 px-3 rounded-lg text-sm" disabled>Generate Note</button>
                        </div>
                        <div class="p-4 flex-grow">
                            <textarea id="sessionInfo" class="w-full h-full border border-gray-300 rounded-md p-3 focus:outline-none focus:ring-2 focus:ring-sky-400" placeholder="Enter session details here..." disabled style="resize: vertical;"></textarea>
                        </div>
                    </div>
                    <div class="resizer-y" id="resizer-session-notes"></div>
                    <div id="notesWrapper" class="flex flex-col" style="flex-basis: 50%;">
                         <h2 class="text-xl font-semibold text-gray-700 p-4 border-b border-t">Persistent Notes</h2>
                        <div class="p-4 flex-grow">
                            <textarea id="persistentNotes" class="w-full h-full border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-sky-400" placeholder="Notes to reference across multiple sessions..." disabled style="resize: vertical;"></textarea>
                        </div>
                    </div>
                </div>
            </div>

            <div class="resizer" id="resizer3"></div>

            <!-- Panel 4: SOAP Note -->
            <div class="panel flex flex-col" id="panelSoap" style="flex-basis: 33.33%;">
                <h2 class="text-xl font-semibold text-gray-700 p-4 border-b">SOAP Note</h2>
                <div class="p-4 flex-grow overflow-y-auto space-y-4">
                    <!-- Subjective -->
                    <div>
                        <div class="flex justify-between items-center mb-1">
                            <label for="soapS" class="font-semibold text-gray-600">S (Subjective)</label>
                            <button class="btn-copy btn btn-secondary text-xs px-2 py-1 rounded-md" data-target="soapS">Copy</button>
                        </div>
                        <textarea id="soapS" class="soap-input w-full h-28 border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-sky-400" placeholder="â€¢ " disabled></textarea>
                    </div>
                    <!-- Objective -->
                    <div>
                        <div class="flex justify-between items-center mb-1">
                            <label for="soapO" class="font-semibold text-gray-600">O (Objective)</label>
                            <button class="btn-copy btn btn-secondary text-xs px-2 py-1 rounded-md" data-target="soapO">Copy</button>
                        </div>
                        <textarea id="soapO" class="soap-input w-full h-28 border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-sky-400" placeholder="â€¢ " disabled></textarea>
                    </div>
                    <!-- Assessment -->
                    <div>
                        <div class="flex justify-between items-center mb-1">
                            <label for="soapA" class="font-semibold text-gray-600">A (Assessment)</label>
                            <button class="btn-copy btn btn-secondary text-xs px-2 py-1 rounded-md" data-target="soapA">Copy</button>
                        </div>
                        <textarea id="soapA" class="soap-input w-full h-28 border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-sky-400" placeholder="â€¢ " disabled></textarea>
                    </div>
                    <!-- Plan -->
                    <div>
                        <div class="flex justify-between items-center mb-1">
                            <label for="soapP" class="font-semibold text-gray-600">P (Plan)</label>
                            <button class="btn-copy btn btn-secondary text-xs px-2 py-1 rounded-md" data-target="soapP">Copy</button>
                        </div>
                        <textarea id="soapP" class="soap-input w-full h-28 border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-sky-400" placeholder="â€¢ " disabled></textarea>
                    </div>
                </div>
            </div>
        </main>
                <!-- Message Box for copy confirmation -->
        <div id="messageBox" class="fixed bottom-5 right-5 bg-gray-800 text-white py-2 px-4 rounded-lg shadow-lg opacity-0 transition-opacity duration-300">
            Copied to clipboard!
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div id="settingsModal" class="fixed inset-0 z-50 flex items-center justify-center hidden">
        <div id="modalOverlay" class="absolute inset-0 bg-black opacity-50"></div>
        <div class="relative bg-white rounded-lg shadow-xl p-6 w-full max-w-lg mx-4">
            <div class="flex justify-between items-center mb-4 pb-4 border-b">
                <h2 class="text-2xl font-bold text-gray-800">Settings</h2>
                <button id="closeSettingsBtn" class="text-gray-500 hover:text-gray-800 text-3xl">&times;</button>
            </div>

            <!-- Connection Settings -->
            <div class="mb-6">
                <h3 class="text-xl font-semibold text-gray-700 mb-3">Connection</h3>
                <div class="space-y-4">
                    <div class="flex flex-col">
                        <label for="serverAddressInput" class="mb-1 font-semibold text-gray-600">Open WebUI Address</label>
                        <input type="text" id="serverAddressInput" class="border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-400" placeholder="e.g., http://localhost:3000">
                    </div>
                    <div class="flex flex-col">
                        <label for="apiKeyInput" class="mb-1 font-semibold text-gray-600">API Key (optional)</label>
                        <input type="password" id="apiKeyInput" class="border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-400">
                    </div>
                    <div class="flex items-center space-x-4">
                        <button id="connectApiBtn" class="btn btn-primary font-semibold py-2 px-4 rounded-lg shadow-sm text-sm">Connect</button>
                        <span id="apiStatus" class="text-sm font-semibold"></span>
                    </div>
                    <div class="flex flex-col">
                         <label for="modelSelect" class="mb-1 font-semibold text-gray-600">AI Model</label>
                         <select id="modelSelect" class="border border-gray-300 rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-400" disabled>
                            <option>Connect to server first</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Data Management -->
            <div>
                <h3 class="text-xl font-semibold text-gray-700 mb-3">Data Management</h3>
                <div class="flex flex-wrap gap-4">
                     <button id="exportBtn" class="btn btn-primary font-semibold py-2 px-4 rounded-lg shadow-sm">Export Data</button>
                     <button id="loadBtn" class="btn btn-secondary font-semibold py-2 px-4 rounded-lg shadow-sm">Import Data</button>
                     <button id="eraseAllBtn" class="btn btn-danger font-semibold py-2 px-4 rounded-lg shadow-sm">Erase All Data</button>
                </div>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const clientListEl = document.getElementById('clientList');
            const newClientInput = document.getElementById('newClientInput');
            const addClientBtn = document.getElementById('addClientBtn');
            const appointmentListEl = document.getElementById('appointmentList');
            const addAppointmentBtn = document.getElementById('addAppointmentBtn');
            const appointmentDateEl = document.getElementById('appointmentDate');
            const deletedClientsListEl = document.getElementById('deletedClientsList');
            const clearDeletedClientsBtn = document.getElementById('clearDeletedClientsBtn');
            const archivedClientsListEl = document.getElementById('archivedClientsList');
            const deletedAppointmentsListEl = document.getElementById('deletedAppointmentsList');
            const clearDeletedAppointmentsBtn = document.getElementById('clearDeletedAppointmentsBtn');
            const persistentNotesEl = document.getElementById('persistentNotes');
            const sessionInfoEl = document.getElementById('sessionInfo');
            const soapSEl = document.getElementById('soapS');
            const soapOEl = document.getElementById('soapO');
            const soapAEl = document.getElementById('soapA');
            const soapPEl = document.getElementById('soapP');
            const autoSaveIndicator = document.getElementById('autoSaveIndicator');
            const saveStatus = document.getElementById('saveStatus');
            // Settings and Modal Elements
            const settingsBtn = document.getElementById('settingsBtn');
            const settingsModal = document.getElementById('settingsModal');
            const modalOverlay = document.getElementById('modalOverlay');
            const closeSettingsBtn = document.getElementById('closeSettingsBtn');
            const manualSaveBtn = document.getElementById('manualSaveBtn');
            const exportBtn = document.getElementById('exportBtn');
            const loadBtn = document.getElementById('loadBtn');
            const eraseAllBtn = document.getElementById('eraseAllBtn');
            // AI Integration Elements
            const serverAddressInput = document.getElementById('serverAddressInput');
            const apiKeyInput = document.getElementById('apiKeyInput');
            const connectApiBtn = document.getElementById('connectApiBtn');
            const apiStatus = document.getElementById('apiStatus');
            const modelSelect = document.getElementById('modelSelect');
            const generateNoteBtn = document.getElementById('generateNoteBtn');

            // App State
            let data = { clients: [], archivedClients: [] };
            let deletedItems = { clients: [], appointments: [] };
            let selectedClientId = null;
            let selectedAppointmentId = null;
            let isDirty = false; // Flag to check if there are unsaved changes
            let serverAddress = null;
            let apiKey = null;
            let selectedModel = null;
            const getInitialData = () => ({ clients: [], archivedClients: [] });

            // --- Data Management ---
            const findClient = id => data.clients.find(c => c.id === id) || data.archivedClients.find(c => c.id === id);
            const findAppointment = (client, id) => client?.appointments.find(a => a.id === id);

            // --- UI Rendering ---
            const renderClients = () => {
                clientListEl.innerHTML = '';
                if (data.clients.length === 0) {
                     clientListEl.innerHTML = '<p class="p-4 text-sm text-gray-500">No active clients.</p>';
                }
                data.clients.sort((a, b) => a.name.localeCompare(b.name));
                data.clients.forEach(client => {
                    const div = document.createElement('div');
                    div.className = `list-item flex justify-between items-center p-3 border-b ${client.id === selectedClientId ? 'selected' : ''}`;
                    div.dataset.id = client.id;
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = client.name;
                    nameSpan.className = 'truncate flex-grow cursor-pointer';
                    div.appendChild(nameSpan);

                    const btnGroup = document.createElement('div');
                    btnGroup.className = 'flex items-center space-x-2 ml-2';
                    const archiveBtn = document.createElement('button');
                    archiveBtn.textContent = 'Archive';
                    archiveBtn.title = 'Archive Client';
                    archiveBtn.className = 'btn btn-secondary text-xs px-2 py-1 rounded-md';
                    archiveBtn.onclick = (e) => {
                        e.stopPropagation();
                        archiveClient(client.id);
                    };
                    btnGroup.appendChild(archiveBtn);

                    const removeBtn = document.createElement('button');
                    removeBtn.innerHTML = '&times;';
                    removeBtn.title = 'Delete Client';
                    removeBtn.className = 'font-bold text-red-500 hover:text-red-700 text-xl px-1 rounded-full w-6 h-6 flex items-center justify-center';
                    removeBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (confirm(`Are you sure you want to delete ${client.name}? You can restore this client later.`)) {
                            removeClient(client.id);
                        }
                    };
                    btnGroup.appendChild(removeBtn);
                    div.appendChild(btnGroup);
                    div.onclick = () => selectClient(client.id);
                    clientListEl.appendChild(div);
                });
            };

            const renderAppointments = () => {
                const client = findClient(selectedClientId);
                appointmentListEl.innerHTML = '';
                if (!client) {
                    appointmentListEl.innerHTML = '<p class="p-4 text-sm text-gray-500">Select a client to see appointments.</p>';
                    return;
                }
                if (!client.appointments || client.appointments.length === 0) {
                    appointmentListEl.innerHTML = '<p class="p-4 text-sm text-gray-500">No appointments yet.</p>';
                    return;
                }
                client.appointments.sort((a, b) => new Date(b.date) - new Date(a.date));
                client.appointments.forEach(appt => {
                    const div = document.createElement('div');
                    div.className = `list-item flex justify-between items-center p-3 border-b ${appt.id === selectedAppointmentId ? 'selected' : ''}`;
                    div.dataset.id = appt.id;

                    const span = document.createElement('span');
                    span.textContent = new Date(appt.date).toLocaleDateString();
                    span.className = 'flex-grow cursor-pointer';
                    div.appendChild(span);

                    const removeBtn = document.createElement('button');
                    removeBtn.innerHTML = '&times;';
                    removeBtn.title = 'Delete Appointment';
                    removeBtn.className = 'font-bold text-red-500 hover:text-red-700 text-xl px-1 rounded-full w-6 h-6 flex items-center justify-center';
                    removeBtn.onclick = (e) => {
                        e.stopPropagation();
                         if (confirm(`Are you sure you want to delete the appointment on ${new Date(appt.date).toLocaleDateString()}? You can restore it later.`)) {
                            removeAppointment(appt.id);
                        }
                    };
                    div.appendChild(removeBtn);
                    div.onclick = () => selectAppointment(appt.id);
                    appointmentListEl.appendChild(div);
                });
            };

            const renderDetails = () => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);

                // Enable/disable inputs
                persistentNotesEl.disabled = !client;
                sessionInfoEl.disabled = !appointment;
                [soapSEl, soapOEl, soapAEl, soapPEl].forEach(el => el.disabled = !appointment);
                addAppointmentBtn.disabled = !client;
                generateNoteBtn.disabled = !appointment || !selectedModel || !sessionInfoEl.value.trim();

                // Populate data
                persistentNotesEl.value = client ? (client.persistentNotes || '') : '';
                sessionInfoEl.value = appointment ? (appointment.sessionInfo || '') : '';
                soapSEl.value = appointment ? (appointment.soap?.s || '') : '';
                soapOEl.value = appointment ? (appointment.soap?.o || '') : '';
                soapAEl.value = appointment ? (appointment.soap?.a || '') : '';
                soapPEl.value = appointment ? (appointment.soap?.p || '') : '';
            };

            const renderDeletedLists = () => {
                deletedClientsListEl.innerHTML = '';
                if (deletedItems.clients.length === 0) {
                    deletedClientsListEl.innerHTML = '<p class="text-xs text-gray-400">None</p>';
                }
                deletedItems.clients.forEach(client => {
                    const div = document.createElement('div');
                    div.className = 'flex justify-between items-center text-xs py-1';
                    div.innerHTML = `<span>${client.name}</span>`;
                    const btn = document.createElement('button');
                    btn.textContent = 'Restore';
                    btn.className = 'btn btn-secondary text-xs px-1 py-0.5 rounded';
                    btn.onclick = () => restoreClient(client.id);
                    div.appendChild(btn);
                    deletedClientsListEl.appendChild(div);
                });

                deletedAppointmentsListEl.innerHTML = '';
                if (deletedItems.appointments.length === 0) {
                    deletedAppointmentsListEl.innerHTML = '<p class="text-xs text-gray-400">None</p>';
                }
                deletedItems.appointments.forEach(appt => {
                    const div = document.createElement('div');
                    div.className = 'flex justify-between items-center text-xs py-1';
                    const clientName = findClient(appt.clientId)?.name || 'Unknown';
                    div.innerHTML = `<span>${new Date(appt.date).toLocaleDateString()} (${clientName})</span>`;
                    const btn = document.createElement('button');
                    btn.textContent = 'Restore';
                    btn.className = 'btn btn-secondary text-xs px-1 py-0.5 rounded';
                    btn.onclick = () => restoreAppointment(appt.id);
                    div.appendChild(btn);
                    deletedAppointmentsListEl.appendChild(div);
                });
            };

            const renderArchivedClients = () => {
                archivedClientsListEl.innerHTML = '';
                if (!data.archivedClients || data.archivedClients.length === 0) {
                    archivedClientsListEl.innerHTML = '<p class="text-xs text-gray-400">None</p>';
                    return;
                }
                data.archivedClients.sort((a, b) => a.name.localeCompare(b.name));
                data.archivedClients.forEach(client => {
                    const div = document.createElement('div');
                    div.className = 'flex justify-between items-center text-xs py-1';
                    div.innerHTML = `<span>${client.name}</span>`;
                    const btn = document.createElement('button');
                    btn.textContent = 'Unarchive';
                    btn.className = 'btn btn-secondary text-xs px-1 py-0.5 rounded';
                    btn.onclick = () => unarchiveClient(client.id);
                    div.appendChild(btn);
                    archivedClientsListEl.appendChild(div);
                });
            };

            const fullRender = () => {
                renderClients();
                renderAppointments();
                renderDetails();
                renderDeletedLists();
                renderArchivedClients();
            };

            // --- Event Handlers & Actions ---
            const selectClient = (id) => {
                selectedClientId = id;
                selectedAppointmentId = null; 
                markDirty();
                fullRender();
            };

            const selectAppointment = (id) => {
                selectedAppointmentId = id;
                markDirty();
                fullRender();
            };

            const addClient = () => {
                const name = newClientInput.value.trim();
                if (!name) return;
                const newClient = {
                    id: crypto.randomUUID(),
                    name,
                    persistentNotes: '',
                    appointments: []
                };
                data.clients.push(newClient);
                newClientInput.value = '';
                selectClient(newClient.id);
                markDirty();
            };

            const removeClient = (id) => {
                const clientIndex = data.clients.findIndex(c => c.id === id);
                if (clientIndex === -1) return;
                const [client] = data.clients.splice(clientIndex, 1);
                if (client.appointments) {
                    client.appointments.forEach(appt => {
                        deletedItems.appointments.push({ ...appt, clientId: client.id });
                    });
                }
                deletedItems.clients.push(client);
                if (selectedClientId === id) {
                    selectedClientId = null;
                    selectedAppointmentId = null;
                }
                fullRender();
                markDirty();
            };

            const restoreClient = (id) => {
                const clientIndex = deletedItems.clients.findIndex(c => c.id === id);
                if (clientIndex === -1) return;
                const [client] = deletedItems.clients.splice(clientIndex, 1);
                const appointmentsToRestore = deletedItems.appointments.filter(a => a.clientId === id);
                client.appointments = client.appointments || [];
                client.appointments.push(...appointmentsToRestore);
                deletedItems.appointments = deletedItems.appointments.filter(a => a.clientId !== id);
                data.clients.push(client);
                fullRender();
                markDirty();
            };

            const archiveClient = (id) => {
                const clientIndex = data.clients.findIndex(c => c.id === id);
                if (clientIndex === -1) return;
                const [client] = data.clients.splice(clientIndex, 1);
                if (!data.archivedClients) data.archivedClients = [];
                data.archivedClients.push(client);
                if (selectedClientId === id) {
                    selectedClientId = null;
                    selectedAppointmentId = null;
                }
                fullRender();
                markDirty();
            };

            const unarchiveClient = (id) => {
                if (!data.archivedClients) return;
                const clientIndex = data.archivedClients.findIndex(c => c.id === id);
                if (clientIndex === -1) return;
                const [client] = data.archivedClients.splice(clientIndex, 1);
                data.clients.push(client);
                fullRender();
                markDirty();
            };

            const addAppointment = () => {
                const client = findClient(selectedClientId);
                if (!client || !appointmentDateEl.value) {
                    alert('Please select a client and a date to add an appointment.');
                    return;
                }
                const newAppointment = {
                    id: crypto.randomUUID(),
                    date: new Date(appointmentDateEl.value).toISOString(),
                    sessionInfo: '',
                    soap: { s: 'â€¢ ', o: 'â€¢ ', a: 'â€¢ ', p: 'â€¢ ' }
                };
                if (!client.appointments) client.appointments = [];
                client.appointments.push(newAppointment);
                selectAppointment(newAppointment.id);
                markDirty();
            };

            const removeAppointment = (id) => {
                const client = findClient(selectedClientId);
                if (!client || !client.appointments) return;
                const apptIndex = client.appointments.findIndex(a => a.id === id);
                if (apptIndex === -1) return;
                const [appt] = client.appointments.splice(apptIndex, 1);
                deletedItems.appointments.push({ ...appt, clientId: client.id });
                 if (selectedAppointmentId === id) {
                    selectedAppointmentId = null;
                }
                fullRender();
                markDirty();
            };

            const restoreAppointment = (id) => {
                const apptIndex = deletedItems.appointments.findIndex(a => a.id === id);
                if (apptIndex === -1) return;
                const [appt] = deletedItems.appointments.splice(apptIndex, 1);
                const client = findClient(appt.clientId);
                if (client) {
                    if (!client.appointments) client.appointments = [];
                    client.appointments.push(appt);
                    fullRender();
                    markDirty();
                } else {
                    deletedItems.appointments.push(appt);
                    alert('Cannot restore appointment because its client could not be found. Restore the client first.');
                }
            };

            const handleSoapKeydown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const target = e.target;
                    const start = target.selectionStart;
                    const end = target.selectionEnd;
                    const text = target.value;
                    target.value = text.substring(0, start) + '\nâ€¢ ' + text.substring(end);
                    target.selectionStart = target.selectionEnd = start + 3;
                    markDirty();
                }
            };
            [soapSEl, soapOEl, soapAEl, soapPEl].forEach(el => {
                el.addEventListener('keydown', handleSoapKeydown);
            });

            // --- AI SOAP Note Generation (Open WebUI) ---
            const connectToServer = async () => {
                const address = serverAddressInput.value.trim();
                if (!address) {
                    alert('Please enter an Open WebUI address.');
                    return;
                }
                serverAddress = address.endsWith('/') ? address.slice(0, -1) : address;
                apiKey = apiKeyInput.value.trim();

                apiStatus.textContent = 'Connecting...';
                apiStatus.style.color = 'orange';
                modelSelect.innerHTML = '<option>Loading models...</option>';
                modelSelect.disabled = true;

                try {
                    const headers = new Headers();
                    if (apiKey) {
                        headers.append('Authorization', `Bearer ${apiKey}`);
                    }
                    const response = await fetch(`${serverAddress}/api/v1/models`, { headers });
                    if (!response.ok) {
                        const error = new Error(`Failed to connect to Open WebUI. Status: ${response.status}`);
                        error.response = response;
                        throw error;
                    }
                    const data = await response.json();
                    
                    apiStatus.textContent = 'Connected';
                    apiStatus.style.color = 'green';
                    
                    localStorage.setItem('serverAddress', serverAddress);
                    if (apiKey) localStorage.setItem('apiKey', apiKey);
                    else localStorage.removeItem('apiKey');
                    
                    modelSelect.innerHTML = '';
                    const models = data.data;

                    if (models && models.length > 0) {
                        models.forEach(model => {
                            const option = document.createElement('option');
                            option.value = model.id;
                            option.textContent = model.id;
                            modelSelect.appendChild(option);
                        });

                        let autoSelectedModelId = null;
                        const deepseekModel = models.find(m => m.id === 'deepseek-r1:1.5b');

                        if (deepseekModel) {
                            autoSelectedModelId = deepseekModel.id;
                        } else {
                            const fallbackModel = models.find(m => 
                                m.id !== 'arena-model' && 
                                !m.id.toLowerCase().includes('coder') && 
                                !m.id.toLowerCase().includes('coding')
                            );
                            if (fallbackModel) {
                                autoSelectedModelId = fallbackModel.id;
                            }
                        }

                        if (autoSelectedModelId) {
                            modelSelect.value = autoSelectedModelId;
                        } else if (models.length > 0) {
                            // If no preferred model found, just default to the first in the list
                            modelSelect.value = models[0].id;
                        }

                        selectedModel = modelSelect.value;
                        modelSelect.disabled = false;
                        
                    } else {
                        modelSelect.innerHTML = '<option>No models found</option>';
                        selectedModel = null;
                        modelSelect.disabled = true;
                    }

                } catch (error) {
                    console.error('API connection error:', error);
                    apiStatus.textContent = 'Failed';
                    apiStatus.style.color = 'red';
                    serverAddress = null;
                    modelSelect.innerHTML = '<option>Connection failed</option>';
                    
                    let alertMessage = `Connection to "${address}" failed.`;
                    
                    if (error.response?.status === 401) {
                         alertMessage += `\n\nError: Authentication failed (401 Unauthorized). Please check if your API Key is correct and has the necessary permissions. Some servers require an API key even if it's optional in the UI.`;
                    } else if (error instanceof TypeError && error.message.toLowerCase().includes('failed to fetch')) {
                        alertMessage = `Network Error: Failed to fetch.

This is the most common error and is almost always caused by one of two things:

1.  **CORS Policy:** Your browser is blocking the request for security reasons. The Open WebUI server must be configured to allow requests from this webpage.
    *SOLUTION:* In your Open WebUI settings, find the "Allowed Origins" configuration and add the URL of this page. You can often just add "*" to allow all origins, but this is less secure.

2.  **Server Not Reachable:** The address "${address}" is incorrect, or the Open WebUI server is not running. Please double-check the address and ensure the server is active.

This error cannot be fixed within this application's code; it requires a configuration change on the server you are trying to connect to.`;
                    } else {
                        alertMessage += `\n\nError: ${error.message}`;
                    }
                    alert(alertMessage);

                } finally {
                    fullRender();
                }
            };

            const generateSoapNote = async () => {
                if (!selectedModel) {
                    alert('Please connect to your server and select a model first.');
                    return;
                }

                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (!client || !appointment || !sessionInfoEl.value.trim()) {
                    alert('Please select a client and appointment, and enter some session information.');
                    return;
                }

                generateNoteBtn.disabled = true;
                generateNoteBtn.textContent = 'Generating...';

                const systemPrompt = `You are a helpful assistant for a therapist or clinician. Your task is to convert raw session notes into a structured SOAP note format. The user will provide "Persistent Notes" which contain background information about the client, and "Session Information" which contains the notes from the current session. Analyze both sets of notes and generate a SOAP note.

**Guidelines for each section:**
- **Subjective (S):** What the client reports. Direct quotes, feelings, goals, and history reported by the client.
- **Objective (O):** Observable facts. The clinician's observations of the client's affect, appearance, behavior, and body language.
- **Assessment (A):** The clinician's professional judgment and interpretation of the subjective and objective information. Diagnosis, progress towards goals, and clinical impressions.
- **Plan (P):** The course of action. Topics for the next session, homework, referrals, and treatment plan modifications.

**Important Constraints:**
- **Stick to the provided information:** Do NOT invent details that are not present in the "Session Information" or "Persistent Notes".
- **Do not add client statements:** Only include quotes or reported feelings if they are in the source text.
- **Do not assume presentation:** Do not make assumptions about the client's presentation (e.g., "appeared tired") unless it is explicitly documented.
- **Do not infer progress:** Do not add statements about progress unless it is specifically noted in the session information.
- It is acceptable to identify and detail therapeutic interventions if they are mentioned in the notes.

Your entire response must be a single, raw JSON object. Do not wrap it in markdown code fences or add any explanatory text. The JSON object must have exactly four keys: "s", "o", "a", and "p". Each key's value must be a string formatted with bullet points (â€¢) for each distinct point.`;

                const userPrompt = `
- **Client Name:** ${client.name}
- **Persistent Notes (Background):**
${persistentNotesEl.value || 'N/A'}

- **Session Information (This Session):**
${sessionInfoEl.value}
`;

                const payload = {
                    model: selectedModel,
                    messages: [
                        { "role": "system", "content": systemPrompt },
                        { "role": "user", "content": userPrompt }
                    ],
                    response_format: { "type": "json_object" },
                    stream: false
                };
                
                try {
                    const headers = new Headers({ 'Content-Type': 'application/json' });
                     if (apiKey) {
                        headers.append('Authorization', `Bearer ${apiKey}`);
                    }
                    const response = await fetch(`${serverAddress}/api/v1/chat/completions`, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        const error = new Error(`API error: ${response.status} - ${errorText}`);
                        error.response = response;
                        throw error;
                    }

                    const result = await response.json();
                    let content = result.choices[0].message.content;
                    
                    const jsonMatch = content.match(/{[\s\S]*}/);
                    if (!jsonMatch) {
                        throw new Error('AI response did not contain a valid JSON object.');
                    }
                    const jsonString = jsonMatch[0];
                    let soapData;

                    try {
                        soapData = JSON.parse(jsonString);
                    } catch (parseError) {
                        console.error("Failed to parse the following JSON string from the AI:", jsonString);
                        throw new Error(`The AI model returned malformed JSON. Check the browser console for the raw output that failed to parse. Details: ${parseError.message}`);
                    }

                    if (typeof soapData.s !== 'string' || typeof soapData.o !== 'string' || typeof soapData.a !== 'string' || typeof soapData.p !== 'string') {
                        console.error("Received valid JSON from AI, but it was missing required SOAP keys. Received object:", soapData);
                        throw new Error(`AI response was not in the expected JSON format (missing s, o, a, or p keys). The AI returned: ${JSON.stringify(soapData)}`);
                    }

                    // Update UI and data model
                    soapSEl.value = soapData.s;
                    soapOEl.value = soapData.o;
                    soapAEl.value = soapData.a;
                    soapPEl.value = soapData.p;

                    if (!appointment.soap) appointment.soap = {};
                    appointment.soap.s = soapData.s;
                    appointment.soap.o = soapData.o;
                    appointment.soap.a = soapData.a;
                    appointment.soap.p = soapData.p;
                    markDirty();

                } catch (error) {
                    console.error('SOAP Note Generation Error:', error);
                    let alertMessage = `Failed to generate SOAP note. Please check your connection and the console for details.\nError: ${error.message}`;
                     
                    if (error.response?.status === 401) {
                         alertMessage = `Authentication failed (401 Unauthorized) while trying to generate the note. Please re-check your API Key.`;
                    } else if (error instanceof TypeError && error.message.toLowerCase().includes('failed to fetch')) {
                        alertMessage = `Network Error: Failed to fetch.

This is the most common error and is almost always caused by one of two things:

1.  **CORS Policy:** Your browser is blocking the request for security reasons. The Open WebUI server must be configured to allow requests from this webpage.
    *SOLUTION:* In your Open WebUI settings, find the "Allowed Origins" configuration and add the URL of this page. You can often just add "*" to allow all origins, but this is less secure.

2.  **Server Not Reachable:** The address "${serverAddress}" is incorrect, or the Open WebUI server is not running. Please double-check the address and ensure the server is active.

This error cannot be fixed within this application's code; it requires a configuration change on the server you are trying to connect to.`;
                    }
                    alert(alertMessage);
                } finally {
                    generateNoteBtn.disabled = false;
                    generateNoteBtn.textContent = 'Generate Note';
                    renderDetails(); 
                }
            };


            // --- Data Persistence (Save/Load/AutoSave) ---
            const updateSaveStatus = (message, isGood = true, duration = 0) => {
                autoSaveIndicator.classList.remove('hidden');
                saveStatus.textContent = message;
                saveStatus.style.color = isGood ? 'green' : 'red';
                if (duration > 0) {
                    setTimeout(() => {
                         if (saveStatus.textContent === message) {
                            autoSaveIndicator.classList.add('hidden');
                         }
                    }, duration);
                }
            }

            const markDirty = () => {
                if (!isDirty) {
                    isDirty = true;
                    updateSaveStatus('Unsaved changes...', false);
                }
                debouncedAutoSave();
            };

            const saveDataToCookie = () => {
                try {
                    const state = { data, deletedItems, selectedClientId, selectedAppointmentId };
                    document.cookie = `clientData=${encodeURIComponent(JSON.stringify(state))};path=/;max-age=31536000;samesite=strict`;
                    isDirty = false;
                } catch (e) {
                    console.error("Failed to save to cookie", e);
                    updateSaveStatus('Cookie save failed!', false, 3000);
                }
            };

            const loadDataFromCookie = () => {
                const cookie = document.cookie.split('; ').find(row => row.startsWith('clientData='));
                if (cookie) {
                    try {
                        const state = JSON.parse(decodeURIComponent(cookie.split('=')[1]));
                        data = state.data || getInitialData();
                        if (!data.archivedClients) data.archivedClients = [];
                        deletedItems = state.deletedItems || { clients: [], appointments: [] };
                        selectedClientId = state.selectedClientId || null;
                        selectedAppointmentId = state.selectedAppointmentId || null;
                        updateSaveStatus('Loaded from cookie', true, 2000);
                    } catch (e) {
                        console.error("Failed to load from cookie", e);
                        data = getInitialData();
                        deletedItems = { clients: [], appointments: [] };
                    }
                }
            };

            const exportFile = async () => {
                try {
                    // First, ensure the latest state is saved to the cookie
                    saveDataToCookie();
                    updateSaveStatus('Saved.', true, 2000);
                                         
                    const cookie = document.cookie.split('; ').find(row => row.startsWith('clientData='));
                    if (!cookie) {
                        updateSaveStatus('Nothing to export!', false, 3000);
                        return;
                    }
                    const stateJSON = decodeURIComponent(cookie.split('=')[1]);
                                        
                    const blob = new Blob([stateJSON], { type: 'application/json' });
                    const handle = await window.showSaveFilePicker({
                        suggestedName: `client-data-${new Date().toISOString().split('T')[0]}.json`,
                        types: [{ description: 'JSON Files', accept: { 'application/json': ['.json'] } }]
                    });
                    const writable = await handle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    updateSaveStatus('Exported successfully!', true, 3000);
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        console.error('Failed to export file:', err);
                        updateSaveStatus('Export failed!', false, 3000);
                    }
                }
            };

            let saveTimeout;
            const debouncedAutoSave = () => {
                clearTimeout(saveTimeout);
                saveTimeout = setTimeout(() => {
                    saveDataToCookie();
                    if (!isDirty) {
                       updateSaveStatus('Auto-saved', true, 2000);
                    }
                }, 1500);
            };

            const loadFile = async () => {
                 if (isDirty && !confirm('You have unsaved changes that will be lost. Are you sure you want to import a new file?')) {
                    return;
                }
                try {
                    const [handle] = await window.showOpenFilePicker({
                        types: [{ description: 'JSON Files', accept: { 'application/json': ['.json'] } }]
                    });
                    const file = await handle.getFile();
                    const contents = await file.text();
                    JSON.parse(contents); // Validate JSON
                    document.cookie = `clientData=${encodeURIComponent(contents)};path=/;max-age=31536000;samesite=strict`;
                    updateSaveStatus(`Imported ${file.name}. Reloading...`, true, 3000);
                    setTimeout(() => {
                        window.location.reload();
                    }, 1000);
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        console.error('Failed to load file:', err);
                        updateSaveStatus('Import failed! Invalid file.', false, 3000);
                    }
                }
            };

            const eraseAllData = () => {
                const confirmationText = "DELETE ALL DATA";
                const userInput = prompt(`This action will permanently erase all client data from this browser. This cannot be undone.\n\nTo confirm, please type "${confirmationText}" in the box below.`);
                if (userInput === confirmationText) {
                    data = getInitialData();
                    deletedItems = { clients: [], appointments: [] };
                    selectedClientId = null;
                    selectedAppointmentId = null;
                    isDirty = false;
                    document.cookie = 'clientData=;path=/;max-age=0';
                    localStorage.removeItem('columnSizes');
                    localStorage.removeItem('rowSizes');
                    localStorage.removeItem('serverAddress');
                    localStorage.removeItem('apiKey');
                    autoSaveIndicator.classList.add('hidden');
                    alert('All data has been permanently erased. The page will now reload.');
                    window.location.reload();
                } else if (userInput !== null) {
                    alert('The text you entered did not match. No data has been erased.');
                }
            };

            // --- Event Listeners ---
            addClientBtn.addEventListener('click', addClient);
            newClientInput.addEventListener('keyup', (e) => e.key === 'Enter' && addClient());
            addAppointmentBtn.addEventListener('click', addAppointment);
            exportBtn.addEventListener('click', exportFile);
            loadBtn.addEventListener('click', loadFile);
            eraseAllBtn.addEventListener('click', eraseAllData);
            generateNoteBtn.addEventListener('click', generateSoapNote);
            connectApiBtn.addEventListener('click', connectToServer);

            manualSaveBtn.addEventListener('click', () => {
                saveDataToCookie();
                updateSaveStatus('Data saved!', true, 2000);
            });

            settingsBtn.addEventListener('click', () => settingsModal.classList.remove('hidden'));
            closeSettingsBtn.addEventListener('click', () => settingsModal.classList.add('hidden'));
            modalOverlay.addEventListener('click', () => settingsModal.classList.add('hidden'));
            
            modelSelect.addEventListener('change', (e) => {
                selectedModel = e.target.value;
                fullRender();
            });

            clearDeletedClientsBtn.addEventListener('click', () => {
                if (deletedItems.clients.length > 0 && confirm('Are you sure you want to permanently delete all recently deleted clients? This cannot be undone.')) {
                    deletedItems.clients = [];
                    fullRender();
                    markDirty();
                }
            });
            clearDeletedAppointmentsBtn.addEventListener('click', () => {
                if (deletedItems.appointments.length > 0 && confirm('Are you sure you want to permanently delete all recently deleted appointments? This cannot be undone.')) {
                    deletedItems.appointments = [];
                    fullRender();
                    markDirty();
                }
            });

            persistentNotesEl.addEventListener('input', () => {
                const client = findClient(selectedClientId);
                if (client) {
                    client.persistentNotes = persistentNotesEl.value;
                    markDirty();
                }
            });
            sessionInfoEl.addEventListener('input', () => {
                const client = findClient(selectedClientId);
                const appointment = findAppointment(client, selectedAppointmentId);
                if (appointment) {
                    appointment.sessionInfo = sessionInfoEl.value;
                    markDirty();
                }
                renderDetails(); 
            });
            [soapSEl, soapOEl, soapAEl, soapPEl].forEach(el => {
                el.addEventListener('input', () => {
                    const client = findClient(selectedClientId);
                    const appointment = findAppointment(client, selectedAppointmentId);
                    if (appointment) {
                        const key = el.id.slice(-1).toLowerCase();
                        if (!appointment.soap) appointment.soap = {};
                        appointment.soap[key] = el.value;
                        markDirty();
                    }
                });
            });

            document.querySelectorAll('.btn-copy').forEach(button => {
                button.addEventListener('click', () => {
                    const targetId = button.dataset.target;
                    const textarea = document.getElementById(targetId);
                    if (textarea.disabled) return;
                    navigator.clipboard.writeText(textarea.value).then(() => {
                        const messageBox = document.getElementById('messageBox');
                        messageBox.classList.remove('opacity-0');
                        setTimeout(() => {
                            messageBox.classList.add('opacity-0');
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy text: ', err);
                    });
                });
            });

            // --- Resizable Panels ---
            const panels = ['panelClients', 'panelAppointments', 'panelSession', 'panelSoap'];
            function saveColumnSizes() {
                const sizes = panels.map(id => document.getElementById(id).style.flexBasis);
                localStorage.setItem('columnSizes', JSON.stringify(sizes));
                const sessionInfoHeight = document.getElementById('sessionInfoWrapper').style.flexBasis;
                const notesHeight = document.getElementById('notesWrapper').style.flexBasis;
                localStorage.setItem('rowSizes', JSON.stringify({ sessionInfoHeight, notesHeight }));
            }

            function loadColumnSizes() {
                const sizes = JSON.parse(localStorage.getItem('columnSizes'));
                if (sizes && sizes.length === panels.length) {
                    panels.forEach((id, index) => {
                        const panel = document.getElementById(id);
                        if (panel) panel.style.flexBasis = sizes[index];
                    });
                }
                const rowSizes = JSON.parse(localStorage.getItem('rowSizes'));
                if (rowSizes) {
                    const sessionWrapper = document.getElementById('sessionInfoWrapper');
                    const notesWrapper = document.getElementById('notesWrapper');
                    if (sessionWrapper) sessionWrapper.style.flexBasis = rowSizes.sessionInfoHeight;
                    if (notesWrapper) notesWrapper.style.flexBasis = rowSizes.notesHeight;
                }
            }

            function makeResizable(resizer, prev, next, direction = 'x') {
                if (!resizer || !prev || !next) return;
                let isResizing = false;
                resizer.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    isResizing = true;
                    const cursor = direction === 'x' ? 'col-resize' : 'row-resize';
                    document.body.style.cursor = cursor;
                    document.body.style.userSelect = 'none';

                    const mousemove = (e) => {
                        if (!isResizing) return;
                        const prevRect = prev.getBoundingClientRect();
                        const nextRect = next.getBoundingClientRect();
                        if (direction === 'x') {
                            const newPrevWidth = e.clientX - prevRect.left;
                            const newNextWidth = nextRect.right - e.clientX;
                            if (newPrevWidth > 150 && newNextWidth > 150) {
                                prev.style.flexBasis = `${newPrevWidth}px`;
                                next.style.flexBasis = `${newNextWidth}px`;
                            }
                        } else {
                            const newPrevHeight = e.clientY - prevRect.top;
                            const newNextHeight = nextRect.bottom - e.clientY;
                            if (newPrevHeight > 100 && newNextHeight > 100) {
                                prev.style.flexBasis = `${newPrevHeight}px`;
                                next.style.flexBasis = `${newNextHeight}px`;
                            }
                        }
                    };

                    const mouseup = () => {
                        isResizing = false;
                        window.removeEventListener('mousemove', mousemove);
                        window.removeEventListener('mouseup', mouseup);
                        document.body.style.cursor = '';
                        document.body.style.userSelect = '';
                        saveColumnSizes();
                    };
                    window.addEventListener('mousemove', mousemove);
                    window.addEventListener('mouseup', mouseup);
                });
            }
            makeResizable(document.getElementById('resizer1'), document.getElementById('panelClients'), document.getElementById('panelAppointments'), 'x');
            makeResizable(document.getElementById('resizer2'), document.getElementById('panelAppointments'), document.getElementById('panelSession'), 'x');
            makeResizable(document.getElementById('resizer3'), document.getElementById('panelSession'), document.getElementById('panelSoap'), 'x');
            makeResizable(document.getElementById('resizer-session-notes'), document.getElementById('sessionInfoWrapper'), document.getElementById('notesWrapper'), 'y');

            // --- Initial Load & Render ---
            const loadServerSettings = () => {
                const savedAddress = localStorage.getItem('serverAddress');
                const savedApiKey = localStorage.getItem('apiKey');
                if (savedAddress) {
                    serverAddressInput.value = savedAddress;
                    if(savedApiKey) apiKeyInput.value = savedApiKey;
                    connectToServer();
                }
            };

            loadServerSettings();
            loadDataFromCookie();
            loadColumnSizes();
            appointmentDateEl.value = new Date().toISOString().split('T')[0];
            fullRender();
        });
    </script>
</body>
</html>

